/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.2
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

#define SWIGCSHARP


#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif



#include <stdlib.h>
#include <string.h>
#include <stdio.h>


/* Support for throwing C# exceptions from C/C++. There are two types: 
 * Exceptions that take a message and ArgumentExceptions that take a message and a parameter name. */
typedef enum {
  SWIG_CSharpApplicationException,
  SWIG_CSharpArithmeticException,
  SWIG_CSharpDivideByZeroException,
  SWIG_CSharpIndexOutOfRangeException,
  SWIG_CSharpInvalidCastException,
  SWIG_CSharpInvalidOperationException,
  SWIG_CSharpIOException,
  SWIG_CSharpNullReferenceException,
  SWIG_CSharpOutOfMemoryException,
  SWIG_CSharpOverflowException,
  SWIG_CSharpSystemException
} SWIG_CSharpExceptionCodes;

typedef enum {
  SWIG_CSharpArgumentException,
  SWIG_CSharpArgumentNullException,
  SWIG_CSharpArgumentOutOfRangeException
} SWIG_CSharpExceptionArgumentCodes;

typedef void (SWIGSTDCALL* SWIG_CSharpExceptionCallback_t)(const char *);
typedef void (SWIGSTDCALL* SWIG_CSharpExceptionArgumentCallback_t)(const char *, const char *);

typedef struct {
  SWIG_CSharpExceptionCodes code;
  SWIG_CSharpExceptionCallback_t callback;
} SWIG_CSharpException_t;

typedef struct {
  SWIG_CSharpExceptionArgumentCodes code;
  SWIG_CSharpExceptionArgumentCallback_t callback;
} SWIG_CSharpExceptionArgument_t;

static SWIG_CSharpException_t SWIG_csharp_exceptions[] = {
  { SWIG_CSharpApplicationException, NULL },
  { SWIG_CSharpArithmeticException, NULL },
  { SWIG_CSharpDivideByZeroException, NULL },
  { SWIG_CSharpIndexOutOfRangeException, NULL },
  { SWIG_CSharpInvalidCastException, NULL },
  { SWIG_CSharpInvalidOperationException, NULL },
  { SWIG_CSharpIOException, NULL },
  { SWIG_CSharpNullReferenceException, NULL },
  { SWIG_CSharpOutOfMemoryException, NULL },
  { SWIG_CSharpOverflowException, NULL },
  { SWIG_CSharpSystemException, NULL }
};

static SWIG_CSharpExceptionArgument_t SWIG_csharp_exceptions_argument[] = {
  { SWIG_CSharpArgumentException, NULL },
  { SWIG_CSharpArgumentNullException, NULL },
  { SWIG_CSharpArgumentOutOfRangeException, NULL }
};

static void SWIGUNUSED SWIG_CSharpSetPendingException(SWIG_CSharpExceptionCodes code, const char *msg) {
  SWIG_CSharpExceptionCallback_t callback = SWIG_csharp_exceptions[SWIG_CSharpApplicationException].callback;
  if ((size_t)code < sizeof(SWIG_csharp_exceptions)/sizeof(SWIG_CSharpException_t)) {
    callback = SWIG_csharp_exceptions[code].callback;
  }
  callback(msg);
}

static void SWIGUNUSED SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpExceptionArgumentCodes code, const char *msg, const char *param_name) {
  SWIG_CSharpExceptionArgumentCallback_t callback = SWIG_csharp_exceptions_argument[SWIG_CSharpArgumentException].callback;
  if ((size_t)code < sizeof(SWIG_csharp_exceptions_argument)/sizeof(SWIG_CSharpExceptionArgument_t)) {
    callback = SWIG_csharp_exceptions_argument[code].callback;
  }
  callback(msg, param_name);
}


#ifdef __cplusplus
extern "C" 
#endif
SWIGEXPORT void SWIGSTDCALL SWIGRegisterExceptionCallbacks_SharpMocha(
                                                SWIG_CSharpExceptionCallback_t applicationCallback,
                                                SWIG_CSharpExceptionCallback_t arithmeticCallback,
                                                SWIG_CSharpExceptionCallback_t divideByZeroCallback, 
                                                SWIG_CSharpExceptionCallback_t indexOutOfRangeCallback, 
                                                SWIG_CSharpExceptionCallback_t invalidCastCallback,
                                                SWIG_CSharpExceptionCallback_t invalidOperationCallback,
                                                SWIG_CSharpExceptionCallback_t ioCallback,
                                                SWIG_CSharpExceptionCallback_t nullReferenceCallback,
                                                SWIG_CSharpExceptionCallback_t outOfMemoryCallback, 
                                                SWIG_CSharpExceptionCallback_t overflowCallback, 
                                                SWIG_CSharpExceptionCallback_t systemCallback) {
  SWIG_csharp_exceptions[SWIG_CSharpApplicationException].callback = applicationCallback;
  SWIG_csharp_exceptions[SWIG_CSharpArithmeticException].callback = arithmeticCallback;
  SWIG_csharp_exceptions[SWIG_CSharpDivideByZeroException].callback = divideByZeroCallback;
  SWIG_csharp_exceptions[SWIG_CSharpIndexOutOfRangeException].callback = indexOutOfRangeCallback;
  SWIG_csharp_exceptions[SWIG_CSharpInvalidCastException].callback = invalidCastCallback;
  SWIG_csharp_exceptions[SWIG_CSharpInvalidOperationException].callback = invalidOperationCallback;
  SWIG_csharp_exceptions[SWIG_CSharpIOException].callback = ioCallback;
  SWIG_csharp_exceptions[SWIG_CSharpNullReferenceException].callback = nullReferenceCallback;
  SWIG_csharp_exceptions[SWIG_CSharpOutOfMemoryException].callback = outOfMemoryCallback;
  SWIG_csharp_exceptions[SWIG_CSharpOverflowException].callback = overflowCallback;
  SWIG_csharp_exceptions[SWIG_CSharpSystemException].callback = systemCallback;
}

#ifdef __cplusplus
extern "C" 
#endif
SWIGEXPORT void SWIGSTDCALL SWIGRegisterExceptionArgumentCallbacks_SharpMocha(
                                                SWIG_CSharpExceptionArgumentCallback_t argumentCallback,
                                                SWIG_CSharpExceptionArgumentCallback_t argumentNullCallback,
                                                SWIG_CSharpExceptionArgumentCallback_t argumentOutOfRangeCallback) {
  SWIG_csharp_exceptions_argument[SWIG_CSharpArgumentException].callback = argumentCallback;
  SWIG_csharp_exceptions_argument[SWIG_CSharpArgumentNullException].callback = argumentNullCallback;
  SWIG_csharp_exceptions_argument[SWIG_CSharpArgumentOutOfRangeException].callback = argumentOutOfRangeCallback;
}


/* Callback for returning strings to C# without leaking memory */
typedef char * (SWIGSTDCALL* SWIG_CSharpStringHelperCallback)(const char *);
static SWIG_CSharpStringHelperCallback SWIG_csharp_string_callback = NULL;


#ifdef __cplusplus
extern "C" 
#endif
SWIGEXPORT void SWIGSTDCALL SWIGRegisterStringCallback_SharpMocha(SWIG_CSharpStringHelperCallback callback) {
  SWIG_csharp_string_callback = callback;
}


/* Contract support */

#define SWIG_contract_assert(nullreturn, expr, msg) if (!(expr)) {SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, msg, ""); return nullreturn; } else


#include <string>


#include <stdexcept>


#include <vector>
#include <algorithm>
#include <stdexcept>


#include <set>
#include <algorithm>
#include <stdexcept>


#include <list>
#include <stdexcept>


#include <map>
#include <algorithm>
#include <stdexcept>

SWIGINTERN std::vector< int > *new_std_vector_Sl_int_Sg___SWIG_2(int capacity){
        std::vector< int >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< int >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN int std_vector_Sl_int_Sg__getitemcopy(std::vector< int > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN int const &std_vector_Sl_int_Sg__getitem(std::vector< int > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_int_Sg__setitem(std::vector< int > *self,int index,int const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_int_Sg__AddRange(std::vector< int > *self,std::vector< int > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< int > *std_vector_Sl_int_Sg__GetRange(std::vector< int > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< int >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_int_Sg__Insert(std::vector< int > *self,int index,int const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_int_Sg__InsertRange(std::vector< int > *self,int index,std::vector< int > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_int_Sg__RemoveAt(std::vector< int > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_int_Sg__RemoveRange(std::vector< int > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< int > *std_vector_Sl_int_Sg__Repeat(int const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< int >(count, value);
      }
SWIGINTERN void std_vector_Sl_int_Sg__Reverse__SWIG_0(std::vector< int > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_int_Sg__Reverse__SWIG_1(std::vector< int > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_int_Sg__SetRange(std::vector< int > *self,int index,std::vector< int > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN bool std_vector_Sl_int_Sg__Contains(std::vector< int > *self,int const &value){
        return std::find(self->begin(), self->end(), value) != self->end();
      }
SWIGINTERN int std_vector_Sl_int_Sg__IndexOf(std::vector< int > *self,int const &value){
        int index = -1;
        std::vector< int >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end())
          index = (int)(it - self->begin());
        return index;
      }
SWIGINTERN int std_vector_Sl_int_Sg__LastIndexOf(std::vector< int > *self,int const &value){
        int index = -1;
        std::vector< int >::reverse_iterator rit = std::find(self->rbegin(), self->rend(), value);
        if (rit != self->rend())
          index = (int)(self->rend() - 1 - rit);
        return index;
      }
SWIGINTERN bool std_vector_Sl_int_Sg__Remove(std::vector< int > *self,int const &value){
        std::vector< int >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end()) {
          self->erase(it);
	  return true;
        }
        return false;
      }

#include "Math/Vector3.h"
	

#include "Color.h"
	

#include "Math/EulerAngles.h"


#include "Vertex.h"


#include "MathIncludes.h"


#include "metadef.h"


#include "LayerMask.h"


#include "GameObject.h"
	
SWIGINTERN std::vector< Component * > *new_std_vector_Sl_Component_Sm__Sg___SWIG_2(int capacity){
        std::vector< Component * >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< Component * >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN Component *std_vector_Sl_Component_Sm__Sg__getitemcopy(std::vector< Component * > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN Component *const &std_vector_Sl_Component_Sm__Sg__getitem(std::vector< Component * > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_Component_Sm__Sg__setitem(std::vector< Component * > *self,int index,Component *const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_Component_Sm__Sg__AddRange(std::vector< Component * > *self,std::vector< Component * > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< Component * > *std_vector_Sl_Component_Sm__Sg__GetRange(std::vector< Component * > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< Component * >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_Component_Sm__Sg__Insert(std::vector< Component * > *self,int index,Component *const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_Component_Sm__Sg__InsertRange(std::vector< Component * > *self,int index,std::vector< Component * > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_Component_Sm__Sg__RemoveAt(std::vector< Component * > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_Component_Sm__Sg__RemoveRange(std::vector< Component * > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< Component * > *std_vector_Sl_Component_Sm__Sg__Repeat(Component *const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< Component * >(count, value);
      }
SWIGINTERN void std_vector_Sl_Component_Sm__Sg__Reverse__SWIG_0(std::vector< Component * > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_Component_Sm__Sg__Reverse__SWIG_1(std::vector< Component * > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_Component_Sm__Sg__SetRange(std::vector< Component * > *self,int index,std::vector< Component * > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN bool std_vector_Sl_Component_Sm__Sg__Contains(std::vector< Component * > *self,Component *const &value){
        return std::find(self->begin(), self->end(), value) != self->end();
      }
SWIGINTERN int std_vector_Sl_Component_Sm__Sg__IndexOf(std::vector< Component * > *self,Component *const &value){
        int index = -1;
        std::vector< Component * >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end())
          index = (int)(it - self->begin());
        return index;
      }
SWIGINTERN int std_vector_Sl_Component_Sm__Sg__LastIndexOf(std::vector< Component * > *self,Component *const &value){
        int index = -1;
        std::vector< Component * >::reverse_iterator rit = std::find(self->rbegin(), self->rend(), value);
        if (rit != self->rend())
          index = (int)(self->rend() - 1 - rit);
        return index;
      }
SWIGINTERN bool std_vector_Sl_Component_Sm__Sg__Remove(std::vector< Component * > *self,Component *const &value){
        std::vector< Component * >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end()) {
          self->erase(it);
	  return true;
        }
        return false;
      }
SWIGINTERN std::set< string >::value_type const &std_set_Sl_string_Sg__getitem(std::set< string > *self,std::set< string >::value_type const &val){
        std::set< std::string >::iterator iter = self->find(val);
        if (iter != self->end())
          return *iter;
        else
          throw std::out_of_range("key not found");
      }
SWIGINTERN void std_set_Sl_string_Sg__setitem(std::set< string > *self,std::set< string >::value_type const &x){
        (*self).insert(x);
      }
SWIGINTERN bool std_set_Sl_string_Sg__Contains(std::set< string > *self,std::set< string >::value_type const &val){
        std::set< std::string >::iterator iter = self->find(val);
        return iter != self->end();
      }
SWIGINTERN void std_set_Sl_string_Sg__Add(std::set< string > *self,std::set< string >::value_type const &val){
        std::set< std::string >::iterator iter = self->find(val);
        if (iter != self->end())
          throw std::out_of_range("key already exists");
        self->insert(val);
      }
SWIGINTERN bool std_set_Sl_string_Sg__Remove(std::set< string > *self,std::set< string >::value_type const &val){
        std::set< std::string >::iterator iter = self->find(val);
        if (iter != self->end()) {
          self->erase(iter);
          return true;
        }
        return false;
      }
SWIGINTERN std::set< std::string >::iterator *std_set_Sl_string_Sg__create_iterator_begin(std::set< string > *self){
        return new std::set< std::string >::iterator(self->begin());
      }
SWIGINTERN bool std_set_Sl_string_Sg__is_iterator_good(std::set< string > *self,std::set< std::string >::iterator *swigier){
		  if (*swigier == self->end())
			  return false;
		  return true;
	  }
SWIGINTERN std::set< string >::value_type const &std_set_Sl_string_Sg__get_next_key(std::set< string > *self,std::set< std::string >::iterator *swigiterator){
		  std::set< std::string >::iterator iter = *swigiterator;
		  (*swigiterator)++;
        return *iter;
      }
SWIGINTERN void std_set_Sl_string_Sg__destroy_iterator(std::set< string > *self,std::set< std::string >::iterator *swigiterator){
        delete swigiterator;
      }

#include "ret.h"

SWIGINTERN std::set< GameObject * >::value_type const &std_set_Sl_GameObject_Sm__Sg__getitem(std::set< GameObject * > *self,std::set< GameObject * >::value_type const &val){
        std::set< GameObject * >::iterator iter = self->find(val);
        if (iter != self->end())
          return *iter;
        else
          throw std::out_of_range("key not found");
      }
SWIGINTERN void std_set_Sl_GameObject_Sm__Sg__setitem(std::set< GameObject * > *self,std::set< GameObject * >::value_type const &x){
        (*self).insert(x);
      }
SWIGINTERN bool std_set_Sl_GameObject_Sm__Sg__Contains(std::set< GameObject * > *self,std::set< GameObject * >::value_type const &val){
        std::set< GameObject * >::iterator iter = self->find(val);
        return iter != self->end();
      }
SWIGINTERN void std_set_Sl_GameObject_Sm__Sg__Add(std::set< GameObject * > *self,std::set< GameObject * >::value_type const &val){
        std::set< GameObject * >::iterator iter = self->find(val);
        if (iter != self->end())
          throw std::out_of_range("key already exists");
        self->insert(val);
      }
SWIGINTERN bool std_set_Sl_GameObject_Sm__Sg__Remove(std::set< GameObject * > *self,std::set< GameObject * >::value_type const &val){
        std::set< GameObject * >::iterator iter = self->find(val);
        if (iter != self->end()) {
          self->erase(iter);
          return true;
        }
        return false;
      }
SWIGINTERN std::set< GameObject * >::iterator *std_set_Sl_GameObject_Sm__Sg__create_iterator_begin(std::set< GameObject * > *self){
        return new std::set< GameObject * >::iterator(self->begin());
      }
SWIGINTERN bool std_set_Sl_GameObject_Sm__Sg__is_iterator_good(std::set< GameObject * > *self,std::set< GameObject * >::iterator *swigier){
		  if (*swigier == self->end())
			  return false;
		  return true;
	  }
SWIGINTERN std::set< GameObject * >::value_type const &std_set_Sl_GameObject_Sm__Sg__get_next_key(std::set< GameObject * > *self,std::set< GameObject * >::iterator *swigiterator){
		  std::set< GameObject * >::iterator iter = *swigiterator;
		  (*swigiterator)++;
        return *iter;
      }
SWIGINTERN void std_set_Sl_GameObject_Sm__Sg__destroy_iterator(std::set< GameObject * > *self,std::set< GameObject * >::iterator *swigiterator){
        delete swigiterator;
      }

#include "Engine.h"
	

#include "MochaWindow.h"


#include "AssetManager.h"
#include "Asset.h"
#include "Mesh.h"
#include "Sound.h"
#include "SkinnedMesh.h"

SWIGINTERN std::vector< Vertex > *new_std_vector_Sl_Vertex_Sg___SWIG_2(int capacity){
        std::vector< Vertex >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< Vertex >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN Vertex std_vector_Sl_Vertex_Sg__getitemcopy(std::vector< Vertex > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN Vertex const &std_vector_Sl_Vertex_Sg__getitem(std::vector< Vertex > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_Vertex_Sg__setitem(std::vector< Vertex > *self,int index,Vertex const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_Vertex_Sg__AddRange(std::vector< Vertex > *self,std::vector< Vertex > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< Vertex > *std_vector_Sl_Vertex_Sg__GetRange(std::vector< Vertex > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< Vertex >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_Vertex_Sg__Insert(std::vector< Vertex > *self,int index,Vertex const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_Vertex_Sg__InsertRange(std::vector< Vertex > *self,int index,std::vector< Vertex > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_Vertex_Sg__RemoveAt(std::vector< Vertex > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_Vertex_Sg__RemoveRange(std::vector< Vertex > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< Vertex > *std_vector_Sl_Vertex_Sg__Repeat(Vertex const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< Vertex >(count, value);
      }
SWIGINTERN void std_vector_Sl_Vertex_Sg__Reverse__SWIG_0(std::vector< Vertex > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_Vertex_Sg__Reverse__SWIG_1(std::vector< Vertex > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_Vertex_Sg__SetRange(std::vector< Vertex > *self,int index,std::vector< Vertex > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }

#include "BaseState.h"


#include "ObjectFactory.h"


#include "GSM.h"


#include "StateSerializer.h"

SWIGINTERN std::vector< bool > *new_std_vector_Sl_bool_Sg___SWIG_2(int capacity){
        std::vector< bool >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< bool >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN bool std_vector_Sl_bool_Sg__getitemcopy(std::vector< bool > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN bool std_vector_Sl_bool_Sg__getitem(std::vector< bool > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_bool_Sg__setitem(std::vector< bool > *self,int index,bool const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_bool_Sg__AddRange(std::vector< bool > *self,std::vector< bool > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< bool > *std_vector_Sl_bool_Sg__GetRange(std::vector< bool > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< bool >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_bool_Sg__Insert(std::vector< bool > *self,int index,bool const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_bool_Sg__InsertRange(std::vector< bool > *self,int index,std::vector< bool > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_bool_Sg__RemoveAt(std::vector< bool > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_bool_Sg__RemoveRange(std::vector< bool > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< bool > *std_vector_Sl_bool_Sg__Repeat(bool const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< bool >(count, value);
      }
SWIGINTERN void std_vector_Sl_bool_Sg__Reverse__SWIG_0(std::vector< bool > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_bool_Sg__Reverse__SWIG_1(std::vector< bool > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_bool_Sg__SetRange(std::vector< bool > *self,int index,std::vector< bool > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN bool std_vector_Sl_bool_Sg__Contains(std::vector< bool > *self,bool const &value){
        return std::find(self->begin(), self->end(), value) != self->end();
      }
SWIGINTERN int std_vector_Sl_bool_Sg__IndexOf(std::vector< bool > *self,bool const &value){
        int index = -1;
        std::vector< bool >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end())
          index = (int)(it - self->begin());
        return index;
      }
SWIGINTERN int std_vector_Sl_bool_Sg__LastIndexOf(std::vector< bool > *self,bool const &value){
        int index = -1;
        std::vector< bool >::reverse_iterator rit = std::find(self->rbegin(), self->rend(), value);
        if (rit != self->rend())
          index = (int)(self->rend() - 1 - rit);
        return index;
      }
SWIGINTERN bool std_vector_Sl_bool_Sg__Remove(std::vector< bool > *self,bool const &value){
        std::vector< bool >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end()) {
          self->erase(it);
	  return true;
        }
        return false;
      }
SWIGINTERN std::vector< StateObjDesc > *new_std_vector_Sl_StateObjDesc_Sg___SWIG_2(int capacity){
        std::vector< StateObjDesc >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< StateObjDesc >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN StateObjDesc std_vector_Sl_StateObjDesc_Sg__getitemcopy(std::vector< StateObjDesc > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN StateObjDesc const &std_vector_Sl_StateObjDesc_Sg__getitem(std::vector< StateObjDesc > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_StateObjDesc_Sg__setitem(std::vector< StateObjDesc > *self,int index,StateObjDesc const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_StateObjDesc_Sg__AddRange(std::vector< StateObjDesc > *self,std::vector< StateObjDesc > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< StateObjDesc > *std_vector_Sl_StateObjDesc_Sg__GetRange(std::vector< StateObjDesc > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< StateObjDesc >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_StateObjDesc_Sg__Insert(std::vector< StateObjDesc > *self,int index,StateObjDesc const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_StateObjDesc_Sg__InsertRange(std::vector< StateObjDesc > *self,int index,std::vector< StateObjDesc > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_StateObjDesc_Sg__RemoveAt(std::vector< StateObjDesc > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_StateObjDesc_Sg__RemoveRange(std::vector< StateObjDesc > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< StateObjDesc > *std_vector_Sl_StateObjDesc_Sg__Repeat(StateObjDesc const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< StateObjDesc >(count, value);
      }
SWIGINTERN void std_vector_Sl_StateObjDesc_Sg__Reverse__SWIG_0(std::vector< StateObjDesc > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_StateObjDesc_Sg__Reverse__SWIG_1(std::vector< StateObjDesc > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_StateObjDesc_Sg__SetRange(std::vector< StateObjDesc > *self,int index,std::vector< StateObjDesc > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }

#include "Barrista.h"

SWIGINTERN std::vector< Barrista::operation_info > *new_std_vector_Sl_Barrista_operation_info_Sg___SWIG_2(int capacity){
        std::vector< Barrista::operation_info >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< Barrista::operation_info >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN Barrista::operation_info std_vector_Sl_Barrista_operation_info_Sg__getitemcopy(std::vector< Barrista::operation_info > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN Barrista::operation_info const &std_vector_Sl_Barrista_operation_info_Sg__getitem(std::vector< Barrista::operation_info > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_Barrista_operation_info_Sg__setitem(std::vector< Barrista::operation_info > *self,int index,Barrista::operation_info const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_Barrista_operation_info_Sg__AddRange(std::vector< Barrista::operation_info > *self,std::vector< Barrista::operation_info > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< Barrista::operation_info > *std_vector_Sl_Barrista_operation_info_Sg__GetRange(std::vector< Barrista::operation_info > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< Barrista::operation_info >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_Barrista_operation_info_Sg__Insert(std::vector< Barrista::operation_info > *self,int index,Barrista::operation_info const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_Barrista_operation_info_Sg__InsertRange(std::vector< Barrista::operation_info > *self,int index,std::vector< Barrista::operation_info > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_Barrista_operation_info_Sg__RemoveAt(std::vector< Barrista::operation_info > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_Barrista_operation_info_Sg__RemoveRange(std::vector< Barrista::operation_info > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< Barrista::operation_info > *std_vector_Sl_Barrista_operation_info_Sg__Repeat(Barrista::operation_info const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< Barrista::operation_info >(count, value);
      }
SWIGINTERN void std_vector_Sl_Barrista_operation_info_Sg__Reverse__SWIG_0(std::vector< Barrista::operation_info > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_Barrista_operation_info_Sg__Reverse__SWIG_1(std::vector< Barrista::operation_info > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_Barrista_operation_info_Sg__SetRange(std::vector< Barrista::operation_info > *self,int index,std::vector< Barrista::operation_info > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }

#include "ScriptSubsystem.h"


#include "EditorSubsystem.h"

SWIGINTERN std::vector< GameObject * > *new_std_vector_Sl_GameObject_Sm__Sg___SWIG_2(int capacity){
        std::vector< GameObject * >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< GameObject * >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN GameObject *std_vector_Sl_GameObject_Sm__Sg__getitemcopy(std::vector< GameObject * > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN GameObject *const &std_vector_Sl_GameObject_Sm__Sg__getitem(std::vector< GameObject * > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_GameObject_Sm__Sg__setitem(std::vector< GameObject * > *self,int index,GameObject *const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_GameObject_Sm__Sg__AddRange(std::vector< GameObject * > *self,std::vector< GameObject * > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< GameObject * > *std_vector_Sl_GameObject_Sm__Sg__GetRange(std::vector< GameObject * > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< GameObject * >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_GameObject_Sm__Sg__Insert(std::vector< GameObject * > *self,int index,GameObject *const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_GameObject_Sm__Sg__InsertRange(std::vector< GameObject * > *self,int index,std::vector< GameObject * > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_GameObject_Sm__Sg__RemoveAt(std::vector< GameObject * > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_GameObject_Sm__Sg__RemoveRange(std::vector< GameObject * > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< GameObject * > *std_vector_Sl_GameObject_Sm__Sg__Repeat(GameObject *const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< GameObject * >(count, value);
      }
SWIGINTERN void std_vector_Sl_GameObject_Sm__Sg__Reverse__SWIG_0(std::vector< GameObject * > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_GameObject_Sm__Sg__Reverse__SWIG_1(std::vector< GameObject * > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_GameObject_Sm__Sg__SetRange(std::vector< GameObject * > *self,int index,std::vector< GameObject * > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN bool std_vector_Sl_GameObject_Sm__Sg__Contains(std::vector< GameObject * > *self,GameObject *const &value){
        return std::find(self->begin(), self->end(), value) != self->end();
      }
SWIGINTERN int std_vector_Sl_GameObject_Sm__Sg__IndexOf(std::vector< GameObject * > *self,GameObject *const &value){
        int index = -1;
        std::vector< GameObject * >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end())
          index = (int)(it - self->begin());
        return index;
      }
SWIGINTERN int std_vector_Sl_GameObject_Sm__Sg__LastIndexOf(std::vector< GameObject * > *self,GameObject *const &value){
        int index = -1;
        std::vector< GameObject * >::reverse_iterator rit = std::find(self->rbegin(), self->rend(), value);
        if (rit != self->rend())
          index = (int)(self->rend() - 1 - rit);
        return index;
      }
SWIGINTERN bool std_vector_Sl_GameObject_Sm__Sg__Remove(std::vector< GameObject * > *self,GameObject *const &value){
        std::vector< GameObject * >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end()) {
          self->erase(it);
	  return true;
        }
        return false;
      }

#include "Material.h"
#include "MaterialImpl.h"
#include "TextureNode.h"
#include "ShaderNode.h"
#include "UVTransformNode.h"
#include "ColorNode.h"

SWIGINTERN std::vector< MatAttribNode * > *new_std_vector_Sl_MatAttribNode_Sm__Sg___SWIG_2(int capacity){
        std::vector< MatAttribNode * >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< MatAttribNode * >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN MatAttribNode *std_vector_Sl_MatAttribNode_Sm__Sg__getitemcopy(std::vector< MatAttribNode * > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN MatAttribNode *const &std_vector_Sl_MatAttribNode_Sm__Sg__getitem(std::vector< MatAttribNode * > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_MatAttribNode_Sm__Sg__setitem(std::vector< MatAttribNode * > *self,int index,MatAttribNode *const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_MatAttribNode_Sm__Sg__AddRange(std::vector< MatAttribNode * > *self,std::vector< MatAttribNode * > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< MatAttribNode * > *std_vector_Sl_MatAttribNode_Sm__Sg__GetRange(std::vector< MatAttribNode * > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< MatAttribNode * >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_MatAttribNode_Sm__Sg__Insert(std::vector< MatAttribNode * > *self,int index,MatAttribNode *const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_MatAttribNode_Sm__Sg__InsertRange(std::vector< MatAttribNode * > *self,int index,std::vector< MatAttribNode * > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_MatAttribNode_Sm__Sg__RemoveAt(std::vector< MatAttribNode * > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_MatAttribNode_Sm__Sg__RemoveRange(std::vector< MatAttribNode * > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< MatAttribNode * > *std_vector_Sl_MatAttribNode_Sm__Sg__Repeat(MatAttribNode *const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< MatAttribNode * >(count, value);
      }
SWIGINTERN void std_vector_Sl_MatAttribNode_Sm__Sg__Reverse__SWIG_0(std::vector< MatAttribNode * > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_MatAttribNode_Sm__Sg__Reverse__SWIG_1(std::vector< MatAttribNode * > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_MatAttribNode_Sm__Sg__SetRange(std::vector< MatAttribNode * > *self,int index,std::vector< MatAttribNode * > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN bool std_vector_Sl_MatAttribNode_Sm__Sg__Contains(std::vector< MatAttribNode * > *self,MatAttribNode *const &value){
        return std::find(self->begin(), self->end(), value) != self->end();
      }
SWIGINTERN int std_vector_Sl_MatAttribNode_Sm__Sg__IndexOf(std::vector< MatAttribNode * > *self,MatAttribNode *const &value){
        int index = -1;
        std::vector< MatAttribNode * >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end())
          index = (int)(it - self->begin());
        return index;
      }
SWIGINTERN int std_vector_Sl_MatAttribNode_Sm__Sg__LastIndexOf(std::vector< MatAttribNode * > *self,MatAttribNode *const &value){
        int index = -1;
        std::vector< MatAttribNode * >::reverse_iterator rit = std::find(self->rbegin(), self->rend(), value);
        if (rit != self->rend())
          index = (int)(self->rend() - 1 - rit);
        return index;
      }
SWIGINTERN bool std_vector_Sl_MatAttribNode_Sm__Sg__Remove(std::vector< MatAttribNode * > *self,MatAttribNode *const &value){
        std::vector< MatAttribNode * >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end()) {
          self->erase(it);
	  return true;
        }
        return false;
      }
SWIGINTERN std::map< unsigned int,std::vector< MatAttribNode * > >::mapped_type const &std_map_Sl_unsigned_SS_int_Sc_std_vector_Sl_MatAttribNode_Sm__Sg__Sg__getitem(std::map< unsigned int,std::vector< MatAttribNode * > > *self,std::map< unsigned int,std::vector< MatAttribNode * > >::key_type const &key){
        std::map< unsigned int, std::vector< MatAttribNode * >, std::less< unsigned int > >::iterator iter = self->find(key);
        if (iter != self->end())
          return iter->second;
        else
          throw std::out_of_range("key not found");
      }
SWIGINTERN void std_map_Sl_unsigned_SS_int_Sc_std_vector_Sl_MatAttribNode_Sm__Sg__Sg__setitem(std::map< unsigned int,std::vector< MatAttribNode * > > *self,std::map< unsigned int,std::vector< MatAttribNode * > >::key_type const &key,std::map< unsigned int,std::vector< MatAttribNode * > >::mapped_type const &x){
        (*self)[key] = x;
      }
SWIGINTERN bool std_map_Sl_unsigned_SS_int_Sc_std_vector_Sl_MatAttribNode_Sm__Sg__Sg__ContainsKey(std::map< unsigned int,std::vector< MatAttribNode * > > *self,std::map< unsigned int,std::vector< MatAttribNode * > >::key_type const &key){
        std::map< unsigned int, std::vector< MatAttribNode * >, std::less< unsigned int > >::iterator iter = self->find(key);
        return iter != self->end();
      }
SWIGINTERN void std_map_Sl_unsigned_SS_int_Sc_std_vector_Sl_MatAttribNode_Sm__Sg__Sg__Add(std::map< unsigned int,std::vector< MatAttribNode * > > *self,std::map< unsigned int,std::vector< MatAttribNode * > >::key_type const &key,std::map< unsigned int,std::vector< MatAttribNode * > >::mapped_type const &val){
        std::map< unsigned int, std::vector< MatAttribNode * >, std::less< unsigned int > >::iterator iter = self->find(key);
        if (iter != self->end())
          throw std::out_of_range("key already exists");
        self->insert(std::pair< unsigned int, std::vector< MatAttribNode * > >(key, val));
      }
SWIGINTERN bool std_map_Sl_unsigned_SS_int_Sc_std_vector_Sl_MatAttribNode_Sm__Sg__Sg__Remove(std::map< unsigned int,std::vector< MatAttribNode * > > *self,std::map< unsigned int,std::vector< MatAttribNode * > >::key_type const &key){
        std::map< unsigned int, std::vector< MatAttribNode * >, std::less< unsigned int > >::iterator iter = self->find(key);
        if (iter != self->end()) {
          self->erase(iter);
          return true;
        }                
        return false;
      }
SWIGINTERN std::map< unsigned int,std::vector< MatAttribNode * >,std::less< unsigned int > >::iterator *std_map_Sl_unsigned_SS_int_Sc_std_vector_Sl_MatAttribNode_Sm__Sg__Sg__create_iterator_begin(std::map< unsigned int,std::vector< MatAttribNode * > > *self){
        return new std::map< unsigned int, std::vector< MatAttribNode * >, std::less< unsigned int > >::iterator(self->begin());
      }
SWIGINTERN std::map< unsigned int,std::vector< MatAttribNode * > >::key_type const &std_map_Sl_unsigned_SS_int_Sc_std_vector_Sl_MatAttribNode_Sm__Sg__Sg__get_next_key(std::map< unsigned int,std::vector< MatAttribNode * > > *self,std::map< unsigned int,std::vector< MatAttribNode * >,std::less< unsigned int > >::iterator *swigiterator){
        std::map< unsigned int, std::vector< MatAttribNode * >, std::less< unsigned int > >::iterator iter = *swigiterator;
        (*swigiterator)++;
        return (*iter).first;
      }
SWIGINTERN void std_map_Sl_unsigned_SS_int_Sc_std_vector_Sl_MatAttribNode_Sm__Sg__Sg__destroy_iterator(std::map< unsigned int,std::vector< MatAttribNode * > > *self,std::map< unsigned int,std::vector< MatAttribNode * >,std::less< unsigned int > >::iterator *swigiterator){
        delete swigiterator;
      }

#include "FrameController.h"


#include "Input.h"


#include "PhysicsEngine.h"
#include "MathIncludes.h"


#include "Animation.h"


#include "Sound.h"


#include "Oculus.h"


#include "Renderer.h"


#include "Prefab.h"


#include "AudioManager.h"
	

#include "Component.h"


#include "CTransform.h"

SWIGINTERN std::vector< CTransform * > *new_std_vector_Sl_CTransform_Sm__Sg___SWIG_2(int capacity){
        std::vector< CTransform * >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< CTransform * >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN CTransform *std_vector_Sl_CTransform_Sm__Sg__getitemcopy(std::vector< CTransform * > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN CTransform *const &std_vector_Sl_CTransform_Sm__Sg__getitem(std::vector< CTransform * > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CTransform_Sm__Sg__setitem(std::vector< CTransform * > *self,int index,CTransform *const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CTransform_Sm__Sg__AddRange(std::vector< CTransform * > *self,std::vector< CTransform * > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< CTransform * > *std_vector_Sl_CTransform_Sm__Sg__GetRange(std::vector< CTransform * > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< CTransform * >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_CTransform_Sm__Sg__Insert(std::vector< CTransform * > *self,int index,CTransform *const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CTransform_Sm__Sg__InsertRange(std::vector< CTransform * > *self,int index,std::vector< CTransform * > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CTransform_Sm__Sg__RemoveAt(std::vector< CTransform * > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CTransform_Sm__Sg__RemoveRange(std::vector< CTransform * > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< CTransform * > *std_vector_Sl_CTransform_Sm__Sg__Repeat(CTransform *const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< CTransform * >(count, value);
      }
SWIGINTERN void std_vector_Sl_CTransform_Sm__Sg__Reverse__SWIG_0(std::vector< CTransform * > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_CTransform_Sm__Sg__Reverse__SWIG_1(std::vector< CTransform * > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_CTransform_Sm__Sg__SetRange(std::vector< CTransform * > *self,int index,std::vector< CTransform * > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN bool std_vector_Sl_CTransform_Sm__Sg__Contains(std::vector< CTransform * > *self,CTransform *const &value){
        return std::find(self->begin(), self->end(), value) != self->end();
      }
SWIGINTERN int std_vector_Sl_CTransform_Sm__Sg__IndexOf(std::vector< CTransform * > *self,CTransform *const &value){
        int index = -1;
        std::vector< CTransform * >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end())
          index = (int)(it - self->begin());
        return index;
      }
SWIGINTERN int std_vector_Sl_CTransform_Sm__Sg__LastIndexOf(std::vector< CTransform * > *self,CTransform *const &value){
        int index = -1;
        std::vector< CTransform * >::reverse_iterator rit = std::find(self->rbegin(), self->rend(), value);
        if (rit != self->rend())
          index = (int)(self->rend() - 1 - rit);
        return index;
      }
SWIGINTERN bool std_vector_Sl_CTransform_Sm__Sg__Remove(std::vector< CTransform * > *self,CTransform *const &value){
        std::vector< CTransform * >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end()) {
          self->erase(it);
	  return true;
        }
        return false;
      }

#include "CRenderer.h"
#include "AABB.h"


#include "CMeshRenderer.h"


#include "CSkinMeshRenderer.h"


#include "CAnimationController.h"

SWIGINTERN std::vector< AssetHandle > *new_std_vector_Sl_AssetHandle_Sg___SWIG_2(int capacity){
        std::vector< AssetHandle >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< AssetHandle >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN AssetHandle std_vector_Sl_AssetHandle_Sg__getitemcopy(std::vector< AssetHandle > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN AssetHandle const &std_vector_Sl_AssetHandle_Sg__getitem(std::vector< AssetHandle > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_AssetHandle_Sg__setitem(std::vector< AssetHandle > *self,int index,AssetHandle const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_AssetHandle_Sg__AddRange(std::vector< AssetHandle > *self,std::vector< AssetHandle > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< AssetHandle > *std_vector_Sl_AssetHandle_Sg__GetRange(std::vector< AssetHandle > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< AssetHandle >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_AssetHandle_Sg__Insert(std::vector< AssetHandle > *self,int index,AssetHandle const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_AssetHandle_Sg__InsertRange(std::vector< AssetHandle > *self,int index,std::vector< AssetHandle > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_AssetHandle_Sg__RemoveAt(std::vector< AssetHandle > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_AssetHandle_Sg__RemoveRange(std::vector< AssetHandle > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< AssetHandle > *std_vector_Sl_AssetHandle_Sg__Repeat(AssetHandle const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< AssetHandle >(count, value);
      }
SWIGINTERN void std_vector_Sl_AssetHandle_Sg__Reverse__SWIG_0(std::vector< AssetHandle > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_AssetHandle_Sg__Reverse__SWIG_1(std::vector< AssetHandle > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_AssetHandle_Sg__SetRange(std::vector< AssetHandle > *self,int index,std::vector< AssetHandle > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }

#include "CLight.h"
	

#include "CPhysics.h"
	
SWIGINTERN std::vector< Math::Vector3 > *new_std_vector_Sl_Math_Vector3_Sg___SWIG_2(int capacity){
        std::vector< Math::Vector3 >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< Math::Vector3 >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN Math::Vector3 std_vector_Sl_Math_Vector3_Sg__getitemcopy(std::vector< Math::Vector3 > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN Math::Vector3 const &std_vector_Sl_Math_Vector3_Sg__getitem(std::vector< Math::Vector3 > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_Math_Vector3_Sg__setitem(std::vector< Math::Vector3 > *self,int index,Math::Vector3 const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_Math_Vector3_Sg__AddRange(std::vector< Math::Vector3 > *self,std::vector< Math::Vector3 > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< Math::Vector3 > *std_vector_Sl_Math_Vector3_Sg__GetRange(std::vector< Math::Vector3 > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< Math::Vector3 >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_Math_Vector3_Sg__Insert(std::vector< Math::Vector3 > *self,int index,Math::Vector3 const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_Math_Vector3_Sg__InsertRange(std::vector< Math::Vector3 > *self,int index,std::vector< Math::Vector3 > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_Math_Vector3_Sg__RemoveAt(std::vector< Math::Vector3 > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_Math_Vector3_Sg__RemoveRange(std::vector< Math::Vector3 > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< Math::Vector3 > *std_vector_Sl_Math_Vector3_Sg__Repeat(Math::Vector3 const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< Math::Vector3 >(count, value);
      }
SWIGINTERN void std_vector_Sl_Math_Vector3_Sg__Reverse__SWIG_0(std::vector< Math::Vector3 > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_Math_Vector3_Sg__Reverse__SWIG_1(std::vector< Math::Vector3 > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_Math_Vector3_Sg__SetRange(std::vector< Math::Vector3 > *self,int index,std::vector< Math::Vector3 > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }

#include "ColliderCom.h"
#include "BoxColliderComponent.h"
#include "MeshCollider.h"


#include "CCamera.h"
	

#include "CSound.h"

SWIGINTERN std::map< std::string,float >::mapped_type const &std_map_Sl_std_string_Sc_float_Sg__getitem(std::map< std::string,float > *self,std::map< std::string,float >::key_type const &key){
        std::map< std::string, float, std::less< std::string > >::iterator iter = self->find(key);
        if (iter != self->end())
          return iter->second;
        else
          throw std::out_of_range("key not found");
      }
SWIGINTERN void std_map_Sl_std_string_Sc_float_Sg__setitem(std::map< std::string,float > *self,std::map< std::string,float >::key_type const &key,std::map< std::string,float >::mapped_type const &x){
        (*self)[key] = x;
      }
SWIGINTERN bool std_map_Sl_std_string_Sc_float_Sg__ContainsKey(std::map< std::string,float > *self,std::map< std::string,float >::key_type const &key){
        std::map< std::string, float, std::less< std::string > >::iterator iter = self->find(key);
        return iter != self->end();
      }
SWIGINTERN void std_map_Sl_std_string_Sc_float_Sg__Add(std::map< std::string,float > *self,std::map< std::string,float >::key_type const &key,std::map< std::string,float >::mapped_type const &val){
        std::map< std::string, float, std::less< std::string > >::iterator iter = self->find(key);
        if (iter != self->end())
          throw std::out_of_range("key already exists");
        self->insert(std::pair< std::string, float >(key, val));
      }
SWIGINTERN bool std_map_Sl_std_string_Sc_float_Sg__Remove(std::map< std::string,float > *self,std::map< std::string,float >::key_type const &key){
        std::map< std::string, float, std::less< std::string > >::iterator iter = self->find(key);
        if (iter != self->end()) {
          self->erase(iter);
          return true;
        }                
        return false;
      }
SWIGINTERN std::map< std::string,float,std::less< std::string > >::iterator *std_map_Sl_std_string_Sc_float_Sg__create_iterator_begin(std::map< std::string,float > *self){
        return new std::map< std::string, float, std::less< std::string > >::iterator(self->begin());
      }
SWIGINTERN std::map< std::string,float >::key_type const &std_map_Sl_std_string_Sc_float_Sg__get_next_key(std::map< std::string,float > *self,std::map< std::string,float,std::less< std::string > >::iterator *swigiterator){
        std::map< std::string, float, std::less< std::string > >::iterator iter = *swigiterator;
        (*swigiterator)++;
        return (*iter).first;
      }
SWIGINTERN void std_map_Sl_std_string_Sc_float_Sg__destroy_iterator(std::map< std::string,float > *self,std::map< std::string,float,std::less< std::string > >::iterator *swigiterator){
        delete swigiterator;
      }
SWIGINTERN std::map< std::string,AudioAsset >::mapped_type const &std_map_Sl_std_string_Sc_AudioAsset_Sg__getitem(std::map< std::string,AudioAsset > *self,std::map< std::string,AudioAsset >::key_type const &key){
        std::map< std::string, AudioAsset, std::less< std::string > >::iterator iter = self->find(key);
        if (iter != self->end())
          return iter->second;
        else
          throw std::out_of_range("key not found");
      }
SWIGINTERN void std_map_Sl_std_string_Sc_AudioAsset_Sg__setitem(std::map< std::string,AudioAsset > *self,std::map< std::string,AudioAsset >::key_type const &key,std::map< std::string,AudioAsset >::mapped_type const &x){
        (*self)[key] = x;
      }
SWIGINTERN bool std_map_Sl_std_string_Sc_AudioAsset_Sg__ContainsKey(std::map< std::string,AudioAsset > *self,std::map< std::string,AudioAsset >::key_type const &key){
        std::map< std::string, AudioAsset, std::less< std::string > >::iterator iter = self->find(key);
        return iter != self->end();
      }
SWIGINTERN void std_map_Sl_std_string_Sc_AudioAsset_Sg__Add(std::map< std::string,AudioAsset > *self,std::map< std::string,AudioAsset >::key_type const &key,std::map< std::string,AudioAsset >::mapped_type const &val){
        std::map< std::string, AudioAsset, std::less< std::string > >::iterator iter = self->find(key);
        if (iter != self->end())
          throw std::out_of_range("key already exists");
        self->insert(std::pair< std::string, AudioAsset >(key, val));
      }
SWIGINTERN bool std_map_Sl_std_string_Sc_AudioAsset_Sg__Remove(std::map< std::string,AudioAsset > *self,std::map< std::string,AudioAsset >::key_type const &key){
        std::map< std::string, AudioAsset, std::less< std::string > >::iterator iter = self->find(key);
        if (iter != self->end()) {
          self->erase(iter);
          return true;
        }                
        return false;
      }
SWIGINTERN std::map< std::string,AudioAsset,std::less< std::string > >::iterator *std_map_Sl_std_string_Sc_AudioAsset_Sg__create_iterator_begin(std::map< std::string,AudioAsset > *self){
        return new std::map< std::string, AudioAsset, std::less< std::string > >::iterator(self->begin());
      }
SWIGINTERN std::map< std::string,AudioAsset >::key_type const &std_map_Sl_std_string_Sc_AudioAsset_Sg__get_next_key(std::map< std::string,AudioAsset > *self,std::map< std::string,AudioAsset,std::less< std::string > >::iterator *swigiterator){
        std::map< std::string, AudioAsset, std::less< std::string > >::iterator iter = *swigiterator;
        (*swigiterator)++;
        return (*iter).first;
      }
SWIGINTERN void std_map_Sl_std_string_Sc_AudioAsset_Sg__destroy_iterator(std::map< std::string,AudioAsset > *self,std::map< std::string,AudioAsset,std::less< std::string > >::iterator *swigiterator){
        delete swigiterator;
      }

#include "IZone.h"


#include "CZone.h"


#include "CMapZone.h"
	

#include "CStreamZone.h"
#include "CStreamMarker.h"
	

#include "CScript.h"
	

#include "CDiffuseRenderer.h"


#include "CForwardRenderer.h"


#include "CFontRenderer.h"


#include "CReflectionProbe.h"


#include "CConvexHull.h"


#include "CParticleEmitter.h"


#include "CParticleRenderer.h"


#include "CPostProcess.h"


#include "CBloom.h"


#include "CMotionBlur.h"


#include "CCensorFX.h"


#include "CFilmGrain.h"


#include "CChromaticAberration.h"


#include "CArtifactFX.h"


#include "CShadowProbe.h"


#ifdef __cplusplus
extern "C" {
#endif

SWIGEXPORT void SWIGSTDCALL CSharp_IntVector_Clear(void * jarg1) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_IntVector_Add(void * jarg1, int jarg2) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int *arg2 = 0 ;
  int temp2 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  temp2 = (int)jarg2; 
  arg2 = &temp2; 
  (arg1)->push_back((int const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_IntVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  std::vector< int >::size_type result;
  
  arg1 = (std::vector< int > *)jarg1; 
  result = ((std::vector< int > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_IntVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  std::vector< int >::size_type result;
  
  arg1 = (std::vector< int > *)jarg1; 
  result = ((std::vector< int > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_IntVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  std::vector< int >::size_type arg2 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (std::vector< int >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_IntVector__SWIG_0() {
  void * jresult ;
  std::vector< int > *result = 0 ;
  
  result = (std::vector< int > *)new std::vector< int >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_IntVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< int > *arg1 = 0 ;
  std::vector< int > *result = 0 ;
  
  arg1 = (std::vector< int > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< int > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< int > *)new std::vector< int >((std::vector< int > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_IntVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< int > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< int > *)new_std_vector_Sl_int_Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_IntVector_getitemcopy(void * jarg1, int jarg2) {
  int jresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ;
  int result;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (int)std_vector_Sl_int_Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_IntVector_getitem(void * jarg1, int jarg2) {
  int jresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ;
  int *result = 0 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (int *) &std_vector_Sl_int_Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = *result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_IntVector_setitem(void * jarg1, int jarg2, int jarg3) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ;
  int *arg3 = 0 ;
  int temp3 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (int)jarg3; 
  arg3 = &temp3; 
  try {
    std_vector_Sl_int_Sg__setitem(arg1,arg2,(int const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_IntVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  std::vector< int > *arg2 = 0 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (std::vector< int > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< int > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_int_Sg__AddRange(arg1,(std::vector< int > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_IntVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< int > *result = 0 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< int > *)std_vector_Sl_int_Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_IntVector_Insert(void * jarg1, int jarg2, int jarg3) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ;
  int *arg3 = 0 ;
  int temp3 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (int)jarg3; 
  arg3 = &temp3; 
  try {
    std_vector_Sl_int_Sg__Insert(arg1,arg2,(int const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_IntVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ;
  std::vector< int > *arg3 = 0 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< int > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< int > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_int_Sg__InsertRange(arg1,arg2,(std::vector< int > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_IntVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_int_Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_IntVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_int_Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_IntVector_Repeat(int jarg1, int jarg2) {
  void * jresult ;
  int *arg1 = 0 ;
  int arg2 ;
  int temp1 ;
  std::vector< int > *result = 0 ;
  
  temp1 = (int)jarg1; 
  arg1 = &temp1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< int > *)std_vector_Sl_int_Sg__Repeat((int const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_IntVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  std_vector_Sl_int_Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_IntVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_int_Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_IntVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ;
  std::vector< int > *arg3 = 0 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< int > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< int > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_int_Sg__SetRange(arg1,arg2,(std::vector< int > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_IntVector_Contains(void * jarg1, int jarg2) {
  unsigned int jresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int *arg2 = 0 ;
  int temp2 ;
  bool result;
  
  arg1 = (std::vector< int > *)jarg1; 
  temp2 = (int)jarg2; 
  arg2 = &temp2; 
  result = (bool)std_vector_Sl_int_Sg__Contains(arg1,(int const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_IntVector_IndexOf(void * jarg1, int jarg2) {
  int jresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int *arg2 = 0 ;
  int temp2 ;
  int result;
  
  arg1 = (std::vector< int > *)jarg1; 
  temp2 = (int)jarg2; 
  arg2 = &temp2; 
  result = (int)std_vector_Sl_int_Sg__IndexOf(arg1,(int const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_IntVector_LastIndexOf(void * jarg1, int jarg2) {
  int jresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int *arg2 = 0 ;
  int temp2 ;
  int result;
  
  arg1 = (std::vector< int > *)jarg1; 
  temp2 = (int)jarg2; 
  arg2 = &temp2; 
  result = (int)std_vector_Sl_int_Sg__LastIndexOf(arg1,(int const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_IntVector_Remove(void * jarg1, int jarg2) {
  unsigned int jresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int *arg2 = 0 ;
  int temp2 ;
  bool result;
  
  arg1 = (std::vector< int > *)jarg1; 
  temp2 = (int)jarg2; 
  arg2 = &temp2; 
  result = (bool)std_vector_Sl_int_Sg__Remove(arg1,(int const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_IntVector(void * jarg1) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_MochaVec2__SWIG_0() {
  void * jresult ;
  Math::Vector2 *result = 0 ;
  
  result = (Math::Vector2 *)new Math::Vector2();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_MochaVec2__SWIG_1(float jarg1, float jarg2) {
  void * jresult ;
  float arg1 ;
  float arg2 ;
  Math::Vector2 *result = 0 ;
  
  arg1 = (float)jarg1; 
  arg2 = (float)jarg2; 
  result = (Math::Vector2 *)new Math::Vector2(arg1,arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_MochaVec2__SWIG_2(void * jarg1) {
  void * jresult ;
  ConstRealPointer arg1 ;
  ConstRealPointer *argp1 ;
  Math::Vector2 *result = 0 ;
  
  argp1 = (ConstRealPointer *)jarg1; 
  if (!argp1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null ConstRealPointer", 0);
    return 0;
  }
  arg1 = *argp1; 
  result = (Math::Vector2 *)new Math::Vector2(arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec2_GetE(void * jarg1, unsigned int jarg2) {
  void * jresult ;
  Math::Vector2 *arg1 = (Math::Vector2 *) 0 ;
  unsigned int arg2 ;
  float *result = 0 ;
  
  arg1 = (Math::Vector2 *)jarg1; 
  arg2 = (unsigned int)jarg2; 
  result = (float *) &(arg1)->operator [](arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec2_Sub__SWIG_0(void * jarg1) {
  void * jresult ;
  Math::Vector2 *arg1 = (Math::Vector2 *) 0 ;
  Math::Vector2 result;
  
  arg1 = (Math::Vector2 *)jarg1; 
  result = ((Math::Vector2 const *)arg1)->operator -();
  jresult = new Math::Vector2((const Math::Vector2 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec2_Mul__SWIG_0(void * jarg1, float jarg2) {
  void * jresult ;
  Math::Vector2 *arg1 = (Math::Vector2 *) 0 ;
  float arg2 ;
  Math::Vector2 result;
  
  arg1 = (Math::Vector2 *)jarg1; 
  arg2 = (float)jarg2; 
  result = ((Math::Vector2 const *)arg1)->operator *(arg2);
  jresult = new Math::Vector2((const Math::Vector2 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec2_Div__SWIG_0(void * jarg1, float jarg2) {
  void * jresult ;
  Math::Vector2 *arg1 = (Math::Vector2 *) 0 ;
  float arg2 ;
  Math::Vector2 result;
  
  arg1 = (Math::Vector2 *)jarg1; 
  arg2 = (float)jarg2; 
  result = ((Math::Vector2 const *)arg1)->operator /(arg2);
  jresult = new Math::Vector2((const Math::Vector2 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec2_Add(void * jarg1, void * jarg2) {
  void * jresult ;
  Math::Vector2 *arg1 = (Math::Vector2 *) 0 ;
  Math::Vector2 *arg2 = 0 ;
  Math::Vector2 result;
  
  arg1 = (Math::Vector2 *)jarg1; 
  arg2 = (Math::Vector2 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector2Param type is null", 0);
    return 0;
  } 
  result = ((Math::Vector2 const *)arg1)->operator +((Math::Vector2 const &)*arg2);
  jresult = new Math::Vector2((const Math::Vector2 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec2_Sub__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  Math::Vector2 *arg1 = (Math::Vector2 *) 0 ;
  Math::Vector2 *arg2 = 0 ;
  Math::Vector2 result;
  
  arg1 = (Math::Vector2 *)jarg1; 
  arg2 = (Math::Vector2 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector2Param type is null", 0);
    return 0;
  } 
  result = ((Math::Vector2 const *)arg1)->operator -((Math::Vector2 const &)*arg2);
  jresult = new Math::Vector2((const Math::Vector2 &)result); 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_MochaVec2_Comp(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  Math::Vector2 *arg1 = (Math::Vector2 *) 0 ;
  Math::Vector2 *arg2 = 0 ;
  bool result;
  
  arg1 = (Math::Vector2 *)jarg1; 
  arg2 = (Math::Vector2 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector2Param type is null", 0);
    return 0;
  } 
  result = (bool)((Math::Vector2 const *)arg1)->operator ==((Math::Vector2 const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_MochaVec2_NegComp(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  Math::Vector2 *arg1 = (Math::Vector2 *) 0 ;
  Math::Vector2 *arg2 = 0 ;
  bool result;
  
  arg1 = (Math::Vector2 *)jarg1; 
  arg2 = (Math::Vector2 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector2Param type is null", 0);
    return 0;
  } 
  result = (bool)((Math::Vector2 const *)arg1)->operator !=((Math::Vector2 const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec2_Mul__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  Math::Vector2 *arg1 = (Math::Vector2 *) 0 ;
  Math::Vector2 *arg2 = 0 ;
  Math::Vector2 result;
  
  arg1 = (Math::Vector2 *)jarg1; 
  arg2 = (Math::Vector2 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector2Param type is null", 0);
    return 0;
  } 
  result = ((Math::Vector2 const *)arg1)->operator *((Math::Vector2 const &)*arg2);
  jresult = new Math::Vector2((const Math::Vector2 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec2_Div__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  Math::Vector2 *arg1 = (Math::Vector2 *) 0 ;
  Math::Vector2 *arg2 = 0 ;
  Math::Vector2 result;
  
  arg1 = (Math::Vector2 *)jarg1; 
  arg2 = (Math::Vector2 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector2Param type is null", 0);
    return 0;
  } 
  result = ((Math::Vector2 const *)arg1)->operator /((Math::Vector2 const &)*arg2);
  jresult = new Math::Vector2((const Math::Vector2 &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_MochaVec2_Set(void * jarg1, float jarg2, float jarg3) {
  Math::Vector2 *arg1 = (Math::Vector2 *) 0 ;
  float arg2 ;
  float arg3 ;
  
  arg1 = (Math::Vector2 *)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  (arg1)->Set(arg2,arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_MochaVec2_ZeroOut(void * jarg1) {
  Math::Vector2 *arg1 = (Math::Vector2 *) 0 ;
  
  arg1 = (Math::Vector2 *)jarg1; 
  (arg1)->ZeroOut();
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec2_Reflect(void * jarg1, void * jarg2) {
  void * jresult ;
  Math::Vector2 *arg1 = (Math::Vector2 *) 0 ;
  Math::Vector2 *arg2 = 0 ;
  Math::Vector2 result;
  
  arg1 = (Math::Vector2 *)jarg1; 
  arg2 = (Math::Vector2 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector2Param type is null", 0);
    return 0;
  } 
  result = ((Math::Vector2 const *)arg1)->Reflect((Math::Vector2 const &)*arg2);
  jresult = new Math::Vector2((const Math::Vector2 &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_MochaVec2_AddScaledVector(void * jarg1, void * jarg2, float jarg3) {
  Math::Vector2 *arg1 = (Math::Vector2 *) 0 ;
  Math::Vector2 *arg2 = 0 ;
  float arg3 ;
  
  arg1 = (Math::Vector2 *)jarg1; 
  arg2 = (Math::Vector2 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector2Param type is null", 0);
    return ;
  } 
  arg3 = (float)jarg3; 
  (arg1)->AddScaledVector((Math::Vector2 const &)*arg2,arg3);
}


SWIGEXPORT float SWIGSTDCALL CSharp_MochaVec2_Dot(void * jarg1, void * jarg2) {
  float jresult ;
  Math::Vector2 *arg1 = (Math::Vector2 *) 0 ;
  Math::Vector2 *arg2 = 0 ;
  float result;
  
  arg1 = (Math::Vector2 *)jarg1; 
  arg2 = (Math::Vector2 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector2Param type is null", 0);
    return 0;
  } 
  result = (float)((Math::Vector2 const *)arg1)->Dot((Math::Vector2 const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_MochaVec2_Length(void * jarg1) {
  float jresult ;
  Math::Vector2 *arg1 = (Math::Vector2 *) 0 ;
  float result;
  
  arg1 = (Math::Vector2 *)jarg1; 
  result = (float)((Math::Vector2 const *)arg1)->Length();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_MochaVec2_LengthSq(void * jarg1) {
  float jresult ;
  Math::Vector2 *arg1 = (Math::Vector2 *) 0 ;
  float result;
  
  arg1 = (Math::Vector2 *)jarg1; 
  result = (float)((Math::Vector2 const *)arg1)->LengthSq();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec2_Normalized(void * jarg1) {
  void * jresult ;
  Math::Vector2 *arg1 = (Math::Vector2 *) 0 ;
  Math::Vector2 result;
  
  arg1 = (Math::Vector2 *)jarg1; 
  result = ((Math::Vector2 const *)arg1)->Normalized();
  jresult = new Math::Vector2((const Math::Vector2 &)result); 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_MochaVec2_Normalize(void * jarg1) {
  float jresult ;
  Math::Vector2 *arg1 = (Math::Vector2 *) 0 ;
  float result;
  
  arg1 = (Math::Vector2 *)jarg1; 
  result = (float)(arg1)->Normalize();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_MochaVec2_AttemptNormalize(void * jarg1) {
  float jresult ;
  Math::Vector2 *arg1 = (Math::Vector2 *) 0 ;
  float result;
  
  arg1 = (Math::Vector2 *)jarg1; 
  result = (float)(arg1)->AttemptNormalize();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec2_Negate(void * jarg1) {
  void * jresult ;
  Math::Vector2 *arg1 = (Math::Vector2 *) 0 ;
  Math::Vector2 *result = 0 ;
  
  arg1 = (Math::Vector2 *)jarg1; 
  result = (Math::Vector2 *) &(arg1)->Negate();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_MochaVec2_Valid(void * jarg1) {
  unsigned int jresult ;
  Math::Vector2 *arg1 = (Math::Vector2 *) 0 ;
  bool result;
  
  arg1 = (Math::Vector2 *)jarg1; 
  result = (bool)((Math::Vector2 const *)arg1)->Valid();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_MochaVec2_Splat(void * jarg1, float jarg2) {
  Math::Vector2 *arg1 = (Math::Vector2 *) 0 ;
  float arg2 ;
  
  arg1 = (Math::Vector2 *)jarg1; 
  arg2 = (float)jarg2; 
  (arg1)->Splat(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_MochaVec2_x_set(void * jarg1, float jarg2) {
  Math::Vector2 *arg1 = (Math::Vector2 *) 0 ;
  float arg2 ;
  
  arg1 = (Math::Vector2 *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->x = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_MochaVec2_x_get(void * jarg1) {
  float jresult ;
  Math::Vector2 *arg1 = (Math::Vector2 *) 0 ;
  float result;
  
  arg1 = (Math::Vector2 *)jarg1; 
  result = (float) ((arg1)->x);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_MochaVec2_y_set(void * jarg1, float jarg2) {
  Math::Vector2 *arg1 = (Math::Vector2 *) 0 ;
  float arg2 ;
  
  arg1 = (Math::Vector2 *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->y = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_MochaVec2_y_get(void * jarg1) {
  float jresult ;
  Math::Vector2 *arg1 = (Math::Vector2 *) 0 ;
  float result;
  
  arg1 = (Math::Vector2 *)jarg1; 
  result = (float) ((arg1)->y);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_MochaVec2_array_set(void * jarg1, void * jarg2) {
  Math::Vector2 *arg1 = (Math::Vector2 *) 0 ;
  float *arg2 ;
  
  arg1 = (Math::Vector2 *)jarg1; 
  arg2 = (float *)jarg2; 
  {
    size_t ii;
    float *b = (float *) arg1->array;
    for (ii = 0; ii < (size_t)2; ii++) b[ii] = *((float *) arg2 + ii);
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec2_array_get(void * jarg1) {
  void * jresult ;
  Math::Vector2 *arg1 = (Math::Vector2 *) 0 ;
  float *result = 0 ;
  
  arg1 = (Math::Vector2 *)jarg1; 
  result = (float *)(float *) ((arg1)->array);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_MochaVec2(void * jarg1) {
  Math::Vector2 *arg1 = (Math::Vector2 *) 0 ;
  
  arg1 = (Math::Vector2 *)jarg1; 
  delete arg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_MochaVec4__SWIG_0() {
  void * jresult ;
  Math::Vector4 *result = 0 ;
  
  result = (Math::Vector4 *)new Math::Vector4();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_MochaVec4__SWIG_1(float jarg1, float jarg2, float jarg3, float jarg4) {
  void * jresult ;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  Math::Vector4 *result = 0 ;
  
  arg1 = (float)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  result = (Math::Vector4 *)new Math::Vector4(arg1,arg2,arg3,arg4);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_MochaVec4__SWIG_2(float jarg1, float jarg2, float jarg3) {
  void * jresult ;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  Math::Vector4 *result = 0 ;
  
  arg1 = (float)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  result = (Math::Vector4 *)new Math::Vector4(arg1,arg2,arg3);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_MochaVec4__SWIG_3(void * jarg1) {
  void * jresult ;
  ConstRealPointer arg1 ;
  ConstRealPointer *argp1 ;
  Math::Vector4 *result = 0 ;
  
  argp1 = (ConstRealPointer *)jarg1; 
  if (!argp1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null ConstRealPointer", 0);
    return 0;
  }
  arg1 = *argp1; 
  result = (Math::Vector4 *)new Math::Vector4(arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_MochaVec4__SWIG_4(float jarg1) {
  void * jresult ;
  float arg1 ;
  Math::Vector4 *result = 0 ;
  
  arg1 = (float)jarg1; 
  result = (Math::Vector4 *)new Math::Vector4(arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec4_GetE(void * jarg1, unsigned int jarg2) {
  void * jresult ;
  Math::Vector4 *arg1 = (Math::Vector4 *) 0 ;
  unsigned int arg2 ;
  float *result = 0 ;
  
  arg1 = (Math::Vector4 *)jarg1; 
  arg2 = (unsigned int)jarg2; 
  result = (float *) &(arg1)->operator [](arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec4_Sub__SWIG_0(void * jarg1) {
  void * jresult ;
  Math::Vector4 *arg1 = (Math::Vector4 *) 0 ;
  Math::Vector4 result;
  
  arg1 = (Math::Vector4 *)jarg1; 
  result = ((Math::Vector4 const *)arg1)->operator -();
  jresult = new Math::Vector4((const Math::Vector4 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec4_Mul__SWIG_0(void * jarg1, float jarg2) {
  void * jresult ;
  Math::Vector4 *arg1 = (Math::Vector4 *) 0 ;
  float arg2 ;
  Math::Vector4 result;
  
  arg1 = (Math::Vector4 *)jarg1; 
  arg2 = (float)jarg2; 
  result = ((Math::Vector4 const *)arg1)->operator *(arg2);
  jresult = new Math::Vector4((const Math::Vector4 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec4_Div__SWIG_0(void * jarg1, float jarg2) {
  void * jresult ;
  Math::Vector4 *arg1 = (Math::Vector4 *) 0 ;
  float arg2 ;
  Math::Vector4 result;
  
  arg1 = (Math::Vector4 *)jarg1; 
  arg2 = (float)jarg2; 
  result = ((Math::Vector4 const *)arg1)->operator /(arg2);
  jresult = new Math::Vector4((const Math::Vector4 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec4_Add(void * jarg1, void * jarg2) {
  void * jresult ;
  Math::Vector4 *arg1 = (Math::Vector4 *) 0 ;
  Math::Vector4 *arg2 = 0 ;
  Math::Vector4 result;
  
  arg1 = (Math::Vector4 *)jarg1; 
  arg2 = (Math::Vector4 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector4Param type is null", 0);
    return 0;
  } 
  result = ((Math::Vector4 const *)arg1)->operator +((Math::Vector4 const &)*arg2);
  jresult = new Math::Vector4((const Math::Vector4 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec4_Sub__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  Math::Vector4 *arg1 = (Math::Vector4 *) 0 ;
  Math::Vector4 *arg2 = 0 ;
  Math::Vector4 result;
  
  arg1 = (Math::Vector4 *)jarg1; 
  arg2 = (Math::Vector4 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector4Param type is null", 0);
    return 0;
  } 
  result = ((Math::Vector4 const *)arg1)->operator -((Math::Vector4 const &)*arg2);
  jresult = new Math::Vector4((const Math::Vector4 &)result); 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_MochaVec4_Comp(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  Math::Vector4 *arg1 = (Math::Vector4 *) 0 ;
  Math::Vector4 *arg2 = 0 ;
  bool result;
  
  arg1 = (Math::Vector4 *)jarg1; 
  arg2 = (Math::Vector4 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector4Param type is null", 0);
    return 0;
  } 
  result = (bool)((Math::Vector4 const *)arg1)->operator ==((Math::Vector4 const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_MochaVec4_NegComp(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  Math::Vector4 *arg1 = (Math::Vector4 *) 0 ;
  Math::Vector4 *arg2 = 0 ;
  bool result;
  
  arg1 = (Math::Vector4 *)jarg1; 
  arg2 = (Math::Vector4 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector4Param type is null", 0);
    return 0;
  } 
  result = (bool)((Math::Vector4 const *)arg1)->operator !=((Math::Vector4 const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec4_Mul__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  Math::Vector4 *arg1 = (Math::Vector4 *) 0 ;
  Math::Vector4 *arg2 = 0 ;
  Math::Vector4 result;
  
  arg1 = (Math::Vector4 *)jarg1; 
  arg2 = (Math::Vector4 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector4Param type is null", 0);
    return 0;
  } 
  result = ((Math::Vector4 const *)arg1)->operator *((Math::Vector4 const &)*arg2);
  jresult = new Math::Vector4((const Math::Vector4 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec4_Div__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  Math::Vector4 *arg1 = (Math::Vector4 *) 0 ;
  Math::Vector4 *arg2 = 0 ;
  Math::Vector4 result;
  
  arg1 = (Math::Vector4 *)jarg1; 
  arg2 = (Math::Vector4 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector4Param type is null", 0);
    return 0;
  } 
  result = ((Math::Vector4 const *)arg1)->operator /((Math::Vector4 const &)*arg2);
  jresult = new Math::Vector4((const Math::Vector4 &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_MochaVec4_Set__SWIG_0(void * jarg1, float jarg2, float jarg3, float jarg4, float jarg5) {
  Math::Vector4 *arg1 = (Math::Vector4 *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  
  arg1 = (Math::Vector4 *)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  arg5 = (float)jarg5; 
  (arg1)->Set(arg2,arg3,arg4,arg5);
}


SWIGEXPORT void SWIGSTDCALL CSharp_MochaVec4_Set__SWIG_1(void * jarg1, float jarg2, float jarg3, float jarg4) {
  Math::Vector4 *arg1 = (Math::Vector4 *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  arg1 = (Math::Vector4 *)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  (arg1)->Set(arg2,arg3,arg4);
}


SWIGEXPORT void SWIGSTDCALL CSharp_MochaVec4_Splat(void * jarg1, float jarg2) {
  Math::Vector4 *arg1 = (Math::Vector4 *) 0 ;
  float arg2 ;
  
  arg1 = (Math::Vector4 *)jarg1; 
  arg2 = (float)jarg2; 
  (arg1)->Splat(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_MochaVec4_ScaleByVector(void * jarg1, void * jarg2) {
  Math::Vector4 *arg1 = (Math::Vector4 *) 0 ;
  Math::Vector4 *arg2 = 0 ;
  
  arg1 = (Math::Vector4 *)jarg1; 
  arg2 = (Math::Vector4 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector4Param type is null", 0);
    return ;
  } 
  (arg1)->ScaleByVector((Math::Vector4 const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec4_ScaledByVector(void * jarg1, void * jarg2) {
  void * jresult ;
  Math::Vector4 *arg1 = (Math::Vector4 *) 0 ;
  Math::Vector4 *arg2 = 0 ;
  Math::Vector4 result;
  
  arg1 = (Math::Vector4 *)jarg1; 
  arg2 = (Math::Vector4 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector4Param type is null", 0);
    return 0;
  } 
  result = ((Math::Vector4 const *)arg1)->ScaledByVector((Math::Vector4 const &)*arg2);
  jresult = new Math::Vector4((const Math::Vector4 &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_MochaVec4_ZeroOut(void * jarg1) {
  Math::Vector4 *arg1 = (Math::Vector4 *) 0 ;
  
  arg1 = (Math::Vector4 *)jarg1; 
  (arg1)->ZeroOut();
}


SWIGEXPORT void SWIGSTDCALL CSharp_MochaVec4_AddScaledVector(void * jarg1, void * jarg2, float jarg3) {
  Math::Vector4 *arg1 = (Math::Vector4 *) 0 ;
  Math::Vector4 *arg2 = 0 ;
  float arg3 ;
  
  arg1 = (Math::Vector4 *)jarg1; 
  arg2 = (Math::Vector4 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector4Param type is null", 0);
    return ;
  } 
  arg3 = (float)jarg3; 
  (arg1)->AddScaledVector((Math::Vector4 const &)*arg2,arg3);
}


SWIGEXPORT float SWIGSTDCALL CSharp_MochaVec4_Dot(void * jarg1, void * jarg2) {
  float jresult ;
  Math::Vector4 *arg1 = (Math::Vector4 *) 0 ;
  Math::Vector4 *arg2 = 0 ;
  float result;
  
  arg1 = (Math::Vector4 *)jarg1; 
  arg2 = (Math::Vector4 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector4Param type is null", 0);
    return 0;
  } 
  result = (float)((Math::Vector4 const *)arg1)->Dot((Math::Vector4 const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_MochaVec4_Length(void * jarg1) {
  float jresult ;
  Math::Vector4 *arg1 = (Math::Vector4 *) 0 ;
  float result;
  
  arg1 = (Math::Vector4 *)jarg1; 
  result = (float)((Math::Vector4 const *)arg1)->Length();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_MochaVec4_LengthSq(void * jarg1) {
  float jresult ;
  Math::Vector4 *arg1 = (Math::Vector4 *) 0 ;
  float result;
  
  arg1 = (Math::Vector4 *)jarg1; 
  result = (float)((Math::Vector4 const *)arg1)->LengthSq();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec4_Normalized(void * jarg1) {
  void * jresult ;
  Math::Vector4 *arg1 = (Math::Vector4 *) 0 ;
  Math::Vector4 result;
  
  arg1 = (Math::Vector4 *)jarg1; 
  result = ((Math::Vector4 const *)arg1)->Normalized();
  jresult = new Math::Vector4((const Math::Vector4 &)result); 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_MochaVec4_Normalize(void * jarg1) {
  float jresult ;
  Math::Vector4 *arg1 = (Math::Vector4 *) 0 ;
  float result;
  
  arg1 = (Math::Vector4 *)jarg1; 
  result = (float)(arg1)->Normalize();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_MochaVec4_AttemptNormalize(void * jarg1) {
  float jresult ;
  Math::Vector4 *arg1 = (Math::Vector4 *) 0 ;
  float result;
  
  arg1 = (Math::Vector4 *)jarg1; 
  result = (float)(arg1)->AttemptNormalize();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec4_Negate(void * jarg1) {
  void * jresult ;
  Math::Vector4 *arg1 = (Math::Vector4 *) 0 ;
  Math::Vector4 *result = 0 ;
  
  arg1 = (Math::Vector4 *)jarg1; 
  result = (Math::Vector4 *) &(arg1)->Negate();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_MochaVec4_Valid(void * jarg1) {
  unsigned int jresult ;
  Math::Vector4 *arg1 = (Math::Vector4 *) 0 ;
  bool result;
  
  arg1 = (Math::Vector4 *)jarg1; 
  result = (bool)((Math::Vector4 const *)arg1)->Valid();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec4_Cross(void * jarg1, void * jarg2) {
  void * jresult ;
  Math::Vector4 *arg1 = (Math::Vector4 *) 0 ;
  Math::Vector4 *arg2 = 0 ;
  Math::Vector4 result;
  
  arg1 = (Math::Vector4 *)jarg1; 
  arg2 = (Math::Vector4 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector4Param type is null", 0);
    return 0;
  } 
  result = ((Math::Vector4 const *)arg1)->Cross((Math::Vector4 const &)*arg2);
  jresult = new Math::Vector4((const Math::Vector4 &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_MochaVec4_x_set(void * jarg1, float jarg2) {
  Math::Vector4 *arg1 = (Math::Vector4 *) 0 ;
  float arg2 ;
  
  arg1 = (Math::Vector4 *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->x = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_MochaVec4_x_get(void * jarg1) {
  float jresult ;
  Math::Vector4 *arg1 = (Math::Vector4 *) 0 ;
  float result;
  
  arg1 = (Math::Vector4 *)jarg1; 
  result = (float) ((arg1)->x);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_MochaVec4_y_set(void * jarg1, float jarg2) {
  Math::Vector4 *arg1 = (Math::Vector4 *) 0 ;
  float arg2 ;
  
  arg1 = (Math::Vector4 *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->y = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_MochaVec4_y_get(void * jarg1) {
  float jresult ;
  Math::Vector4 *arg1 = (Math::Vector4 *) 0 ;
  float result;
  
  arg1 = (Math::Vector4 *)jarg1; 
  result = (float) ((arg1)->y);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_MochaVec4_z_set(void * jarg1, float jarg2) {
  Math::Vector4 *arg1 = (Math::Vector4 *) 0 ;
  float arg2 ;
  
  arg1 = (Math::Vector4 *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->z = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_MochaVec4_z_get(void * jarg1) {
  float jresult ;
  Math::Vector4 *arg1 = (Math::Vector4 *) 0 ;
  float result;
  
  arg1 = (Math::Vector4 *)jarg1; 
  result = (float) ((arg1)->z);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_MochaVec4_w_set(void * jarg1, float jarg2) {
  Math::Vector4 *arg1 = (Math::Vector4 *) 0 ;
  float arg2 ;
  
  arg1 = (Math::Vector4 *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->w = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_MochaVec4_w_get(void * jarg1) {
  float jresult ;
  Math::Vector4 *arg1 = (Math::Vector4 *) 0 ;
  float result;
  
  arg1 = (Math::Vector4 *)jarg1; 
  result = (float) ((arg1)->w);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_MochaVec4_array_set(void * jarg1, void * jarg2) {
  Math::Vector4 *arg1 = (Math::Vector4 *) 0 ;
  float *arg2 ;
  
  arg1 = (Math::Vector4 *)jarg1; 
  arg2 = (float *)jarg2; 
  {
    size_t ii;
    float *b = (float *) arg1->array;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec4_array_get(void * jarg1) {
  void * jresult ;
  Math::Vector4 *arg1 = (Math::Vector4 *) 0 ;
  float *result = 0 ;
  
  arg1 = (Math::Vector4 *)jarg1; 
  result = (float *)(float *) ((arg1)->array);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_MochaVec4(void * jarg1) {
  Math::Vector4 *arg1 = (Math::Vector4 *) 0 ;
  
  arg1 = (Math::Vector4 *)jarg1; 
  delete arg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_MochaVec3__SWIG_0() {
  void * jresult ;
  Math::Vector3 *result = 0 ;
  
  result = (Math::Vector3 *)new Math::Vector3();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_MochaVec3__SWIG_1(float jarg1, float jarg2, float jarg3) {
  void * jresult ;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  Math::Vector3 *result = 0 ;
  
  arg1 = (float)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  result = (Math::Vector3 *)new Math::Vector3(arg1,arg2,arg3);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_MochaVec3__SWIG_2(float jarg1) {
  void * jresult ;
  float arg1 ;
  Math::Vector3 *result = 0 ;
  
  arg1 = (float)jarg1; 
  result = (Math::Vector3 *)new Math::Vector3(arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_MochaVec3__SWIG_3(void * jarg1, float jarg2) {
  void * jresult ;
  Math::Vector2 *arg1 = 0 ;
  float arg2 ;
  Math::Vector3 *result = 0 ;
  
  arg1 = (Math::Vector2 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector2Param type is null", 0);
    return 0;
  } 
  arg2 = (float)jarg2; 
  result = (Math::Vector3 *)new Math::Vector3((Math::Vector2 const &)*arg1,arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_MochaVec3__SWIG_4(void * jarg1) {
  void * jresult ;
  Math::Vector2 *arg1 = 0 ;
  Math::Vector3 *result = 0 ;
  
  arg1 = (Math::Vector2 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector2Param type is null", 0);
    return 0;
  } 
  result = (Math::Vector3 *)new Math::Vector3((Math::Vector2 const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_MochaVec3__SWIG_5(void * jarg1) {
  void * jresult ;
  ConstRealPointer arg1 ;
  ConstRealPointer *argp1 ;
  Math::Vector3 *result = 0 ;
  
  argp1 = (ConstRealPointer *)jarg1; 
  if (!argp1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null ConstRealPointer", 0);
    return 0;
  }
  arg1 = *argp1; 
  result = (Math::Vector3 *)new Math::Vector3(arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_MochaVec3__SWIG_6(void * jarg1) {
  void * jresult ;
  Math::Vector3 *arg1 = 0 ;
  Math::Vector3 *result = 0 ;
  
  arg1 = (Math::Vector3 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3Param type is null", 0);
    return 0;
  } 
  result = (Math::Vector3 *)new Math::Vector3((Math::Vector3 const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec3_ToFloats(void * jarg1) {
  void * jresult ;
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  float *result = 0 ;
  
  arg1 = (Math::Vector3 *)jarg1; 
  result = (float *)(arg1)->ToFloats();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_MochaVec3_GetE(void * jarg1, unsigned int jarg2) {
  float jresult ;
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  unsigned int arg2 ;
  float result;
  
  arg1 = (Math::Vector3 *)jarg1; 
  arg2 = (unsigned int)jarg2; 
  result = (float)((Math::Vector3 const *)arg1)->operator [](arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec3_Sub__SWIG_0(void * jarg1) {
  void * jresult ;
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  Math::Vector3 result;
  
  arg1 = (Math::Vector3 *)jarg1; 
  result = ((Math::Vector3 const *)arg1)->operator -();
  jresult = new Math::Vector3((const Math::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec3_Mul__SWIG_0(void * jarg1, float jarg2) {
  void * jresult ;
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  float arg2 ;
  Math::Vector3 result;
  
  arg1 = (Math::Vector3 *)jarg1; 
  arg2 = (float)jarg2; 
  result = ((Math::Vector3 const *)arg1)->operator *(arg2);
  jresult = new Math::Vector3((const Math::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec3_Div__SWIG_0(void * jarg1, float jarg2) {
  void * jresult ;
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  float arg2 ;
  Math::Vector3 result;
  
  arg1 = (Math::Vector3 *)jarg1; 
  arg2 = (float)jarg2; 
  result = ((Math::Vector3 const *)arg1)->operator /(arg2);
  jresult = new Math::Vector3((const Math::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec3_Add(void * jarg1, void * jarg2) {
  void * jresult ;
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  Math::Vector3 result;
  
  arg1 = (Math::Vector3 *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3Param type is null", 0);
    return 0;
  } 
  result = ((Math::Vector3 const *)arg1)->operator +((Math::Vector3 const &)*arg2);
  jresult = new Math::Vector3((const Math::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec3_Sub__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  Math::Vector3 result;
  
  arg1 = (Math::Vector3 *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3Param type is null", 0);
    return 0;
  } 
  result = ((Math::Vector3 const *)arg1)->operator -((Math::Vector3 const &)*arg2);
  jresult = new Math::Vector3((const Math::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_MochaVec3_Comp(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  bool result;
  
  arg1 = (Math::Vector3 *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3Param type is null", 0);
    return 0;
  } 
  result = (bool)((Math::Vector3 const *)arg1)->operator ==((Math::Vector3 const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_MochaVec3_NegComp(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  bool result;
  
  arg1 = (Math::Vector3 *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3Param type is null", 0);
    return 0;
  } 
  result = (bool)((Math::Vector3 const *)arg1)->operator !=((Math::Vector3 const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec3_Mul__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  Math::Vector3 result;
  
  arg1 = (Math::Vector3 *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3Param type is null", 0);
    return 0;
  } 
  result = ((Math::Vector3 const *)arg1)->operator *((Math::Vector3 const &)*arg2);
  jresult = new Math::Vector3((const Math::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec3_Div__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  Math::Vector3 result;
  
  arg1 = (Math::Vector3 *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3Param type is null", 0);
    return 0;
  } 
  result = ((Math::Vector3 const *)arg1)->operator /((Math::Vector3 const &)*arg2);
  jresult = new Math::Vector3((const Math::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_MochaVec3_Set(void * jarg1, float jarg2, float jarg3, float jarg4) {
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  arg1 = (Math::Vector3 *)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  (arg1)->Set(arg2,arg3,arg4);
}


SWIGEXPORT void SWIGSTDCALL CSharp_MochaVec3_Splat(void * jarg1, float jarg2) {
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  float arg2 ;
  
  arg1 = (Math::Vector3 *)jarg1; 
  arg2 = (float)jarg2; 
  (arg1)->Splat(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_MochaVec3_ScaleByVector(void * jarg1, void * jarg2) {
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  
  arg1 = (Math::Vector3 *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3Param type is null", 0);
    return ;
  } 
  (arg1)->ScaleByVector((Math::Vector3 const &)*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_MochaVec3_ZeroOut(void * jarg1) {
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  
  arg1 = (Math::Vector3 *)jarg1; 
  (arg1)->ZeroOut();
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec3_Reflect(void * jarg1, void * jarg2) {
  void * jresult ;
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  Math::Vector3 result;
  
  arg1 = (Math::Vector3 *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3Param type is null", 0);
    return 0;
  } 
  result = ((Math::Vector3 const *)arg1)->Reflect((Math::Vector3 const &)*arg2);
  jresult = new Math::Vector3((const Math::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec3_Project(void * jarg1, void * jarg2) {
  void * jresult ;
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  Math::Vector3 result;
  
  arg1 = (Math::Vector3 *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3Param type is null", 0);
    return 0;
  } 
  result = (arg1)->Project((Math::Vector3 const &)*arg2);
  jresult = new Math::Vector3((const Math::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_MochaVec3_AddScaledVector(void * jarg1, void * jarg2, float jarg3) {
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  float arg3 ;
  
  arg1 = (Math::Vector3 *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3Param type is null", 0);
    return ;
  } 
  arg3 = (float)jarg3; 
  (arg1)->AddScaledVector((Math::Vector3 const &)*arg2,arg3);
}


SWIGEXPORT float SWIGSTDCALL CSharp_MochaVec3_Dot(void * jarg1, void * jarg2) {
  float jresult ;
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  float result;
  
  arg1 = (Math::Vector3 *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3Param type is null", 0);
    return 0;
  } 
  result = (float)((Math::Vector3 const *)arg1)->Dot((Math::Vector3 const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_MochaVec3_Length(void * jarg1) {
  float jresult ;
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  float result;
  
  arg1 = (Math::Vector3 *)jarg1; 
  result = (float)((Math::Vector3 const *)arg1)->Length();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_MochaVec3_LengthSq(void * jarg1) {
  float jresult ;
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  float result;
  
  arg1 = (Math::Vector3 *)jarg1; 
  result = (float)((Math::Vector3 const *)arg1)->LengthSq();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec3_Normalized(void * jarg1) {
  void * jresult ;
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  Math::Vector3 result;
  
  arg1 = (Math::Vector3 *)jarg1; 
  result = ((Math::Vector3 const *)arg1)->Normalized();
  jresult = new Math::Vector3((const Math::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_MochaVec3_Normalize(void * jarg1) {
  float jresult ;
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  float result;
  
  arg1 = (Math::Vector3 *)jarg1; 
  result = (float)(arg1)->Normalize();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_MochaVec3_Ceil(void * jarg1) {
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  
  arg1 = (Math::Vector3 *)jarg1; 
  (arg1)->Ceil();
}


SWIGEXPORT void SWIGSTDCALL CSharp_MochaVec3_Floor(void * jarg1) {
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  
  arg1 = (Math::Vector3 *)jarg1; 
  (arg1)->Floor();
}


SWIGEXPORT void SWIGSTDCALL CSharp_MochaVec3_Truncate(void * jarg1) {
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  
  arg1 = (Math::Vector3 *)jarg1; 
  (arg1)->Truncate();
}


SWIGEXPORT void SWIGSTDCALL CSharp_MochaVec3_RoundToExtremes(void * jarg1) {
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  
  arg1 = (Math::Vector3 *)jarg1; 
  (arg1)->RoundToExtremes();
}


SWIGEXPORT void SWIGSTDCALL CSharp_MochaVec3_Round(void * jarg1) {
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  
  arg1 = (Math::Vector3 *)jarg1; 
  (arg1)->Round();
}


SWIGEXPORT float SWIGSTDCALL CSharp_MochaVec3_AttemptNormalize(void * jarg1) {
  float jresult ;
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  float result;
  
  arg1 = (Math::Vector3 *)jarg1; 
  result = (float)(arg1)->AttemptNormalize();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec3_Negate(void * jarg1) {
  void * jresult ;
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  Math::Vector3 *result = 0 ;
  
  arg1 = (Math::Vector3 *)jarg1; 
  result = (Math::Vector3 *) &(arg1)->Negate();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_MochaVec3_Valid(void * jarg1) {
  unsigned int jresult ;
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  bool result;
  
  arg1 = (Math::Vector3 *)jarg1; 
  result = (bool)((Math::Vector3 const *)arg1)->Valid();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec3_Cross(void * jarg1, void * jarg2) {
  void * jresult ;
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  Math::Vector3 result;
  
  arg1 = (Math::Vector3 *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3Param type is null", 0);
    return 0;
  } 
  result = ((Math::Vector3 const *)arg1)->Cross((Math::Vector3 const &)*arg2);
  jresult = new Math::Vector3((const Math::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_MochaVec3_InvertComponents(void * jarg1) {
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  
  arg1 = (Math::Vector3 *)jarg1; 
  (arg1)->InvertComponents();
}


SWIGEXPORT float SWIGSTDCALL CSharp_MochaVec3_Distance(void * jarg1, void * jarg2) {
  float jresult ;
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  Math::Vector3 *arg2 = (Math::Vector3 *) 0 ;
  float result;
  
  arg1 = (Math::Vector3 *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2; 
  result = (float)(arg1)->Distance((Math::Vector3 const *)arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec3_Cross2d(void * jarg1, void * jarg2) {
  void * jresult ;
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  Math::Vector3 *arg2 = (Math::Vector3 *) 0 ;
  Math::Vector3 result;
  
  arg1 = (Math::Vector3 *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2; 
  result = (arg1)->Cross2d((Math::Vector3 const *)arg2);
  jresult = new Math::Vector3((const Math::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec3_Min(void * jarg1, void * jarg2) {
  void * jresult ;
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  Math::Vector3 *arg2 = (Math::Vector3 *) 0 ;
  Math::Vector3 result;
  
  arg1 = (Math::Vector3 *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2; 
  result = (arg1)->Min((Math::Vector3 const *)arg2);
  jresult = new Math::Vector3((const Math::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec3_Max(void * jarg1, void * jarg2) {
  void * jresult ;
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  Math::Vector3 *arg2 = (Math::Vector3 *) 0 ;
  Math::Vector3 result;
  
  arg1 = (Math::Vector3 *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2; 
  result = (arg1)->Max((Math::Vector3 const *)arg2);
  jresult = new Math::Vector3((const Math::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec3_Lerp(void * jarg1, void * jarg2, float jarg3) {
  void * jresult ;
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  Math::Vector3 *arg2 = (Math::Vector3 *) 0 ;
  float arg3 ;
  Math::Vector3 result;
  
  arg1 = (Math::Vector3 *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2; 
  arg3 = (float)jarg3; 
  result = (arg1)->Lerp((Math::Vector3 const *)arg2,arg3);
  jresult = new Math::Vector3((const Math::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_MochaVec3_Clamp(void * jarg1, float jarg2, float jarg3) {
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  float arg2 ;
  float arg3 ;
  
  arg1 = (Math::Vector3 *)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  (arg1)->Clamp(arg2,arg3);
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_MochaVec3_AllLess(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  Math::Vector3 *arg2 = (Math::Vector3 *) 0 ;
  bool result;
  
  arg1 = (Math::Vector3 *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2; 
  result = (bool)(arg1)->AllLess((Math::Vector3 const *)arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_MochaVec3_AnyLess(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  Math::Vector3 *arg2 = (Math::Vector3 *) 0 ;
  bool result;
  
  arg1 = (Math::Vector3 *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2; 
  result = (bool)(arg1)->AnyLess((Math::Vector3 const *)arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_MochaVec3_AllGreater(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  Math::Vector3 *arg2 = (Math::Vector3 *) 0 ;
  bool result;
  
  arg1 = (Math::Vector3 *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2; 
  result = (bool)(arg1)->AllGreater((Math::Vector3 const *)arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_MochaVec3_AnyGreater(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  Math::Vector3 *arg2 = (Math::Vector3 *) 0 ;
  bool result;
  
  arg1 = (Math::Vector3 *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2; 
  result = (bool)(arg1)->AnyGreater((Math::Vector3 const *)arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_MochaVec3_x_set(void * jarg1, float jarg2) {
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  float arg2 ;
  
  arg1 = (Math::Vector3 *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->x = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_MochaVec3_x_get(void * jarg1) {
  float jresult ;
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  float result;
  
  arg1 = (Math::Vector3 *)jarg1; 
  result = (float) ((arg1)->x);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_MochaVec3_y_set(void * jarg1, float jarg2) {
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  float arg2 ;
  
  arg1 = (Math::Vector3 *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->y = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_MochaVec3_y_get(void * jarg1) {
  float jresult ;
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  float result;
  
  arg1 = (Math::Vector3 *)jarg1; 
  result = (float) ((arg1)->y);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_MochaVec3_z_set(void * jarg1, float jarg2) {
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  float arg2 ;
  
  arg1 = (Math::Vector3 *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->z = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_MochaVec3_z_get(void * jarg1) {
  float jresult ;
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  float result;
  
  arg1 = (Math::Vector3 *)jarg1; 
  result = (float) ((arg1)->z);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_MochaVec3_array_set(void * jarg1, void * jarg2) {
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  float *arg2 ;
  
  arg1 = (Math::Vector3 *)jarg1; 
  arg2 = (float *)jarg2; 
  {
    size_t ii;
    float *b = (float *) arg1->array;
    for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((float *) arg2 + ii);
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaVec3_array_get(void * jarg1) {
  void * jresult ;
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  float *result = 0 ;
  
  arg1 = (Math::Vector3 *)jarg1; 
  result = (float *)(float *) ((arg1)->array);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_MochaVec3(void * jarg1) {
  Math::Vector3 *arg1 = (Math::Vector3 *) 0 ;
  
  arg1 = (Math::Vector3 *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Color_r_set(void * jarg1, float jarg2) {
  Color *arg1 = (Color *) 0 ;
  float arg2 ;
  
  arg1 = (Color *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->r = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_Color_r_get(void * jarg1) {
  float jresult ;
  Color *arg1 = (Color *) 0 ;
  float result;
  
  arg1 = (Color *)jarg1; 
  result = (float) ((arg1)->r);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Color_g_set(void * jarg1, float jarg2) {
  Color *arg1 = (Color *) 0 ;
  float arg2 ;
  
  arg1 = (Color *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->g = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_Color_g_get(void * jarg1) {
  float jresult ;
  Color *arg1 = (Color *) 0 ;
  float result;
  
  arg1 = (Color *)jarg1; 
  result = (float) ((arg1)->g);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Color_b_set(void * jarg1, float jarg2) {
  Color *arg1 = (Color *) 0 ;
  float arg2 ;
  
  arg1 = (Color *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->b = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_Color_b_get(void * jarg1) {
  float jresult ;
  Color *arg1 = (Color *) 0 ;
  float result;
  
  arg1 = (Color *)jarg1; 
  result = (float) ((arg1)->b);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Color_a_set(void * jarg1, float jarg2) {
  Color *arg1 = (Color *) 0 ;
  float arg2 ;
  
  arg1 = (Color *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->a = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_Color_a_get(void * jarg1) {
  float jresult ;
  Color *arg1 = (Color *) 0 ;
  float result;
  
  arg1 = (Color *)jarg1; 
  result = (float) ((arg1)->a);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Color__SWIG_0(float jarg1, float jarg2, float jarg3, float jarg4) {
  void * jresult ;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  Color *result = 0 ;
  
  arg1 = (float)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  result = (Color *)new Color(arg1,arg2,arg3,arg4);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Color__SWIG_1(float jarg1, float jarg2, float jarg3) {
  void * jresult ;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  Color *result = 0 ;
  
  arg1 = (float)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  result = (Color *)new Color(arg1,arg2,arg3);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Color__SWIG_2(float jarg1, float jarg2) {
  void * jresult ;
  float arg1 ;
  float arg2 ;
  Color *result = 0 ;
  
  arg1 = (float)jarg1; 
  arg2 = (float)jarg2; 
  result = (Color *)new Color(arg1,arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Color__SWIG_3(float jarg1) {
  void * jresult ;
  float arg1 ;
  Color *result = 0 ;
  
  arg1 = (float)jarg1; 
  result = (Color *)new Color(arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Color__SWIG_4() {
  void * jresult ;
  Color *result = 0 ;
  
  result = (Color *)new Color();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Color__SWIG_5(void * jarg1) {
  void * jresult ;
  Vector4 *arg1 = 0 ;
  Color *result = 0 ;
  
  arg1 = (Vector4 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Vector4 const & type is null", 0);
    return 0;
  } 
  result = (Color *)new Color((Vector4 const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Color__SWIG_6(void * jarg1) {
  void * jresult ;
  Color *arg1 = 0 ;
  Color *result = 0 ;
  
  arg1 = (Color *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Color const & type is null", 0);
    return 0;
  } 
  result = (Color *)new Color((Color const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Color_Mul(void * jarg1, float jarg2) {
  void * jresult ;
  Color *arg1 = (Color *) 0 ;
  float *arg2 = 0 ;
  float temp2 ;
  Color result;
  
  arg1 = (Color *)jarg1; 
  temp2 = (float)jarg2; 
  arg2 = &temp2; 
  result = (arg1)->operator *((float const &)*arg2);
  jresult = new Color((const Color &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Color_MulAssign(void * jarg1, float jarg2) {
  void * jresult ;
  Color *arg1 = (Color *) 0 ;
  float *arg2 = 0 ;
  float temp2 ;
  Color *result = 0 ;
  
  arg1 = (Color *)jarg1; 
  temp2 = (float)jarg2; 
  arg2 = &temp2; 
  result = (Color *) &(arg1)->operator *=((float const &)*arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_Color_Comp(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  Color *arg1 = (Color *) 0 ;
  Color *arg2 = 0 ;
  bool result;
  
  arg1 = (Color *)jarg1; 
  arg2 = (Color *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Color const & type is null", 0);
    return 0;
  } 
  result = (bool)(arg1)->operator ==((Color const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_Color_NegComp(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  Color *arg1 = (Color *) 0 ;
  Color *arg2 = 0 ;
  bool result;
  
  arg1 = (Color *)jarg1; 
  arg2 = (Color *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Color const & type is null", 0);
    return 0;
  } 
  result = (bool)(arg1)->operator !=((Color const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_Color(void * jarg1) {
  Color *arg1 = (Color *) 0 ;
  
  arg1 = (Color *)jarg1; 
  delete arg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_WHITE_get() {
  void * jresult ;
  Color *result = 0 ;
  
  result = (Color *)&COLOR::WHITE;
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_BLACK_get() {
  void * jresult ;
  Color *result = 0 ;
  
  result = (Color *)&COLOR::BLACK;
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_RED_get() {
  void * jresult ;
  Color *result = 0 ;
  
  result = (Color *)&COLOR::RED;
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_GREEN_get() {
  void * jresult ;
  Color *result = 0 ;
  
  result = (Color *)&COLOR::GREEN;
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_BLUE_get() {
  void * jresult ;
  Color *result = 0 ;
  
  result = (Color *)&COLOR::BLUE;
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_YELLOW_get() {
  void * jresult ;
  Color *result = 0 ;
  
  result = (Color *)&COLOR::YELLOW;
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_SILVER_get() {
  void * jresult ;
  Color *result = 0 ;
  
  result = (Color *)&COLOR::SILVER;
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_LIGHT_STEEL_BLUE_get() {
  void * jresult ;
  Color *result = 0 ;
  
  result = (Color *)&COLOR::LIGHT_STEEL_BLUE;
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CORNFLOWER_BLUE_get() {
  void * jresult ;
  Color *result = 0 ;
  
  result = (Color *)&COLOR::CORNFLOWER_BLUE;
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_LIME_GREEN_get() {
  void * jresult ;
  Color *result = 0 ;
  
  result = (Color *)&COLOR::LIME_GREEN;
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_GREY_get() {
  void * jresult ;
  Color *result = 0 ;
  
  result = (Color *)&COLOR::GREY;
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_EulerAngles_Angles_set(void * jarg1, void * jarg2) {
  EulerAngles *arg1 = (EulerAngles *) 0 ;
  Math::Vector3 *arg2 = (Math::Vector3 *) 0 ;
  
  arg1 = (EulerAngles *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2; 
  if (arg1) (arg1)->Angles = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_EulerAngles_Angles_get(void * jarg1) {
  void * jresult ;
  EulerAngles *arg1 = (EulerAngles *) 0 ;
  Math::Vector3 *result = 0 ;
  
  arg1 = (EulerAngles *)jarg1; 
  result = (Math::Vector3 *)& ((arg1)->Angles);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_EulerAngles() {
  void * jresult ;
  EulerAngles *result = 0 ;
  
  result = (EulerAngles *)new EulerAngles();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_EulerAngles(void * jarg1) {
  EulerAngles *arg1 = (EulerAngles *) 0 ;
  
  arg1 = (EulerAngles *)jarg1; 
  delete arg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Vertex() {
  void * jresult ;
  Vertex *result = 0 ;
  
  result = (Vertex *)new Vertex();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_Vertex(void * jarg1) {
  Vertex *arg1 = (Vertex *) 0 ;
  
  arg1 = (Vertex *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Vertex_mPosition_set(void * jarg1, void * jarg2) {
  Vertex *arg1 = (Vertex *) 0 ;
  Vector3 arg2 ;
  Vector3 *argp2 ;
  
  arg1 = (Vertex *)jarg1; 
  argp2 = (Vector3 *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null Vector3", 0);
    return ;
  }
  arg2 = *argp2; 
  if (arg1) (arg1)->mPosition = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Vertex_mPosition_get(void * jarg1) {
  void * jresult ;
  Vertex *arg1 = (Vertex *) 0 ;
  Vector3 result;
  
  arg1 = (Vertex *)jarg1; 
  result =  ((arg1)->mPosition);
  jresult = new Vector3((const Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Vertex_mColor_set(void * jarg1, void * jarg2) {
  Vertex *arg1 = (Vertex *) 0 ;
  Color *arg2 = (Color *) 0 ;
  
  arg1 = (Vertex *)jarg1; 
  arg2 = (Color *)jarg2; 
  if (arg1) (arg1)->mColor = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Vertex_mColor_get(void * jarg1) {
  void * jresult ;
  Vertex *arg1 = (Vertex *) 0 ;
  Color *result = 0 ;
  
  arg1 = (Vertex *)jarg1; 
  result = (Color *)& ((arg1)->mColor);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Vertex_mTextureCoords_set(void * jarg1, void * jarg2) {
  Vertex *arg1 = (Vertex *) 0 ;
  Vector2 arg2 ;
  Vector2 *argp2 ;
  
  arg1 = (Vertex *)jarg1; 
  argp2 = (Vector2 *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null Vector2", 0);
    return ;
  }
  arg2 = *argp2; 
  if (arg1) (arg1)->mTextureCoords = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Vertex_mTextureCoords_get(void * jarg1) {
  void * jresult ;
  Vertex *arg1 = (Vertex *) 0 ;
  Vector2 result;
  
  arg1 = (Vertex *)jarg1; 
  result =  ((arg1)->mTextureCoords);
  jresult = new Vector2((const Vector2 &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Vertex_mNormal_set(void * jarg1, void * jarg2) {
  Vertex *arg1 = (Vertex *) 0 ;
  Vector3 arg2 ;
  Vector3 *argp2 ;
  
  arg1 = (Vertex *)jarg1; 
  argp2 = (Vector3 *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null Vector3", 0);
    return ;
  }
  arg2 = *argp2; 
  if (arg1) (arg1)->mNormal = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Vertex_mNormal_get(void * jarg1) {
  void * jresult ;
  Vertex *arg1 = (Vertex *) 0 ;
  Vector3 result;
  
  arg1 = (Vertex *)jarg1; 
  result =  ((arg1)->mNormal);
  jresult = new Vector3((const Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Vertex_tangent_set(void * jarg1, void * jarg2) {
  Vertex *arg1 = (Vertex *) 0 ;
  Vector3 arg2 ;
  Vector3 *argp2 ;
  
  arg1 = (Vertex *)jarg1; 
  argp2 = (Vector3 *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null Vector3", 0);
    return ;
  }
  arg2 = *argp2; 
  if (arg1) (arg1)->tangent = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Vertex_tangent_get(void * jarg1) {
  void * jresult ;
  Vertex *arg1 = (Vertex *) 0 ;
  Vector3 result;
  
  arg1 = (Vertex *)jarg1; 
  result =  ((arg1)->tangent);
  jresult = new Vector3((const Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Vertex_binormal_set(void * jarg1, void * jarg2) {
  Vertex *arg1 = (Vertex *) 0 ;
  Vector3 arg2 ;
  Vector3 *argp2 ;
  
  arg1 = (Vertex *)jarg1; 
  argp2 = (Vector3 *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null Vector3", 0);
    return ;
  }
  arg2 = *argp2; 
  if (arg1) (arg1)->binormal = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Vertex_binormal_get(void * jarg1) {
  void * jresult ;
  Vertex *arg1 = (Vertex *) 0 ;
  Vector3 result;
  
  arg1 = (Vertex *)jarg1; 
  result =  ((arg1)->binormal);
  jresult = new Vector3((const Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_SkinnedVertex() {
  void * jresult ;
  SkinnedVertex *result = 0 ;
  
  result = (SkinnedVertex *)new SkinnedVertex();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_SkinnedVertex(void * jarg1) {
  SkinnedVertex *arg1 = (SkinnedVertex *) 0 ;
  
  arg1 = (SkinnedVertex *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_SkinnedVertex_mPosition_set(void * jarg1, void * jarg2) {
  SkinnedVertex *arg1 = (SkinnedVertex *) 0 ;
  Vector3 arg2 ;
  Vector3 *argp2 ;
  
  arg1 = (SkinnedVertex *)jarg1; 
  argp2 = (Vector3 *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null Vector3", 0);
    return ;
  }
  arg2 = *argp2; 
  if (arg1) (arg1)->mPosition = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_SkinnedVertex_mPosition_get(void * jarg1) {
  void * jresult ;
  SkinnedVertex *arg1 = (SkinnedVertex *) 0 ;
  Vector3 result;
  
  arg1 = (SkinnedVertex *)jarg1; 
  result =  ((arg1)->mPosition);
  jresult = new Vector3((const Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_SkinnedVertex_mColor_set(void * jarg1, void * jarg2) {
  SkinnedVertex *arg1 = (SkinnedVertex *) 0 ;
  Color *arg2 = (Color *) 0 ;
  
  arg1 = (SkinnedVertex *)jarg1; 
  arg2 = (Color *)jarg2; 
  if (arg1) (arg1)->mColor = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_SkinnedVertex_mColor_get(void * jarg1) {
  void * jresult ;
  SkinnedVertex *arg1 = (SkinnedVertex *) 0 ;
  Color *result = 0 ;
  
  arg1 = (SkinnedVertex *)jarg1; 
  result = (Color *)& ((arg1)->mColor);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_SkinnedVertex_mTextureCoords_set(void * jarg1, void * jarg2) {
  SkinnedVertex *arg1 = (SkinnedVertex *) 0 ;
  Vector2 arg2 ;
  Vector2 *argp2 ;
  
  arg1 = (SkinnedVertex *)jarg1; 
  argp2 = (Vector2 *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null Vector2", 0);
    return ;
  }
  arg2 = *argp2; 
  if (arg1) (arg1)->mTextureCoords = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_SkinnedVertex_mTextureCoords_get(void * jarg1) {
  void * jresult ;
  SkinnedVertex *arg1 = (SkinnedVertex *) 0 ;
  Vector2 result;
  
  arg1 = (SkinnedVertex *)jarg1; 
  result =  ((arg1)->mTextureCoords);
  jresult = new Vector2((const Vector2 &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_SkinnedVertex_mNormal_set(void * jarg1, void * jarg2) {
  SkinnedVertex *arg1 = (SkinnedVertex *) 0 ;
  Vector3 arg2 ;
  Vector3 *argp2 ;
  
  arg1 = (SkinnedVertex *)jarg1; 
  argp2 = (Vector3 *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null Vector3", 0);
    return ;
  }
  arg2 = *argp2; 
  if (arg1) (arg1)->mNormal = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_SkinnedVertex_mNormal_get(void * jarg1) {
  void * jresult ;
  SkinnedVertex *arg1 = (SkinnedVertex *) 0 ;
  Vector3 result;
  
  arg1 = (SkinnedVertex *)jarg1; 
  result =  ((arg1)->mNormal);
  jresult = new Vector3((const Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_SkinnedVertex_mTangent_set(void * jarg1, void * jarg2) {
  SkinnedVertex *arg1 = (SkinnedVertex *) 0 ;
  Vector3 arg2 ;
  Vector3 *argp2 ;
  
  arg1 = (SkinnedVertex *)jarg1; 
  argp2 = (Vector3 *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null Vector3", 0);
    return ;
  }
  arg2 = *argp2; 
  if (arg1) (arg1)->mTangent = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_SkinnedVertex_mTangent_get(void * jarg1) {
  void * jresult ;
  SkinnedVertex *arg1 = (SkinnedVertex *) 0 ;
  Vector3 result;
  
  arg1 = (SkinnedVertex *)jarg1; 
  result =  ((arg1)->mTangent);
  jresult = new Vector3((const Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_SkinnedVertex_mBinormal_set(void * jarg1, void * jarg2) {
  SkinnedVertex *arg1 = (SkinnedVertex *) 0 ;
  Vector3 arg2 ;
  Vector3 *argp2 ;
  
  arg1 = (SkinnedVertex *)jarg1; 
  argp2 = (Vector3 *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null Vector3", 0);
    return ;
  }
  arg2 = *argp2; 
  if (arg1) (arg1)->mBinormal = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_SkinnedVertex_mBinormal_get(void * jarg1) {
  void * jresult ;
  SkinnedVertex *arg1 = (SkinnedVertex *) 0 ;
  Vector3 result;
  
  arg1 = (SkinnedVertex *)jarg1; 
  result =  ((arg1)->mBinormal);
  jresult = new Vector3((const Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_SkinnedVertex_mBlendWeights_set(void * jarg1, void * jarg2) {
  SkinnedVertex *arg1 = (SkinnedVertex *) 0 ;
  Vector4 arg2 ;
  Vector4 *argp2 ;
  
  arg1 = (SkinnedVertex *)jarg1; 
  argp2 = (Vector4 *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null Vector4", 0);
    return ;
  }
  arg2 = *argp2; 
  if (arg1) (arg1)->mBlendWeights = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_SkinnedVertex_mBlendWeights_get(void * jarg1) {
  void * jresult ;
  SkinnedVertex *arg1 = (SkinnedVertex *) 0 ;
  Vector4 result;
  
  arg1 = (SkinnedVertex *)jarg1; 
  result =  ((arg1)->mBlendWeights);
  jresult = new Vector4((const Vector4 &)result); 
  return jresult;
}


SWIGEXPORT char * SWIGSTDCALL CSharp_IMeta_mytoplevelname(void * jarg1) {
  char * jresult ;
  IMeta *arg1 = (IMeta *) 0 ;
  std::string result;
  
  arg1 = (IMeta *)jarg1; 
  result = ((IMeta const *)arg1)->mytoplevelname();
  jresult = SWIG_csharp_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_IMeta_mytopid(void * jarg1) {
  unsigned int jresult ;
  IMeta *arg1 = (IMeta *) 0 ;
  unsigned int result;
  
  arg1 = (IMeta *)jarg1; 
  result = (unsigned int)((IMeta const *)arg1)->mytopid();
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_IMeta_gettopid() {
  unsigned int jresult ;
  unsigned int result;
  
  result = (unsigned int)IMeta::gettopid();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_LayerMask_AddLayer(void * jarg1, int jarg2) {
  LayerMask *arg1 = (LayerMask *) 0 ;
  LayerMask::Layers arg2 ;
  
  arg1 = (LayerMask *)jarg1; 
  arg2 = (LayerMask::Layers)jarg2; 
  (arg1)->AddLayer(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_LayerMask_RemoveLayer(void * jarg1, int jarg2) {
  LayerMask *arg1 = (LayerMask *) 0 ;
  LayerMask::Layers arg2 ;
  
  arg1 = (LayerMask *)jarg1; 
  arg2 = (LayerMask::Layers)jarg2; 
  (arg1)->RemoveLayer(arg2);
}


SWIGEXPORT int SWIGSTDCALL CSharp_LayerMask_GetLayerMasks(void * jarg1) {
  int jresult ;
  LayerMask *arg1 = (LayerMask *) 0 ;
  int result;
  
  arg1 = (LayerMask *)jarg1; 
  result = (int)(arg1)->GetLayerMasks();
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_LayerMask_IsOnLayer(void * jarg1, int jarg2) {
  unsigned int jresult ;
  LayerMask *arg1 = (LayerMask *) 0 ;
  LayerMask::Layers arg2 ;
  bool result;
  
  arg1 = (LayerMask *)jarg1; 
  arg2 = (LayerMask::Layers)jarg2; 
  result = (bool)(arg1)->IsOnLayer(arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_ComponentVector_Clear(void * jarg1) {
  std::vector< Component * > *arg1 = (std::vector< Component * > *) 0 ;
  
  arg1 = (std::vector< Component * > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_ComponentVector_Add(void * jarg1, void * jarg2) {
  std::vector< Component * > *arg1 = (std::vector< Component * > *) 0 ;
  Component **arg2 = 0 ;
  Component *temp2 = 0 ;
  
  arg1 = (std::vector< Component * > *)jarg1; 
  temp2 = (Component *)jarg2;
  arg2 = (Component **)&temp2; 
  (arg1)->push_back((Component *const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_ComponentVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< Component * > *arg1 = (std::vector< Component * > *) 0 ;
  std::vector< Component * >::size_type result;
  
  arg1 = (std::vector< Component * > *)jarg1; 
  result = ((std::vector< Component * > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_ComponentVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< Component * > *arg1 = (std::vector< Component * > *) 0 ;
  std::vector< Component * >::size_type result;
  
  arg1 = (std::vector< Component * > *)jarg1; 
  result = ((std::vector< Component * > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_ComponentVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< Component * > *arg1 = (std::vector< Component * > *) 0 ;
  std::vector< Component * >::size_type arg2 ;
  
  arg1 = (std::vector< Component * > *)jarg1; 
  arg2 = (std::vector< Component * >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_ComponentVector__SWIG_0() {
  void * jresult ;
  std::vector< Component * > *result = 0 ;
  
  result = (std::vector< Component * > *)new std::vector< Component * >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_ComponentVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< Component * > *arg1 = 0 ;
  std::vector< Component * > *result = 0 ;
  
  arg1 = (std::vector< Component * > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< Component * > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< Component * > *)new std::vector< Component * >((std::vector< Component * > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_ComponentVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< Component * > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< Component * > *)new_std_vector_Sl_Component_Sm__Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_ComponentVector_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< Component * > *arg1 = (std::vector< Component * > *) 0 ;
  int arg2 ;
  Component *result = 0 ;
  
  arg1 = (std::vector< Component * > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (Component *)std_vector_Sl_Component_Sm__Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_ComponentVector_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< Component * > *arg1 = (std::vector< Component * > *) 0 ;
  int arg2 ;
  Component **result = 0 ;
  
  arg1 = (std::vector< Component * > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (Component **) &std_vector_Sl_Component_Sm__Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)*result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_ComponentVector_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< Component * > *arg1 = (std::vector< Component * > *) 0 ;
  int arg2 ;
  Component **arg3 = 0 ;
  Component *temp3 = 0 ;
  
  arg1 = (std::vector< Component * > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (Component *)jarg3;
  arg3 = (Component **)&temp3; 
  try {
    std_vector_Sl_Component_Sm__Sg__setitem(arg1,arg2,(Component *const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_ComponentVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< Component * > *arg1 = (std::vector< Component * > *) 0 ;
  std::vector< Component * > *arg2 = 0 ;
  
  arg1 = (std::vector< Component * > *)jarg1; 
  arg2 = (std::vector< Component * > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< Component * > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_Component_Sm__Sg__AddRange(arg1,(std::vector< Component * > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_ComponentVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< Component * > *arg1 = (std::vector< Component * > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< Component * > *result = 0 ;
  
  arg1 = (std::vector< Component * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< Component * > *)std_vector_Sl_Component_Sm__Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_ComponentVector_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< Component * > *arg1 = (std::vector< Component * > *) 0 ;
  int arg2 ;
  Component **arg3 = 0 ;
  Component *temp3 = 0 ;
  
  arg1 = (std::vector< Component * > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (Component *)jarg3;
  arg3 = (Component **)&temp3; 
  try {
    std_vector_Sl_Component_Sm__Sg__Insert(arg1,arg2,(Component *const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_ComponentVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< Component * > *arg1 = (std::vector< Component * > *) 0 ;
  int arg2 ;
  std::vector< Component * > *arg3 = 0 ;
  
  arg1 = (std::vector< Component * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< Component * > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< Component * > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_Component_Sm__Sg__InsertRange(arg1,arg2,(std::vector< Component * > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_ComponentVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< Component * > *arg1 = (std::vector< Component * > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< Component * > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_Component_Sm__Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_ComponentVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< Component * > *arg1 = (std::vector< Component * > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< Component * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_Component_Sm__Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_ComponentVector_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  Component **arg1 = 0 ;
  int arg2 ;
  Component *temp1 = 0 ;
  std::vector< Component * > *result = 0 ;
  
  temp1 = (Component *)jarg1;
  arg1 = (Component **)&temp1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< Component * > *)std_vector_Sl_Component_Sm__Sg__Repeat((Component *const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_ComponentVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< Component * > *arg1 = (std::vector< Component * > *) 0 ;
  
  arg1 = (std::vector< Component * > *)jarg1; 
  std_vector_Sl_Component_Sm__Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_ComponentVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< Component * > *arg1 = (std::vector< Component * > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< Component * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_Component_Sm__Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_ComponentVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< Component * > *arg1 = (std::vector< Component * > *) 0 ;
  int arg2 ;
  std::vector< Component * > *arg3 = 0 ;
  
  arg1 = (std::vector< Component * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< Component * > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< Component * > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_Component_Sm__Sg__SetRange(arg1,arg2,(std::vector< Component * > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_ComponentVector_Contains(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::vector< Component * > *arg1 = (std::vector< Component * > *) 0 ;
  Component **arg2 = 0 ;
  Component *temp2 = 0 ;
  bool result;
  
  arg1 = (std::vector< Component * > *)jarg1; 
  temp2 = (Component *)jarg2;
  arg2 = (Component **)&temp2; 
  result = (bool)std_vector_Sl_Component_Sm__Sg__Contains(arg1,(Component *const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_ComponentVector_IndexOf(void * jarg1, void * jarg2) {
  int jresult ;
  std::vector< Component * > *arg1 = (std::vector< Component * > *) 0 ;
  Component **arg2 = 0 ;
  Component *temp2 = 0 ;
  int result;
  
  arg1 = (std::vector< Component * > *)jarg1; 
  temp2 = (Component *)jarg2;
  arg2 = (Component **)&temp2; 
  result = (int)std_vector_Sl_Component_Sm__Sg__IndexOf(arg1,(Component *const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_ComponentVector_LastIndexOf(void * jarg1, void * jarg2) {
  int jresult ;
  std::vector< Component * > *arg1 = (std::vector< Component * > *) 0 ;
  Component **arg2 = 0 ;
  Component *temp2 = 0 ;
  int result;
  
  arg1 = (std::vector< Component * > *)jarg1; 
  temp2 = (Component *)jarg2;
  arg2 = (Component **)&temp2; 
  result = (int)std_vector_Sl_Component_Sm__Sg__LastIndexOf(arg1,(Component *const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_ComponentVector_Remove(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::vector< Component * > *arg1 = (std::vector< Component * > *) 0 ;
  Component **arg2 = 0 ;
  Component *temp2 = 0 ;
  bool result;
  
  arg1 = (std::vector< Component * > *)jarg1; 
  temp2 = (Component *)jarg2;
  arg2 = (Component **)&temp2; 
  result = (bool)std_vector_Sl_Component_Sm__Sg__Remove(arg1,(Component *const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_ComponentVector(void * jarg1) {
  std::vector< Component * > *arg1 = (std::vector< Component * > *) 0 ;
  
  arg1 = (std::vector< Component * > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_TagSet__SWIG_0() {
  void * jresult ;
  std::set< string > *result = 0 ;
  
  result = (std::set< string > *)new std::set< string >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_TagSet__SWIG_1(void * jarg1) {
  void * jresult ;
  std::set< std::string > *arg1 = 0 ;
  std::set< string > *result = 0 ;
  
  arg1 = (std::set< std::string > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::set< std::string > const & type is null", 0);
    return 0;
  } 
  result = (std::set< string > *)new std::set< string >((std::set< std::string > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_TagSet_size(void * jarg1) {
  unsigned long jresult ;
  std::set< string > *arg1 = (std::set< string > *) 0 ;
  std::set< string >::size_type result;
  
  arg1 = (std::set< string > *)jarg1; 
  result = ((std::set< string > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_TagSet_empty(void * jarg1) {
  unsigned int jresult ;
  std::set< string > *arg1 = (std::set< string > *) 0 ;
  bool result;
  
  arg1 = (std::set< string > *)jarg1; 
  result = (bool)((std::set< string > const *)arg1)->empty();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_TagSet_Clear(void * jarg1) {
  std::set< string > *arg1 = (std::set< string > *) 0 ;
  
  arg1 = (std::set< string > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT char * SWIGSTDCALL CSharp_TagSet_getitem(void * jarg1, char * jarg2) {
  char * jresult ;
  std::set< string > *arg1 = (std::set< string > *) 0 ;
  std::set< string >::value_type *arg2 = 0 ;
  std::set< string >::value_type *result = 0 ;
  
  arg1 = (std::set< string > *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  std::set< string >::value_type arg2_str(jarg2);
  arg2 = &arg2_str; 
  try {
    result = (std::set< string >::value_type *) &std_set_Sl_string_Sg__getitem(arg1,(std::string const &)*arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = SWIG_csharp_string_callback(result->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_TagSet_setitem(void * jarg1, char * jarg2) {
  std::set< string > *arg1 = (std::set< string > *) 0 ;
  std::set< string >::value_type *arg2 = 0 ;
  
  arg1 = (std::set< string > *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  std::set< string >::value_type arg2_str(jarg2);
  arg2 = &arg2_str; 
  std_set_Sl_string_Sg__setitem(arg1,(std::string const &)*arg2);
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_TagSet_Contains(void * jarg1, char * jarg2) {
  unsigned int jresult ;
  std::set< string > *arg1 = (std::set< string > *) 0 ;
  std::set< string >::value_type *arg2 = 0 ;
  bool result;
  
  arg1 = (std::set< string > *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  std::set< string >::value_type arg2_str(jarg2);
  arg2 = &arg2_str; 
  result = (bool)std_set_Sl_string_Sg__Contains(arg1,(std::string const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_TagSet_Add(void * jarg1, char * jarg2) {
  std::set< string > *arg1 = (std::set< string > *) 0 ;
  std::set< string >::value_type *arg2 = 0 ;
  
  arg1 = (std::set< string > *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  std::set< string >::value_type arg2_str(jarg2);
  arg2 = &arg2_str; 
  try {
    std_set_Sl_string_Sg__Add(arg1,(std::string const &)*arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_TagSet_Remove(void * jarg1, char * jarg2) {
  unsigned int jresult ;
  std::set< string > *arg1 = (std::set< string > *) 0 ;
  std::set< string >::value_type *arg2 = 0 ;
  bool result;
  
  arg1 = (std::set< string > *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  std::set< string >::value_type arg2_str(jarg2);
  arg2 = &arg2_str; 
  result = (bool)std_set_Sl_string_Sg__Remove(arg1,(std::string const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_TagSet_create_iterator_begin(void * jarg1) {
  void * jresult ;
  std::set< string > *arg1 = (std::set< string > *) 0 ;
  std::set< std::string >::iterator *result = 0 ;
  
  arg1 = (std::set< string > *)jarg1; 
  result = (std::set< std::string >::iterator *)std_set_Sl_string_Sg__create_iterator_begin(arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_TagSet_is_iterator_good(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::set< string > *arg1 = (std::set< string > *) 0 ;
  std::set< std::string >::iterator *arg2 = (std::set< std::string >::iterator *) 0 ;
  bool result;
  
  arg1 = (std::set< string > *)jarg1; 
  arg2 = (std::set< std::string >::iterator *)jarg2; 
  result = (bool)std_set_Sl_string_Sg__is_iterator_good(arg1,arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT char * SWIGSTDCALL CSharp_TagSet_get_next_key(void * jarg1, void * jarg2) {
  char * jresult ;
  std::set< string > *arg1 = (std::set< string > *) 0 ;
  std::set< std::string >::iterator *arg2 = (std::set< std::string >::iterator *) 0 ;
  std::set< string >::value_type *result = 0 ;
  
  arg1 = (std::set< string > *)jarg1; 
  arg2 = (std::set< std::string >::iterator *)jarg2; 
  result = (std::set< string >::value_type *) &std_set_Sl_string_Sg__get_next_key(arg1,arg2);
  jresult = SWIG_csharp_string_callback(result->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_TagSet_destroy_iterator(void * jarg1, void * jarg2) {
  std::set< string > *arg1 = (std::set< string > *) 0 ;
  std::set< std::string >::iterator *arg2 = (std::set< std::string >::iterator *) 0 ;
  
  arg1 = (std::set< string > *)jarg1; 
  arg2 = (std::set< std::string >::iterator *)jarg2; 
  std_set_Sl_string_Sg__destroy_iterator(arg1,arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_TagSet(void * jarg1) {
  std::set< string > *arg1 = (std::set< string > *) 0 ;
  
  arg1 = (std::set< string > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_GameObject_flags_set(void * jarg1, void * jarg2) {
  GameObject *arg1 = (GameObject *) 0 ;
  std::set< std::string > *arg2 = (std::set< std::string > *) 0 ;
  
  arg1 = (GameObject *)jarg1; 
  arg2 = (std::set< std::string > *)jarg2; 
  if (arg1) (arg1)->flags = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_GameObject_flags_get(void * jarg1) {
  void * jresult ;
  GameObject *arg1 = (GameObject *) 0 ;
  std::set< std::string > *result = 0 ;
  
  arg1 = (GameObject *)jarg1; 
  result = (std::set< std::string > *)& ((arg1)->flags);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_GameObject_Duplicate(void * jarg1) {
  void * jresult ;
  GameObject *arg1 = (GameObject *) 0 ;
  GameObject *result = 0 ;
  
  arg1 = (GameObject *)jarg1; 
  result = (GameObject *)(arg1)->Duplicate();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_GameObject_Destroy(void * jarg1) {
  GameObject *arg1 = (GameObject *) 0 ;
  
  arg1 = (GameObject *)jarg1; 
  (arg1)->Destroy();
}


SWIGEXPORT void SWIGSTDCALL CSharp_GameObject_SetFlag(void * jarg1, char * jarg2) {
  GameObject *arg1 = (GameObject *) 0 ;
  std::string arg2 ;
  
  arg1 = (GameObject *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  (&arg2)->assign(jarg2); 
  (arg1)->SetFlag(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_GameObject_ClearFlag(void * jarg1, char * jarg2) {
  GameObject *arg1 = (GameObject *) 0 ;
  std::string arg2 ;
  
  arg1 = (GameObject *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  (&arg2)->assign(jarg2); 
  (arg1)->ClearFlag(arg2);
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_GameObject_GetFlag(void * jarg1, char * jarg2) {
  unsigned int jresult ;
  GameObject *arg1 = (GameObject *) 0 ;
  std::string arg2 ;
  bool result;
  
  arg1 = (GameObject *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  (&arg2)->assign(jarg2); 
  result = (bool)(arg1)->GetFlag(arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_GameObject_GetID(void * jarg1) {
  unsigned int jresult ;
  GameObject *arg1 = (GameObject *) 0 ;
  unsigned int result;
  
  arg1 = (GameObject *)jarg1; 
  result = (unsigned int)(arg1)->GetID();
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_GameObject_HasComponentByName(void * jarg1, char * jarg2) {
  unsigned int jresult ;
  GameObject *arg1 = (GameObject *) 0 ;
  std::string arg2 ;
  bool result;
  
  arg1 = (GameObject *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  (&arg2)->assign(jarg2); 
  result = (bool)(arg1)->HasComponentByName(arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT char * SWIGSTDCALL CSharp_GameObject_GetName(void * jarg1) {
  char * jresult ;
  GameObject *arg1 = (GameObject *) 0 ;
  std::string result;
  
  arg1 = (GameObject *)jarg1; 
  result = ((GameObject const *)arg1)->GetName();
  jresult = SWIG_csharp_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT char * SWIGSTDCALL CSharp_GameObject_SetName(void * jarg1, char * jarg2) {
  char * jresult ;
  GameObject *arg1 = (GameObject *) 0 ;
  std::string arg2 ;
  std::string result;
  
  arg1 = (GameObject *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  (&arg2)->assign(jarg2); 
  result = (arg1)->SetName(arg2);
  jresult = SWIG_csharp_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_GameObject_RequireComponentByName(void * jarg1, char * jarg2) {
  void * jresult ;
  GameObject *arg1 = (GameObject *) 0 ;
  std::string arg2 ;
  Component *result = 0 ;
  
  arg1 = (GameObject *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  (&arg2)->assign(jarg2); 
  result = (Component *)(arg1)->RequireComponentByName(arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_GameObject_GetComponentByName__SWIG_0(void * jarg1, char * jarg2) {
  void * jresult ;
  GameObject *arg1 = (GameObject *) 0 ;
  std::string arg2 ;
  Component *result = 0 ;
  
  arg1 = (GameObject *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  (&arg2)->assign(jarg2); 
  result = (Component *)(arg1)->GetComponentByName(arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_GameObject_GetComponentByName__SWIG_1(void * jarg1, char * jarg2, unsigned int jarg3) {
  void * jresult ;
  GameObject *arg1 = (GameObject *) 0 ;
  std::string arg2 ;
  bool arg3 ;
  Component *result = 0 ;
  
  arg1 = (GameObject *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  (&arg2)->assign(jarg2); 
  arg3 = jarg3 ? true : false; 
  result = (Component *)(arg1)->GetComponentByName(arg2,arg3);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_GameObject_GetComponentInChildren(void * jarg1, char * jarg2) {
  void * jresult ;
  GameObject *arg1 = (GameObject *) 0 ;
  std::string arg2 ;
  Component *result = 0 ;
  
  arg1 = (GameObject *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  (&arg2)->assign(jarg2); 
  result = (Component *)(arg1)->GetComponentInChildren(arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_GameObject_transform_set(void * jarg1, void * jarg2) {
  GameObject *arg1 = (GameObject *) 0 ;
  CTransform *arg2 = (CTransform *) 0 ;
  
  arg1 = (GameObject *)jarg1; 
  arg2 = (CTransform *)jarg2; 
  if (arg1) (arg1)->transform = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_GameObject_transform_get(void * jarg1) {
  void * jresult ;
  GameObject *arg1 = (GameObject *) 0 ;
  CTransform *result = 0 ;
  
  arg1 = (GameObject *)jarg1; 
  result = (CTransform *) ((arg1)->transform);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_GameObject_mName_set(void * jarg1, char * jarg2) {
  GameObject *arg1 = (GameObject *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (GameObject *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  if (arg1) (arg1)->mName = *arg2;
}


SWIGEXPORT char * SWIGSTDCALL CSharp_GameObject_mName_get(void * jarg1) {
  char * jresult ;
  GameObject *arg1 = (GameObject *) 0 ;
  std::string *result = 0 ;
  
  arg1 = (GameObject *)jarg1; 
  result = (std::string *) & ((arg1)->mName);
  jresult = SWIG_csharp_string_callback(result->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_GameObject_mGUID_set(void * jarg1, char * jarg2) {
  GameObject *arg1 = (GameObject *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (GameObject *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  if (arg1) (arg1)->mGUID = *arg2;
}


SWIGEXPORT char * SWIGSTDCALL CSharp_GameObject_mGUID_get(void * jarg1) {
  char * jresult ;
  GameObject *arg1 = (GameObject *) 0 ;
  std::string *result = 0 ;
  
  arg1 = (GameObject *)jarg1; 
  result = (std::string *) & ((arg1)->mGUID);
  jresult = SWIG_csharp_string_callback(result->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_GameObject_mComponents_set(void * jarg1, void * jarg2) {
  GameObject *arg1 = (GameObject *) 0 ;
  std::vector< Component * > *arg2 = (std::vector< Component * > *) 0 ;
  
  arg1 = (GameObject *)jarg1; 
  arg2 = (std::vector< Component * > *)jarg2; 
  if (arg1) (arg1)->mComponents = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_GameObject_mComponents_get(void * jarg1) {
  void * jresult ;
  GameObject *arg1 = (GameObject *) 0 ;
  std::vector< Component * > *result = 0 ;
  
  arg1 = (GameObject *)jarg1; 
  result = (std::vector< Component * > *)& ((arg1)->mComponents);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_GameObject_mIsSelected_set(void * jarg1, unsigned int jarg2) {
  GameObject *arg1 = (GameObject *) 0 ;
  bool arg2 ;
  
  arg1 = (GameObject *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->mIsSelected = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_GameObject_mIsSelected_get(void * jarg1) {
  unsigned int jresult ;
  GameObject *arg1 = (GameObject *) 0 ;
  bool result;
  
  arg1 = (GameObject *)jarg1; 
  result = (bool) ((arg1)->mIsSelected);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_GameObject_mLayerMask_set(void * jarg1, void * jarg2) {
  GameObject *arg1 = (GameObject *) 0 ;
  LayerMask *arg2 = (LayerMask *) 0 ;
  
  arg1 = (GameObject *)jarg1; 
  arg2 = (LayerMask *)jarg2; 
  if (arg1) (arg1)->mLayerMask = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_GameObject_mLayerMask_get(void * jarg1) {
  void * jresult ;
  GameObject *arg1 = (GameObject *) 0 ;
  LayerMask *result = 0 ;
  
  arg1 = (GameObject *)jarg1; 
  result = (LayerMask *)& ((arg1)->mLayerMask);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_GameObject_LookAt__SWIG_0(void * jarg1, void * jarg2) {
  GameObject *arg1 = (GameObject *) 0 ;
  Vector3 *arg2 = 0 ;
  
  arg1 = (GameObject *)jarg1; 
  arg2 = (Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Vector3 const & type is null", 0);
    return ;
  } 
  (arg1)->LookAt((Vector3 const &)*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_GameObject_LookAt__SWIG_1(void * jarg1, void * jarg2) {
  GameObject *arg1 = (GameObject *) 0 ;
  GameObject *arg2 = 0 ;
  
  arg1 = (GameObject *)jarg1; 
  arg2 = (GameObject *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "GameObject const & type is null", 0);
    return ;
  } 
  (arg1)->LookAt((GameObject const &)*arg2);
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_GameObject_GetIsDormantObject(void * jarg1) {
  unsigned int jresult ;
  GameObject *arg1 = (GameObject *) 0 ;
  bool result;
  
  arg1 = (GameObject *)jarg1; 
  result = (bool)(arg1)->GetIsDormantObject();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_GameObject_linkedPrefab_set(void * jarg1, void * jarg2) {
  GameObject *arg1 = (GameObject *) 0 ;
  Prefab *arg2 = (Prefab *) 0 ;
  
  arg1 = (GameObject *)jarg1; 
  arg2 = (Prefab *)jarg2; 
  if (arg1) (arg1)->linkedPrefab = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_GameObject_linkedPrefab_get(void * jarg1) {
  void * jresult ;
  GameObject *arg1 = (GameObject *) 0 ;
  Prefab *result = 0 ;
  
  arg1 = (GameObject *)jarg1; 
  result = (Prefab *) ((arg1)->linkedPrefab);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_GameObject_RevertToPrefab(void * jarg1) {
  void * jresult ;
  GameObject *arg1 = (GameObject *) 0 ;
  GameObject *result = 0 ;
  
  arg1 = (GameObject *)jarg1; 
  result = (GameObject *)(arg1)->RevertToPrefab();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_GameObject_WriteToPrefab(void * jarg1) {
  GameObject *arg1 = (GameObject *) 0 ;
  
  arg1 = (GameObject *)jarg1; 
  (arg1)->WriteToPrefab();
}


SWIGEXPORT void SWIGSTDCALL CSharp_GameObject_DetachFromPrefab(void * jarg1) {
  GameObject *arg1 = (GameObject *) 0 ;
  
  arg1 = (GameObject *)jarg1; 
  (arg1)->DetachFromPrefab();
}


SWIGEXPORT void * SWIGSTDCALL CSharp_GameObject_GetGameObjectByName__SWIG_0(char * jarg1, unsigned int jarg2) {
  void * jresult ;
  std::string arg1 ;
  bool arg2 ;
  GameObject *result = 0 ;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  (&arg1)->assign(jarg1); 
  arg2 = jarg2 ? true : false; 
  result = (GameObject *)GameObject::GetGameObjectByName(arg1,arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_GameObject_GetGameObjectByName__SWIG_1(char * jarg1) {
  void * jresult ;
  std::string arg1 ;
  GameObject *result = 0 ;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  (&arg1)->assign(jarg1); 
  result = (GameObject *)GameObject::GetGameObjectByName(arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_GameObject_GetGameObjectsWithTag(char * jarg1) {
  void * jresult ;
  std::string arg1 ;
  std::vector< GameObject * > result;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  (&arg1)->assign(jarg1); 
  result = GameObject::GetGameObjectsWithTag(arg1);
  jresult = new std::vector< GameObject * >((const std::vector< GameObject * > &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_GameObject_GetGameObjectWithTag(char * jarg1) {
  void * jresult ;
  std::string arg1 ;
  GameObject *result = 0 ;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  (&arg1)->assign(jarg1); 
  result = (GameObject *)GameObject::GetGameObjectWithTag(arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_SetGameObjectPtr__SWIG_0() {
  void * jresult ;
  std::set< GameObject * > *result = 0 ;
  
  result = (std::set< GameObject * > *)new std::set< GameObject * >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_SetGameObjectPtr__SWIG_1(void * jarg1) {
  void * jresult ;
  std::set< GameObject * > *arg1 = 0 ;
  std::set< GameObject * > *result = 0 ;
  
  arg1 = (std::set< GameObject * > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::set< GameObject * > const & type is null", 0);
    return 0;
  } 
  result = (std::set< GameObject * > *)new std::set< GameObject * >((std::set< GameObject * > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_SetGameObjectPtr_size(void * jarg1) {
  unsigned long jresult ;
  std::set< GameObject * > *arg1 = (std::set< GameObject * > *) 0 ;
  std::set< GameObject * >::size_type result;
  
  arg1 = (std::set< GameObject * > *)jarg1; 
  result = ((std::set< GameObject * > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_SetGameObjectPtr_empty(void * jarg1) {
  unsigned int jresult ;
  std::set< GameObject * > *arg1 = (std::set< GameObject * > *) 0 ;
  bool result;
  
  arg1 = (std::set< GameObject * > *)jarg1; 
  result = (bool)((std::set< GameObject * > const *)arg1)->empty();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_SetGameObjectPtr_Clear(void * jarg1) {
  std::set< GameObject * > *arg1 = (std::set< GameObject * > *) 0 ;
  
  arg1 = (std::set< GameObject * > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void * SWIGSTDCALL CSharp_SetGameObjectPtr_getitem(void * jarg1, void * jarg2) {
  void * jresult ;
  std::set< GameObject * > *arg1 = (std::set< GameObject * > *) 0 ;
  std::set< GameObject * >::value_type *arg2 = 0 ;
  std::set< GameObject * >::value_type temp2 = 0 ;
  std::set< GameObject * >::value_type *result = 0 ;
  
  arg1 = (std::set< GameObject * > *)jarg1; 
  temp2 = (std::set< GameObject * >::value_type)jarg2;
  arg2 = (std::set< GameObject * >::value_type *)&temp2; 
  try {
    result = (std::set< GameObject * >::value_type *) &std_set_Sl_GameObject_Sm__Sg__getitem(arg1,(GameObject *const &)*arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)*result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_SetGameObjectPtr_setitem(void * jarg1, void * jarg2) {
  std::set< GameObject * > *arg1 = (std::set< GameObject * > *) 0 ;
  std::set< GameObject * >::value_type *arg2 = 0 ;
  std::set< GameObject * >::value_type temp2 = 0 ;
  
  arg1 = (std::set< GameObject * > *)jarg1; 
  temp2 = (std::set< GameObject * >::value_type)jarg2;
  arg2 = (std::set< GameObject * >::value_type *)&temp2; 
  std_set_Sl_GameObject_Sm__Sg__setitem(arg1,(GameObject *const &)*arg2);
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_SetGameObjectPtr_Contains(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::set< GameObject * > *arg1 = (std::set< GameObject * > *) 0 ;
  std::set< GameObject * >::value_type *arg2 = 0 ;
  std::set< GameObject * >::value_type temp2 = 0 ;
  bool result;
  
  arg1 = (std::set< GameObject * > *)jarg1; 
  temp2 = (std::set< GameObject * >::value_type)jarg2;
  arg2 = (std::set< GameObject * >::value_type *)&temp2; 
  result = (bool)std_set_Sl_GameObject_Sm__Sg__Contains(arg1,(GameObject *const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_SetGameObjectPtr_Add(void * jarg1, void * jarg2) {
  std::set< GameObject * > *arg1 = (std::set< GameObject * > *) 0 ;
  std::set< GameObject * >::value_type *arg2 = 0 ;
  std::set< GameObject * >::value_type temp2 = 0 ;
  
  arg1 = (std::set< GameObject * > *)jarg1; 
  temp2 = (std::set< GameObject * >::value_type)jarg2;
  arg2 = (std::set< GameObject * >::value_type *)&temp2; 
  try {
    std_set_Sl_GameObject_Sm__Sg__Add(arg1,(GameObject *const &)*arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_SetGameObjectPtr_Remove(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::set< GameObject * > *arg1 = (std::set< GameObject * > *) 0 ;
  std::set< GameObject * >::value_type *arg2 = 0 ;
  std::set< GameObject * >::value_type temp2 = 0 ;
  bool result;
  
  arg1 = (std::set< GameObject * > *)jarg1; 
  temp2 = (std::set< GameObject * >::value_type)jarg2;
  arg2 = (std::set< GameObject * >::value_type *)&temp2; 
  result = (bool)std_set_Sl_GameObject_Sm__Sg__Remove(arg1,(GameObject *const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_SetGameObjectPtr_create_iterator_begin(void * jarg1) {
  void * jresult ;
  std::set< GameObject * > *arg1 = (std::set< GameObject * > *) 0 ;
  std::set< GameObject * >::iterator *result = 0 ;
  
  arg1 = (std::set< GameObject * > *)jarg1; 
  result = (std::set< GameObject * >::iterator *)std_set_Sl_GameObject_Sm__Sg__create_iterator_begin(arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_SetGameObjectPtr_is_iterator_good(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::set< GameObject * > *arg1 = (std::set< GameObject * > *) 0 ;
  std::set< GameObject * >::iterator *arg2 = (std::set< GameObject * >::iterator *) 0 ;
  bool result;
  
  arg1 = (std::set< GameObject * > *)jarg1; 
  arg2 = (std::set< GameObject * >::iterator *)jarg2; 
  result = (bool)std_set_Sl_GameObject_Sm__Sg__is_iterator_good(arg1,arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_SetGameObjectPtr_get_next_key(void * jarg1, void * jarg2) {
  void * jresult ;
  std::set< GameObject * > *arg1 = (std::set< GameObject * > *) 0 ;
  std::set< GameObject * >::iterator *arg2 = (std::set< GameObject * >::iterator *) 0 ;
  std::set< GameObject * >::value_type *result = 0 ;
  
  arg1 = (std::set< GameObject * > *)jarg1; 
  arg2 = (std::set< GameObject * >::iterator *)jarg2; 
  result = (std::set< GameObject * >::value_type *) &std_set_Sl_GameObject_Sm__Sg__get_next_key(arg1,arg2);
  jresult = (void *)*result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_SetGameObjectPtr_destroy_iterator(void * jarg1, void * jarg2) {
  std::set< GameObject * > *arg1 = (std::set< GameObject * > *) 0 ;
  std::set< GameObject * >::iterator *arg2 = (std::set< GameObject * >::iterator *) 0 ;
  
  arg1 = (std::set< GameObject * > *)jarg1; 
  arg2 = (std::set< GameObject * >::iterator *)jarg2; 
  std_set_Sl_GameObject_Sm__Sg__destroy_iterator(arg1,arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_SetGameObjectPtr(void * jarg1) {
  std::set< GameObject * > *arg1 = (std::set< GameObject * > *) 0 ;
  
  arg1 = (std::set< GameObject * > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_gameObjectSlotTable_GetAllocatedObjects(void * jarg1) {
  void * jresult ;
  ret::SlotTable< GameObject > *arg1 = (ret::SlotTable< GameObject > *) 0 ;
  std::set< GameObject * > *result = 0 ;
  
  arg1 = (ret::SlotTable< GameObject > *)jarg1; 
  result = (std::set< GameObject * > *)(arg1)->GetAllocatedObjects();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_gameObjectSlotTable_GetNumberOfObjects(void * jarg1) {
  unsigned int jresult ;
  ret::SlotTable< GameObject > *arg1 = (ret::SlotTable< GameObject > *) 0 ;
  unsigned int result;
  
  arg1 = (ret::SlotTable< GameObject > *)jarg1; 
  result = (unsigned int)(arg1)->GetNumberOfObjects();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Engine_StartFromConfig__SWIG_0(void * jarg1, unsigned int jarg2) {
  Engine *arg1 = (Engine *) 0 ;
  bool arg2 ;
  
  arg1 = (Engine *)jarg1; 
  arg2 = jarg2 ? true : false; 
  (arg1)->StartFromConfig(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_Engine_StartFromConfig__SWIG_1(void * jarg1) {
  Engine *arg1 = (Engine *) 0 ;
  
  arg1 = (Engine *)jarg1; 
  (arg1)->StartFromConfig();
}


SWIGEXPORT void SWIGSTDCALL CSharp_Engine_Start__SWIG_0(void * jarg1, unsigned int jarg2, unsigned int jarg3, unsigned int jarg4, unsigned int jarg5, unsigned int jarg6) {
  Engine *arg1 = (Engine *) 0 ;
  bool arg2 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  bool arg5 ;
  bool arg6 ;
  
  arg1 = (Engine *)jarg1; 
  arg2 = jarg2 ? true : false; 
  arg3 = (unsigned int)jarg3; 
  arg4 = (unsigned int)jarg4; 
  arg5 = jarg5 ? true : false; 
  arg6 = jarg6 ? true : false; 
  (arg1)->Start(arg2,arg3,arg4,arg5,arg6);
}


SWIGEXPORT void SWIGSTDCALL CSharp_Engine_Start__SWIG_1(void * jarg1, unsigned int jarg2, unsigned int jarg3, unsigned int jarg4, unsigned int jarg5) {
  Engine *arg1 = (Engine *) 0 ;
  bool arg2 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  bool arg5 ;
  
  arg1 = (Engine *)jarg1; 
  arg2 = jarg2 ? true : false; 
  arg3 = (unsigned int)jarg3; 
  arg4 = (unsigned int)jarg4; 
  arg5 = jarg5 ? true : false; 
  (arg1)->Start(arg2,arg3,arg4,arg5);
}


SWIGEXPORT void SWIGSTDCALL CSharp_Engine_Run(void * jarg1) {
  Engine *arg1 = (Engine *) 0 ;
  
  arg1 = (Engine *)jarg1; 
  (arg1)->Run();
}


SWIGEXPORT void SWIGSTDCALL CSharp_Engine_RegisterEditorMode(void * jarg1) {
  Engine *arg1 = (Engine *) 0 ;
  
  arg1 = (Engine *)jarg1; 
  (arg1)->RegisterEditorMode();
}


SWIGEXPORT void SWIGSTDCALL CSharp_Engine_LoadInitialLevel(void * jarg1) {
  Engine *arg1 = (Engine *) 0 ;
  
  arg1 = (Engine *)jarg1; 
  (arg1)->LoadInitialLevel();
}


SWIGEXPORT void SWIGSTDCALL CSharp_Engine_LockMainLoop(void * jarg1) {
  Engine *arg1 = (Engine *) 0 ;
  
  arg1 = (Engine *)jarg1; 
  (arg1)->LockMainLoop();
}


SWIGEXPORT void SWIGSTDCALL CSharp_Engine_UnlockMainLoop(void * jarg1) {
  Engine *arg1 = (Engine *) 0 ;
  
  arg1 = (Engine *)jarg1; 
  (arg1)->UnlockMainLoop();
}


SWIGEXPORT void SWIGSTDCALL CSharp_Engine_GetDesktopResolution(void * jarg1, void * jarg2, void * jarg3) {
  Engine *arg1 = (Engine *) 0 ;
  int *arg2 = 0 ;
  int *arg3 = 0 ;
  
  arg1 = (Engine *)jarg1; 
  arg2 = (int *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "int & type is null", 0);
    return ;
  } 
  arg3 = (int *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "int & type is null", 0);
    return ;
  } 
  (arg1)->GetDesktopResolution(*arg2,*arg3);
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_Engine_GetIsInited(void * jarg1) {
  unsigned int jresult ;
  Engine *arg1 = (Engine *) 0 ;
  bool result;
  
  arg1 = (Engine *)jarg1; 
  result = (bool)((Engine const *)arg1)->GetIsInited();
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_Engine_GetIsEditorMode(void * jarg1) {
  unsigned int jresult ;
  Engine *arg1 = (Engine *) 0 ;
  bool result;
  
  arg1 = (Engine *)jarg1; 
  result = (bool)((Engine const *)arg1)->GetIsEditorMode();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Engine_Exit(void * jarg1) {
  Engine *arg1 = (Engine *) 0 ;
  
  arg1 = (Engine *)jarg1; 
  (arg1)->Exit();
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Engine_GetGameWnd(void * jarg1) {
  void * jresult ;
  Engine *arg1 = (Engine *) 0 ;
  MochaWindow *result = 0 ;
  
  arg1 = (Engine *)jarg1; 
  result = (MochaWindow *)(arg1)->GetGameWnd();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Engine_GetVRWnd(void * jarg1) {
  void * jresult ;
  Engine *arg1 = (Engine *) 0 ;
  MochaWindow *result = 0 ;
  
  arg1 = (Engine *)jarg1; 
  result = (MochaWindow *)(arg1)->GetVRWnd();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Engine_GetFocusedWnd(void * jarg1) {
  void * jresult ;
  Engine *arg1 = (Engine *) 0 ;
  MochaWindow *result = 0 ;
  
  arg1 = (Engine *)jarg1; 
  result = (MochaWindow *)(arg1)->GetFocusedWnd();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Engine_RegisterSafeFrameToBarrista(void * jarg1) {
  Engine *arg1 = (Engine *) 0 ;
  
  arg1 = (Engine *)jarg1; 
  (arg1)->RegisterSafeFrameToBarrista();
}


SWIGEXPORT void SWIGSTDCALL CSharp_Engine_SignalSafeFrameContinue(void * jarg1) {
  Engine *arg1 = (Engine *) 0 ;
  
  arg1 = (Engine *)jarg1; 
  (arg1)->SignalSafeFrameContinue();
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_Engine_IsInSameFrame(void * jarg1) {
  unsigned int jresult ;
  Engine *arg1 = (Engine *) 0 ;
  bool result;
  
  arg1 = (Engine *)jarg1; 
  result = (bool)(arg1)->IsInSameFrame();
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_Engine_IsGameInFocus(void * jarg1) {
  unsigned int jresult ;
  Engine *arg1 = (Engine *) 0 ;
  bool result;
  
  arg1 = (Engine *)jarg1; 
  result = (bool)(arg1)->IsGameInFocus();
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_Engine_IsEditorWindowInFocus(void * jarg1) {
  unsigned int jresult ;
  Engine *arg1 = (Engine *) 0 ;
  bool result;
  
  arg1 = (Engine *)jarg1; 
  result = (bool)(arg1)->IsEditorWindowInFocus();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Engine_SetPauseMode(void * jarg1, unsigned int jarg2) {
  Engine *arg1 = (Engine *) 0 ;
  bool arg2 ;
  
  arg1 = (Engine *)jarg1; 
  arg2 = jarg2 ? true : false; 
  (arg1)->SetPauseMode(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Engine_getInstance() {
  void * jresult ;
  Engine *result = 0 ;
  
  result = (Engine *)Engine::getInstance();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Engine_mIsLetterBox_set(void * jarg1, unsigned int jarg2) {
  Engine *arg1 = (Engine *) 0 ;
  bool arg2 ;
  
  arg1 = (Engine *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->mIsLetterBox = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_Engine_mIsLetterBox_get(void * jarg1) {
  unsigned int jresult ;
  Engine *arg1 = (Engine *) 0 ;
  bool result;
  
  arg1 = (Engine *)jarg1; 
  result = (bool) ((arg1)->mIsLetterBox);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_MochaWindow_ChangeResolution(void * jarg1, unsigned int jarg2, unsigned int jarg3) {
  MochaWindow *arg1 = (MochaWindow *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  
  arg1 = (MochaWindow *)jarg1; 
  arg2 = (unsigned int)jarg2; 
  arg3 = (unsigned int)jarg3; 
  (arg1)->ChangeResolution(arg2,arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_MochaWindow_SetFullScreen(void * jarg1, unsigned int jarg2) {
  MochaWindow *arg1 = (MochaWindow *) 0 ;
  bool arg2 ;
  
  arg1 = (MochaWindow *)jarg1; 
  arg2 = jarg2 ? true : false; 
  (arg1)->SetFullScreen(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_MochaWindow_SetWindowTitle(void * jarg1, char * jarg2) {
  MochaWindow *arg1 = (MochaWindow *) 0 ;
  char *arg2 = (char *) 0 ;
  
  arg1 = (MochaWindow *)jarg1; 
  arg2 = (char *)jarg2; 
  (arg1)->SetWindowTitle((char const *)arg2);
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_MochaWindow_GetWindowWidth(void * jarg1) {
  unsigned int jresult ;
  MochaWindow *arg1 = (MochaWindow *) 0 ;
  unsigned int result;
  
  arg1 = (MochaWindow *)jarg1; 
  result = (unsigned int)((MochaWindow const *)arg1)->GetWindowWidth();
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_MochaWindow_GetSavedResolutionHeight(void * jarg1) {
  unsigned int jresult ;
  MochaWindow *arg1 = (MochaWindow *) 0 ;
  unsigned int result;
  
  arg1 = (MochaWindow *)jarg1; 
  result = (unsigned int)((MochaWindow const *)arg1)->GetSavedResolutionHeight();
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_MochaWindow_GetSavedResolutionWidth(void * jarg1) {
  unsigned int jresult ;
  MochaWindow *arg1 = (MochaWindow *) 0 ;
  unsigned int result;
  
  arg1 = (MochaWindow *)jarg1; 
  result = (unsigned int)((MochaWindow const *)arg1)->GetSavedResolutionWidth();
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_MochaWindow_GetWindowHeight(void * jarg1) {
  unsigned int jresult ;
  MochaWindow *arg1 = (MochaWindow *) 0 ;
  unsigned int result;
  
  arg1 = (MochaWindow *)jarg1; 
  result = (unsigned int)((MochaWindow const *)arg1)->GetWindowHeight();
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_MochaWindow_GetViewportWidth(void * jarg1) {
  unsigned int jresult ;
  MochaWindow *arg1 = (MochaWindow *) 0 ;
  unsigned int result;
  
  arg1 = (MochaWindow *)jarg1; 
  result = (unsigned int)((MochaWindow const *)arg1)->GetViewportWidth();
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_MochaWindow_GetViewportHeight(void * jarg1) {
  unsigned int jresult ;
  MochaWindow *arg1 = (MochaWindow *) 0 ;
  unsigned int result;
  
  arg1 = (MochaWindow *)jarg1; 
  result = (unsigned int)((MochaWindow const *)arg1)->GetViewportHeight();
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_MochaWindow_IsFullScreen(void * jarg1) {
  unsigned int jresult ;
  MochaWindow *arg1 = (MochaWindow *) 0 ;
  bool result;
  
  arg1 = (MochaWindow *)jarg1; 
  result = (bool)(arg1)->IsFullScreen();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_MochaWindow_AspectRatio(void * jarg1) {
  float jresult ;
  MochaWindow *arg1 = (MochaWindow *) 0 ;
  float result;
  
  arg1 = (MochaWindow *)jarg1; 
  result = (float)((MochaWindow const *)arg1)->AspectRatio();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_MochaWindow_FixedAspectRatio__SWIG_0(void * jarg1) {
  float jresult ;
  MochaWindow *arg1 = (MochaWindow *) 0 ;
  float result;
  
  arg1 = (MochaWindow *)jarg1; 
  result = (float)((MochaWindow const *)arg1)->FixedAspectRatio();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_MochaWindow_FixedAspectRatio__SWIG_1(void * jarg1, float jarg2) {
  MochaWindow *arg1 = (MochaWindow *) 0 ;
  float *arg2 = 0 ;
  float temp2 ;
  
  arg1 = (MochaWindow *)jarg1; 
  temp2 = (float)jarg2; 
  arg2 = &temp2; 
  (arg1)->FixedAspectRatio((float const &)*arg2);
}


SWIGEXPORT float SWIGSTDCALL CSharp_MochaWindow_GetScreenOffsetX(void * jarg1) {
  float jresult ;
  MochaWindow *arg1 = (MochaWindow *) 0 ;
  float result;
  
  arg1 = (MochaWindow *)jarg1; 
  result = (float)((MochaWindow const *)arg1)->GetScreenOffsetX();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_MochaWindow_GetScreenOffsetY(void * jarg1) {
  float jresult ;
  MochaWindow *arg1 = (MochaWindow *) 0 ;
  float result;
  
  arg1 = (MochaWindow *)jarg1; 
  result = (float)((MochaWindow const *)arg1)->GetScreenOffsetY();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_MochaWindow_Letterboxing(void * jarg1, unsigned int jarg2, unsigned int jarg3) {
  MochaWindow *arg1 = (MochaWindow *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  
  arg1 = (MochaWindow *)jarg1; 
  arg2 = (unsigned int)jarg2; 
  arg3 = (unsigned int)jarg3; 
  (arg1)->Letterboxing(arg2,arg3);
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_MochaWindow_GetFocus(void * jarg1) {
  unsigned int jresult ;
  MochaWindow *arg1 = (MochaWindow *) 0 ;
  bool result;
  
  arg1 = (MochaWindow *)jarg1; 
  result = (bool)((MochaWindow const *)arg1)->GetFocus();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MochaWindow_GetHWND(void * jarg1) {
  void * jresult ;
  MochaWindow *arg1 = (MochaWindow *) 0 ;
  HWND *result = 0 ;
  
  arg1 = (MochaWindow *)jarg1; 
  result = (HWND *) &(arg1)->GetHWND();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_MochaWindow_GetHwndAsInt(void * jarg1) {
  unsigned int jresult ;
  MochaWindow *arg1 = (MochaWindow *) 0 ;
  unsigned int result;
  
  arg1 = (MochaWindow *)jarg1; 
  result = (unsigned int)(arg1)->GetHwndAsInt();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_MochaWindow() {
  void * jresult ;
  MochaWindow *result = 0 ;
  
  result = (MochaWindow *)new MochaWindow();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_MochaWindow(void * jarg1) {
  MochaWindow *arg1 = (MochaWindow *) 0 ;
  
  arg1 = (MochaWindow *)jarg1; 
  delete arg1;
}


SWIGEXPORT char * SWIGSTDCALL CSharp_Asset_GetName(void * jarg1) {
  char * jresult ;
  Asset *arg1 = (Asset *) 0 ;
  std::string result;
  
  arg1 = (Asset *)jarg1; 
  result = (arg1)->GetName();
  jresult = SWIG_csharp_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT char * SWIGSTDCALL CSharp_Asset_GetAssetType(void * jarg1) {
  char * jresult ;
  Asset *arg1 = (Asset *) 0 ;
  std::string result;
  
  arg1 = (Asset *)jarg1; 
  result = ((Asset const *)arg1)->GetType();
  jresult = SWIG_csharp_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_Asset_GetUseCounter(void * jarg1) {
  unsigned int jresult ;
  Asset *arg1 = (Asset *) 0 ;
  unsigned int result;
  
  arg1 = (Asset *)jarg1; 
  result = (unsigned int)(arg1)->GetUseCounter();
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_Asset_GetId(void * jarg1) {
  unsigned int jresult ;
  Asset *arg1 = (Asset *) 0 ;
  unsigned int result;
  
  arg1 = (Asset *)jarg1; 
  result = (unsigned int)((Asset const *)arg1)->GetId();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_AssetHandle__SWIG_0(void * jarg1) {
  void * jresult ;
  Asset *arg1 = (Asset *) 0 ;
  AssetHandle *result = 0 ;
  
  arg1 = (Asset *)jarg1; 
  result = (AssetHandle *)new AssetHandle(arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_AssetHandle__SWIG_1(void * jarg1) {
  void * jresult ;
  AssetHandle *arg1 = 0 ;
  AssetHandle *result = 0 ;
  
  arg1 = (AssetHandle *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "AssetHandle const & type is null", 0);
    return 0;
  } 
  result = (AssetHandle *)new AssetHandle((AssetHandle const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_AssetHandle__SWIG_2() {
  void * jresult ;
  AssetHandle *result = 0 ;
  
  result = (AssetHandle *)new AssetHandle();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_AssetHandle_Valid(void * jarg1) {
  unsigned int jresult ;
  AssetHandle *arg1 = (AssetHandle *) 0 ;
  bool result;
  
  arg1 = (AssetHandle *)jarg1; 
  result = (bool)(arg1)->Valid();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_AssetHandle_ResetHandle(void * jarg1) {
  AssetHandle *arg1 = (AssetHandle *) 0 ;
  
  arg1 = (AssetHandle *)jarg1; 
  (arg1)->ResetHandle();
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_AssetHandle_GetId(void * jarg1) {
  unsigned int jresult ;
  AssetHandle *arg1 = (AssetHandle *) 0 ;
  unsigned int result;
  
  arg1 = (AssetHandle *)jarg1; 
  result = (unsigned int)((AssetHandle const *)arg1)->GetId();
  jresult = result; 
  return jresult;
}


SWIGEXPORT char * SWIGSTDCALL CSharp_AssetHandle_GetName(void * jarg1) {
  char * jresult ;
  AssetHandle *arg1 = (AssetHandle *) 0 ;
  std::string result;
  
  arg1 = (AssetHandle *)jarg1; 
  result = ((AssetHandle const *)arg1)->GetName();
  jresult = SWIG_csharp_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_AssetHandle_GetRawAssetPtr(void * jarg1) {
  void * jresult ;
  AssetHandle *arg1 = (AssetHandle *) 0 ;
  Asset *result = 0 ;
  
  arg1 = (AssetHandle *)jarg1; 
  result = (Asset *)((AssetHandle const *)arg1)->GetRawAssetPtr();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT char * SWIGSTDCALL CSharp_AssetHandle_GetUnderlyingAssetType(void * jarg1) {
  char * jresult ;
  AssetHandle *arg1 = (AssetHandle *) 0 ;
  std::string result;
  
  arg1 = (AssetHandle *)jarg1; 
  result = ((AssetHandle const *)arg1)->GetUnderlyingAssetType();
  jresult = SWIG_csharp_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_AssetHandle(void * jarg1) {
  AssetHandle *arg1 = (AssetHandle *) 0 ;
  
  arg1 = (AssetHandle *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_AssetManager_CheckForChangedAssets(void * jarg1) {
  AssetManager *arg1 = (AssetManager *) 0 ;
  
  arg1 = (AssetManager *)jarg1; 
  (arg1)->CheckForChangedAssets();
}


SWIGEXPORT void SWIGSTDCALL CSharp_AssetManager_PrintLoadedAssets(void * jarg1) {
  AssetManager *arg1 = (AssetManager *) 0 ;
  
  arg1 = (AssetManager *)jarg1; 
  (arg1)->PrintLoadedAssets();
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_AssetManager_NumOfAssets(void * jarg1) {
  unsigned int jresult ;
  AssetManager *arg1 = (AssetManager *) 0 ;
  unsigned int result;
  
  arg1 = (AssetManager *)jarg1; 
  result = (unsigned int)((AssetManager const *)arg1)->NumOfAssets();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_AssetManager_GetAsset__SWIG_0(void * jarg1, unsigned int jarg2) {
  void * jresult ;
  AssetManager *arg1 = (AssetManager *) 0 ;
  unsigned int arg2 ;
  AssetHandle result;
  
  arg1 = (AssetManager *)jarg1; 
  arg2 = (unsigned int)jarg2; 
  result = (arg1)->GetAsset(arg2);
  jresult = new AssetHandle((const AssetHandle &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_AssetManager_GetAsset__SWIG_1(void * jarg1, char * jarg2) {
  void * jresult ;
  AssetManager *arg1 = (AssetManager *) 0 ;
  std::string arg2 ;
  AssetHandle result;
  
  arg1 = (AssetManager *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  (&arg2)->assign(jarg2); 
  result = (arg1)->GetAsset(arg2);
  jresult = new AssetHandle((const AssetHandle &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_AssetManager_getInstance() {
  void * jresult ;
  AssetManager *result = 0 ;
  
  result = (AssetManager *)AssetManager::getInstance();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_VertexVector_Clear(void * jarg1) {
  std::vector< Vertex > *arg1 = (std::vector< Vertex > *) 0 ;
  
  arg1 = (std::vector< Vertex > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_VertexVector_Add(void * jarg1, void * jarg2) {
  std::vector< Vertex > *arg1 = (std::vector< Vertex > *) 0 ;
  Vertex *arg2 = 0 ;
  
  arg1 = (std::vector< Vertex > *)jarg1; 
  arg2 = (Vertex *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Vertex const & type is null", 0);
    return ;
  } 
  (arg1)->push_back((Vertex const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_VertexVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< Vertex > *arg1 = (std::vector< Vertex > *) 0 ;
  std::vector< Vertex >::size_type result;
  
  arg1 = (std::vector< Vertex > *)jarg1; 
  result = ((std::vector< Vertex > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_VertexVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< Vertex > *arg1 = (std::vector< Vertex > *) 0 ;
  std::vector< Vertex >::size_type result;
  
  arg1 = (std::vector< Vertex > *)jarg1; 
  result = ((std::vector< Vertex > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_VertexVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< Vertex > *arg1 = (std::vector< Vertex > *) 0 ;
  std::vector< Vertex >::size_type arg2 ;
  
  arg1 = (std::vector< Vertex > *)jarg1; 
  arg2 = (std::vector< Vertex >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_VertexVector__SWIG_0() {
  void * jresult ;
  std::vector< Vertex > *result = 0 ;
  
  result = (std::vector< Vertex > *)new std::vector< Vertex >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_VertexVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< Vertex > *arg1 = 0 ;
  std::vector< Vertex > *result = 0 ;
  
  arg1 = (std::vector< Vertex > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< Vertex > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< Vertex > *)new std::vector< Vertex >((std::vector< Vertex > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_VertexVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< Vertex > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< Vertex > *)new_std_vector_Sl_Vertex_Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_VertexVector_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< Vertex > *arg1 = (std::vector< Vertex > *) 0 ;
  int arg2 ;
  Vertex result;
  
  arg1 = (std::vector< Vertex > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_Vertex_Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = new Vertex((const Vertex &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_VertexVector_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< Vertex > *arg1 = (std::vector< Vertex > *) 0 ;
  int arg2 ;
  Vertex *result = 0 ;
  
  arg1 = (std::vector< Vertex > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (Vertex *) &std_vector_Sl_Vertex_Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_VertexVector_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< Vertex > *arg1 = (std::vector< Vertex > *) 0 ;
  int arg2 ;
  Vertex *arg3 = 0 ;
  
  arg1 = (std::vector< Vertex > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (Vertex *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Vertex const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_Vertex_Sg__setitem(arg1,arg2,(Vertex const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_VertexVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< Vertex > *arg1 = (std::vector< Vertex > *) 0 ;
  std::vector< Vertex > *arg2 = 0 ;
  
  arg1 = (std::vector< Vertex > *)jarg1; 
  arg2 = (std::vector< Vertex > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< Vertex > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_Vertex_Sg__AddRange(arg1,(std::vector< Vertex > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_VertexVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< Vertex > *arg1 = (std::vector< Vertex > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< Vertex > *result = 0 ;
  
  arg1 = (std::vector< Vertex > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< Vertex > *)std_vector_Sl_Vertex_Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_VertexVector_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< Vertex > *arg1 = (std::vector< Vertex > *) 0 ;
  int arg2 ;
  Vertex *arg3 = 0 ;
  
  arg1 = (std::vector< Vertex > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (Vertex *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Vertex const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_Vertex_Sg__Insert(arg1,arg2,(Vertex const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_VertexVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< Vertex > *arg1 = (std::vector< Vertex > *) 0 ;
  int arg2 ;
  std::vector< Vertex > *arg3 = 0 ;
  
  arg1 = (std::vector< Vertex > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< Vertex > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< Vertex > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_Vertex_Sg__InsertRange(arg1,arg2,(std::vector< Vertex > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_VertexVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< Vertex > *arg1 = (std::vector< Vertex > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< Vertex > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_Vertex_Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_VertexVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< Vertex > *arg1 = (std::vector< Vertex > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< Vertex > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_Vertex_Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_VertexVector_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  Vertex *arg1 = 0 ;
  int arg2 ;
  std::vector< Vertex > *result = 0 ;
  
  arg1 = (Vertex *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Vertex const & type is null", 0);
    return 0;
  } 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< Vertex > *)std_vector_Sl_Vertex_Sg__Repeat((Vertex const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_VertexVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< Vertex > *arg1 = (std::vector< Vertex > *) 0 ;
  
  arg1 = (std::vector< Vertex > *)jarg1; 
  std_vector_Sl_Vertex_Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_VertexVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< Vertex > *arg1 = (std::vector< Vertex > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< Vertex > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_Vertex_Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_VertexVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< Vertex > *arg1 = (std::vector< Vertex > *) 0 ;
  int arg2 ;
  std::vector< Vertex > *arg3 = 0 ;
  
  arg1 = (std::vector< Vertex > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< Vertex > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< Vertex > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_Vertex_Sg__SetRange(arg1,arg2,(std::vector< Vertex > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_VertexVector(void * jarg1) {
  std::vector< Vertex > *arg1 = (std::vector< Vertex > *) 0 ;
  
  arg1 = (std::vector< Vertex > *)jarg1; 
  delete arg1;
}


SWIGEXPORT char * SWIGSTDCALL CSharp_Mesh_GetMeshName(void * jarg1) {
  char * jresult ;
  Mesh *arg1 = (Mesh *) 0 ;
  std::string result;
  
  arg1 = (Mesh *)jarg1; 
  result = (arg1)->GetMeshName();
  jresult = SWIG_csharp_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Mesh_GetVertices(void * jarg1) {
  void * jresult ;
  Mesh *arg1 = (Mesh *) 0 ;
  std::vector< Vertex > *result = 0 ;
  
  arg1 = (Mesh *)jarg1; 
  result = (std::vector< Vertex > *) &(arg1)->GetVertices();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Mesh_GetIndices(void * jarg1) {
  void * jresult ;
  Mesh *arg1 = (Mesh *) 0 ;
  std::vector< int > *result = 0 ;
  
  arg1 = (Mesh *)jarg1; 
  result = (std::vector< int > *) &(arg1)->GetIndices();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Mesh_GetMeshType(void * jarg1) {
  void * jresult ;
  Mesh *arg1 = (Mesh *) 0 ;
  MeshType result;
  
  arg1 = (Mesh *)jarg1; 
  result = (arg1)->GetMeshType();
  jresult = new MeshType((const MeshType &)result); 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_Mesh_GetVertexCount(void * jarg1) {
  unsigned int jresult ;
  Mesh *arg1 = (Mesh *) 0 ;
  unsigned int result;
  
  arg1 = (Mesh *)jarg1; 
  result = (unsigned int)(arg1)->GetVertexCount();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Mesh_GetAABB(void * jarg1) {
  void * jresult ;
  Mesh *arg1 = (Mesh *) 0 ;
  AABB result;
  
  arg1 = (Mesh *)jarg1; 
  result = (arg1)->GetAABB();
  jresult = new AABB((const AABB &)result); 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_BaseState_NumOfManagedObjects(void * jarg1) {
  unsigned int jresult ;
  BaseState *arg1 = (BaseState *) 0 ;
  unsigned int result;
  
  arg1 = (BaseState *)jarg1; 
  result = (unsigned int)((BaseState const *)arg1)->NumOfManagedObjects();
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_BaseState_NumOfUnManagedObjects(void * jarg1) {
  unsigned int jresult ;
  BaseState *arg1 = (BaseState *) 0 ;
  unsigned int result;
  
  arg1 = (BaseState *)jarg1; 
  result = (unsigned int)((BaseState const *)arg1)->NumOfUnManagedObjects();
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_BaseState_IsActive__SWIG_0(void * jarg1) {
  unsigned int jresult ;
  BaseState *arg1 = (BaseState *) 0 ;
  bool result;
  
  arg1 = (BaseState *)jarg1; 
  result = (bool)((BaseState const *)arg1)->IsActive();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_BaseState_IsActive__SWIG_1(void * jarg1, unsigned int jarg2) {
  BaseState *arg1 = (BaseState *) 0 ;
  bool arg2 ;
  
  arg1 = (BaseState *)jarg1; 
  arg2 = jarg2 ? true : false; 
  (arg1)->IsActive(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_BaseState_GetManagedObjectsSlotTable(void * jarg1) {
  void * jresult ;
  BaseState *arg1 = (BaseState *) 0 ;
  ret::SlotTable< GameObject > *result = 0 ;
  
  arg1 = (BaseState *)jarg1; 
  result = (ret::SlotTable< GameObject > *) &(arg1)->GetManagedObjectsSlotTable();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_GameObjectIterator_Next(void * jarg1) {
  void * jresult ;
  GameObjectIterator *arg1 = (GameObjectIterator *) 0 ;
  GameObject *result = 0 ;
  
  arg1 = (GameObjectIterator *)jarg1; 
  result = (GameObject *)(arg1)->Next();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_GameObjectIterator(void * jarg1) {
  void * jresult ;
  BaseState *arg1 = (BaseState *) 0 ;
  GameObjectIterator *result = 0 ;
  
  arg1 = (BaseState *)jarg1; 
  result = (GameObjectIterator *)new GameObjectIterator(arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_GameObjectIterator(void * jarg1) {
  GameObjectIterator *arg1 = (GameObjectIterator *) 0 ;
  
  arg1 = (GameObjectIterator *)jarg1; 
  delete arg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_ObjectFactory_MakeNewGameObject__SWIG_0(void * jarg1, char * jarg2, void * jarg3, unsigned int jarg4) {
  void * jresult ;
  ObjectFactory *arg1 = (ObjectFactory *) 0 ;
  std::string *arg2 = 0 ;
  BaseState *arg3 = (BaseState *) 0 ;
  bool arg4 ;
  GameObject *result = 0 ;
  
  arg1 = (ObjectFactory *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  arg3 = (BaseState *)jarg3; 
  arg4 = jarg4 ? true : false; 
  result = (GameObject *)(arg1)->MakeNewGameObject((std::string const &)*arg2,arg3,arg4);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_ObjectFactory_MakeNewGameObject__SWIG_1(void * jarg1, char * jarg2, void * jarg3) {
  void * jresult ;
  ObjectFactory *arg1 = (ObjectFactory *) 0 ;
  std::string *arg2 = 0 ;
  BaseState *arg3 = (BaseState *) 0 ;
  GameObject *result = 0 ;
  
  arg1 = (ObjectFactory *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  arg3 = (BaseState *)jarg3; 
  result = (GameObject *)(arg1)->MakeNewGameObject((std::string const &)*arg2,arg3);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_ObjectFactory_MakeNewGameObject__SWIG_2(void * jarg1, char * jarg2) {
  void * jresult ;
  ObjectFactory *arg1 = (ObjectFactory *) 0 ;
  std::string *arg2 = 0 ;
  GameObject *result = 0 ;
  
  arg1 = (ObjectFactory *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  result = (GameObject *)(arg1)->MakeNewGameObject((std::string const &)*arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_ObjectFactory_MakeNewGameObject__SWIG_3(void * jarg1, void * jarg2, unsigned int jarg3, void * jarg4) {
  void * jresult ;
  ObjectFactory *arg1 = (ObjectFactory *) 0 ;
  GameObject *arg2 = (GameObject *) 0 ;
  bool arg3 ;
  BaseState *arg4 = (BaseState *) 0 ;
  GameObject *result = 0 ;
  
  arg1 = (ObjectFactory *)jarg1; 
  arg2 = (GameObject *)jarg2; 
  arg3 = jarg3 ? true : false; 
  arg4 = (BaseState *)jarg4; 
  result = (GameObject *)(arg1)->MakeNewGameObject((GameObject const *)arg2,arg3,arg4);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_ObjectFactory_Instantiate(void * jarg1, char * jarg2) {
  void * jresult ;
  ObjectFactory *arg1 = (ObjectFactory *) 0 ;
  std::string arg2 ;
  GameObject *result = 0 ;
  
  arg1 = (ObjectFactory *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  (&arg2)->assign(jarg2); 
  result = (GameObject *)(arg1)->Instantiate(arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_ObjectFactory_getInstance() {
  void * jresult ;
  ObjectFactory *result = 0 ;
  
  result = (ObjectFactory *)ObjectFactory::getInstance();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_ObjectFactory() {
  void * jresult ;
  ObjectFactory *result = 0 ;
  
  result = (ObjectFactory *)new ObjectFactory();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_ObjectFactory(void * jarg1) {
  ObjectFactory *arg1 = (ObjectFactory *) 0 ;
  
  arg1 = (ObjectFactory *)jarg1; 
  delete arg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_GSM_getActiveState(void * jarg1) {
  void * jresult ;
  GSM *arg1 = (GSM *) 0 ;
  BaseState *result = 0 ;
  
  arg1 = (GSM *)jarg1; 
  result = (BaseState *)(arg1)->getActiveState();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_GSM_GetNumberOfStates(void * jarg1) {
  unsigned int jresult ;
  GSM *arg1 = (GSM *) 0 ;
  unsigned int result;
  
  arg1 = (GSM *)jarg1; 
  result = (unsigned int)(arg1)->GetNumberOfStates();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_GSM_getStateUnderActive(void * jarg1) {
  void * jresult ;
  GSM *arg1 = (GSM *) 0 ;
  BaseState *result = 0 ;
  
  arg1 = (GSM *)jarg1; 
  result = (BaseState *)(arg1)->getStateUnderActive();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_GSM_getStateAtIndex(void * jarg1, unsigned int jarg2) {
  void * jresult ;
  GSM *arg1 = (GSM *) 0 ;
  unsigned int arg2 ;
  BaseState *result = 0 ;
  
  arg1 = (GSM *)jarg1; 
  arg2 = (unsigned int)jarg2; 
  result = (BaseState *)(arg1)->getStateAtIndex(arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_GSM_PushStateToBottom__SWIG_0(void * jarg1, void * jarg2, unsigned int jarg3) {
  GSM *arg1 = (GSM *) 0 ;
  BaseState *arg2 = (BaseState *) 0 ;
  bool arg3 ;
  
  arg1 = (GSM *)jarg1; 
  arg2 = (BaseState *)jarg2; 
  arg3 = jarg3 ? true : false; 
  (arg1)->PushStateToBottom(arg2,arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_GSM_PushStateToBottom__SWIG_1(void * jarg1, void * jarg2) {
  GSM *arg1 = (GSM *) 0 ;
  BaseState *arg2 = (BaseState *) 0 ;
  
  arg1 = (GSM *)jarg1; 
  arg2 = (BaseState *)jarg2; 
  (arg1)->PushStateToBottom(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_GSM_PushState__SWIG_0(void * jarg1, void * jarg2, unsigned int jarg3) {
  GSM *arg1 = (GSM *) 0 ;
  BaseState *arg2 = (BaseState *) 0 ;
  bool arg3 ;
  
  arg1 = (GSM *)jarg1; 
  arg2 = (BaseState *)jarg2; 
  arg3 = jarg3 ? true : false; 
  (arg1)->PushState(arg2,arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_GSM_PushState__SWIG_1(void * jarg1, void * jarg2) {
  GSM *arg1 = (GSM *) 0 ;
  BaseState *arg2 = (BaseState *) 0 ;
  
  arg1 = (GSM *)jarg1; 
  arg2 = (BaseState *)jarg2; 
  (arg1)->PushState(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_GSM_PopState(void * jarg1) {
  GSM *arg1 = (GSM *) 0 ;
  
  arg1 = (GSM *)jarg1; 
  (arg1)->PopState();
}


SWIGEXPORT void SWIGSTDCALL CSharp_GSM_RemoveState(void * jarg1, void * jarg2) {
  GSM *arg1 = (GSM *) 0 ;
  BaseState *arg2 = (BaseState *) 0 ;
  
  arg1 = (GSM *)jarg1; 
  arg2 = (BaseState *)jarg2; 
  (arg1)->RemoveState(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_GSM_Freeze(void * jarg1) {
  GSM *arg1 = (GSM *) 0 ;
  
  arg1 = (GSM *)jarg1; 
  (arg1)->Freeze();
}


SWIGEXPORT void SWIGSTDCALL CSharp_GSM_UnFreeze(void * jarg1) {
  GSM *arg1 = (GSM *) 0 ;
  
  arg1 = (GSM *)jarg1; 
  (arg1)->UnFreeze();
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_GSM_IsFrozen(void * jarg1) {
  unsigned int jresult ;
  GSM *arg1 = (GSM *) 0 ;
  bool result;
  
  arg1 = (GSM *)jarg1; 
  result = (bool)(arg1)->IsFrozen();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_GSM_getInstance() {
  void * jresult ;
  GSM *result = 0 ;
  
  result = (GSM *)GSM::getInstance();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_BoolVector_Clear(void * jarg1) {
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  
  arg1 = (std::vector< bool > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_BoolVector_Add(void * jarg1, unsigned int jarg2) {
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  bool *arg2 = 0 ;
  bool temp2 ;
  
  arg1 = (std::vector< bool > *)jarg1; 
  temp2 = jarg2 ? true : false; 
  arg2 = &temp2; 
  (arg1)->push_back((bool const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_BoolVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  std::vector< bool >::size_type result;
  
  arg1 = (std::vector< bool > *)jarg1; 
  result = ((std::vector< bool > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_BoolVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  std::vector< bool >::size_type result;
  
  arg1 = (std::vector< bool > *)jarg1; 
  result = ((std::vector< bool > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_BoolVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  std::vector< bool >::size_type arg2 ;
  
  arg1 = (std::vector< bool > *)jarg1; 
  arg2 = (std::vector< bool >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_BoolVector__SWIG_0() {
  void * jresult ;
  std::vector< bool > *result = 0 ;
  
  result = (std::vector< bool > *)new std::vector< bool >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_BoolVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< bool > *arg1 = 0 ;
  std::vector< bool > *result = 0 ;
  
  arg1 = (std::vector< bool > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< bool > *)new std::vector< bool >((std::vector< bool > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_BoolVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< bool > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< bool > *)new_std_vector_Sl_bool_Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_BoolVector_getitemcopy(void * jarg1, int jarg2) {
  unsigned int jresult ;
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  int arg2 ;
  bool result;
  
  arg1 = (std::vector< bool > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (bool)std_vector_Sl_bool_Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_BoolVector_getitem(void * jarg1, int jarg2) {
  unsigned int jresult ;
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  int arg2 ;
  bool result;
  
  arg1 = (std::vector< bool > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (bool)std_vector_Sl_bool_Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_BoolVector_setitem(void * jarg1, int jarg2, unsigned int jarg3) {
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  int arg2 ;
  bool *arg3 = 0 ;
  bool temp3 ;
  
  arg1 = (std::vector< bool > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = jarg3 ? true : false; 
  arg3 = &temp3; 
  try {
    std_vector_Sl_bool_Sg__setitem(arg1,arg2,(bool const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_BoolVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  std::vector< bool > *arg2 = 0 ;
  
  arg1 = (std::vector< bool > *)jarg1; 
  arg2 = (std::vector< bool > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_bool_Sg__AddRange(arg1,(std::vector< bool > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_BoolVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< bool > *result = 0 ;
  
  arg1 = (std::vector< bool > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< bool > *)std_vector_Sl_bool_Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_BoolVector_Insert(void * jarg1, int jarg2, unsigned int jarg3) {
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  int arg2 ;
  bool *arg3 = 0 ;
  bool temp3 ;
  
  arg1 = (std::vector< bool > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = jarg3 ? true : false; 
  arg3 = &temp3; 
  try {
    std_vector_Sl_bool_Sg__Insert(arg1,arg2,(bool const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_BoolVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  int arg2 ;
  std::vector< bool > *arg3 = 0 ;
  
  arg1 = (std::vector< bool > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< bool > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_bool_Sg__InsertRange(arg1,arg2,(std::vector< bool > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_BoolVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< bool > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_bool_Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_BoolVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< bool > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_bool_Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_BoolVector_Repeat(unsigned int jarg1, int jarg2) {
  void * jresult ;
  bool *arg1 = 0 ;
  int arg2 ;
  bool temp1 ;
  std::vector< bool > *result = 0 ;
  
  temp1 = jarg1 ? true : false; 
  arg1 = &temp1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< bool > *)std_vector_Sl_bool_Sg__Repeat((bool const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_BoolVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  
  arg1 = (std::vector< bool > *)jarg1; 
  std_vector_Sl_bool_Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_BoolVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< bool > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_bool_Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_BoolVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  int arg2 ;
  std::vector< bool > *arg3 = 0 ;
  
  arg1 = (std::vector< bool > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< bool > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_bool_Sg__SetRange(arg1,arg2,(std::vector< bool > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_BoolVector_Contains(void * jarg1, unsigned int jarg2) {
  unsigned int jresult ;
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  bool *arg2 = 0 ;
  bool temp2 ;
  bool result;
  
  arg1 = (std::vector< bool > *)jarg1; 
  temp2 = jarg2 ? true : false; 
  arg2 = &temp2; 
  result = (bool)std_vector_Sl_bool_Sg__Contains(arg1,(bool const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_BoolVector_IndexOf(void * jarg1, unsigned int jarg2) {
  int jresult ;
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  bool *arg2 = 0 ;
  bool temp2 ;
  int result;
  
  arg1 = (std::vector< bool > *)jarg1; 
  temp2 = jarg2 ? true : false; 
  arg2 = &temp2; 
  result = (int)std_vector_Sl_bool_Sg__IndexOf(arg1,(bool const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_BoolVector_LastIndexOf(void * jarg1, unsigned int jarg2) {
  int jresult ;
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  bool *arg2 = 0 ;
  bool temp2 ;
  int result;
  
  arg1 = (std::vector< bool > *)jarg1; 
  temp2 = jarg2 ? true : false; 
  arg2 = &temp2; 
  result = (int)std_vector_Sl_bool_Sg__LastIndexOf(arg1,(bool const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_BoolVector_Remove(void * jarg1, unsigned int jarg2) {
  unsigned int jresult ;
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  bool *arg2 = 0 ;
  bool temp2 ;
  bool result;
  
  arg1 = (std::vector< bool > *)jarg1; 
  temp2 = jarg2 ? true : false; 
  arg2 = &temp2; 
  result = (bool)std_vector_Sl_bool_Sg__Remove(arg1,(bool const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_BoolVector(void * jarg1) {
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  
  arg1 = (std::vector< bool > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_StateObjDescVector_Clear(void * jarg1) {
  std::vector< StateObjDesc > *arg1 = (std::vector< StateObjDesc > *) 0 ;
  
  arg1 = (std::vector< StateObjDesc > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_StateObjDescVector_Add(void * jarg1, void * jarg2) {
  std::vector< StateObjDesc > *arg1 = (std::vector< StateObjDesc > *) 0 ;
  StateObjDesc *arg2 = 0 ;
  
  arg1 = (std::vector< StateObjDesc > *)jarg1; 
  arg2 = (StateObjDesc *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "StateObjDesc const & type is null", 0);
    return ;
  } 
  (arg1)->push_back((StateObjDesc const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_StateObjDescVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< StateObjDesc > *arg1 = (std::vector< StateObjDesc > *) 0 ;
  std::vector< StateObjDesc >::size_type result;
  
  arg1 = (std::vector< StateObjDesc > *)jarg1; 
  result = ((std::vector< StateObjDesc > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_StateObjDescVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< StateObjDesc > *arg1 = (std::vector< StateObjDesc > *) 0 ;
  std::vector< StateObjDesc >::size_type result;
  
  arg1 = (std::vector< StateObjDesc > *)jarg1; 
  result = ((std::vector< StateObjDesc > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_StateObjDescVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< StateObjDesc > *arg1 = (std::vector< StateObjDesc > *) 0 ;
  std::vector< StateObjDesc >::size_type arg2 ;
  
  arg1 = (std::vector< StateObjDesc > *)jarg1; 
  arg2 = (std::vector< StateObjDesc >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_StateObjDescVector__SWIG_0() {
  void * jresult ;
  std::vector< StateObjDesc > *result = 0 ;
  
  result = (std::vector< StateObjDesc > *)new std::vector< StateObjDesc >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_StateObjDescVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< StateObjDesc > *arg1 = 0 ;
  std::vector< StateObjDesc > *result = 0 ;
  
  arg1 = (std::vector< StateObjDesc > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< StateObjDesc > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< StateObjDesc > *)new std::vector< StateObjDesc >((std::vector< StateObjDesc > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_StateObjDescVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< StateObjDesc > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< StateObjDesc > *)new_std_vector_Sl_StateObjDesc_Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_StateObjDescVector_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< StateObjDesc > *arg1 = (std::vector< StateObjDesc > *) 0 ;
  int arg2 ;
  StateObjDesc result;
  
  arg1 = (std::vector< StateObjDesc > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_StateObjDesc_Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = new StateObjDesc((const StateObjDesc &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_StateObjDescVector_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< StateObjDesc > *arg1 = (std::vector< StateObjDesc > *) 0 ;
  int arg2 ;
  StateObjDesc *result = 0 ;
  
  arg1 = (std::vector< StateObjDesc > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (StateObjDesc *) &std_vector_Sl_StateObjDesc_Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_StateObjDescVector_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< StateObjDesc > *arg1 = (std::vector< StateObjDesc > *) 0 ;
  int arg2 ;
  StateObjDesc *arg3 = 0 ;
  
  arg1 = (std::vector< StateObjDesc > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (StateObjDesc *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "StateObjDesc const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_StateObjDesc_Sg__setitem(arg1,arg2,(StateObjDesc const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_StateObjDescVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< StateObjDesc > *arg1 = (std::vector< StateObjDesc > *) 0 ;
  std::vector< StateObjDesc > *arg2 = 0 ;
  
  arg1 = (std::vector< StateObjDesc > *)jarg1; 
  arg2 = (std::vector< StateObjDesc > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< StateObjDesc > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_StateObjDesc_Sg__AddRange(arg1,(std::vector< StateObjDesc > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_StateObjDescVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< StateObjDesc > *arg1 = (std::vector< StateObjDesc > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< StateObjDesc > *result = 0 ;
  
  arg1 = (std::vector< StateObjDesc > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< StateObjDesc > *)std_vector_Sl_StateObjDesc_Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_StateObjDescVector_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< StateObjDesc > *arg1 = (std::vector< StateObjDesc > *) 0 ;
  int arg2 ;
  StateObjDesc *arg3 = 0 ;
  
  arg1 = (std::vector< StateObjDesc > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (StateObjDesc *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "StateObjDesc const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_StateObjDesc_Sg__Insert(arg1,arg2,(StateObjDesc const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_StateObjDescVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< StateObjDesc > *arg1 = (std::vector< StateObjDesc > *) 0 ;
  int arg2 ;
  std::vector< StateObjDesc > *arg3 = 0 ;
  
  arg1 = (std::vector< StateObjDesc > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< StateObjDesc > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< StateObjDesc > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_StateObjDesc_Sg__InsertRange(arg1,arg2,(std::vector< StateObjDesc > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_StateObjDescVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< StateObjDesc > *arg1 = (std::vector< StateObjDesc > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< StateObjDesc > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_StateObjDesc_Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_StateObjDescVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< StateObjDesc > *arg1 = (std::vector< StateObjDesc > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< StateObjDesc > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_StateObjDesc_Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_StateObjDescVector_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  StateObjDesc *arg1 = 0 ;
  int arg2 ;
  std::vector< StateObjDesc > *result = 0 ;
  
  arg1 = (StateObjDesc *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "StateObjDesc const & type is null", 0);
    return 0;
  } 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< StateObjDesc > *)std_vector_Sl_StateObjDesc_Sg__Repeat((StateObjDesc const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_StateObjDescVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< StateObjDesc > *arg1 = (std::vector< StateObjDesc > *) 0 ;
  
  arg1 = (std::vector< StateObjDesc > *)jarg1; 
  std_vector_Sl_StateObjDesc_Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_StateObjDescVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< StateObjDesc > *arg1 = (std::vector< StateObjDesc > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< StateObjDesc > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_StateObjDesc_Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_StateObjDescVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< StateObjDesc > *arg1 = (std::vector< StateObjDesc > *) 0 ;
  int arg2 ;
  std::vector< StateObjDesc > *arg3 = 0 ;
  
  arg1 = (std::vector< StateObjDesc > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< StateObjDesc > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< StateObjDesc > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_StateObjDesc_Sg__SetRange(arg1,arg2,(std::vector< StateObjDesc > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_StateObjDescVector(void * jarg1) {
  std::vector< StateObjDesc > *arg1 = (std::vector< StateObjDesc > *) 0 ;
  
  arg1 = (std::vector< StateObjDesc > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_StateObjDesc_name_set(void * jarg1, char * jarg2) {
  StateObjDesc *arg1 = (StateObjDesc *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (StateObjDesc *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  if (arg1) (arg1)->name = *arg2;
}


SWIGEXPORT char * SWIGSTDCALL CSharp_StateObjDesc_name_get(void * jarg1) {
  char * jresult ;
  StateObjDesc *arg1 = (StateObjDesc *) 0 ;
  std::string *result = 0 ;
  
  arg1 = (StateObjDesc *)jarg1; 
  result = (std::string *) & ((arg1)->name);
  jresult = SWIG_csharp_string_callback(result->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_StateObjDesc_hasParent_set(void * jarg1, unsigned int jarg2) {
  StateObjDesc *arg1 = (StateObjDesc *) 0 ;
  bool arg2 ;
  
  arg1 = (StateObjDesc *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->hasParent = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_StateObjDesc_hasParent_get(void * jarg1) {
  unsigned int jresult ;
  StateObjDesc *arg1 = (StateObjDesc *) 0 ;
  bool result;
  
  arg1 = (StateObjDesc *)jarg1; 
  result = (bool) ((arg1)->hasParent);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_StateObjDesc() {
  void * jresult ;
  StateObjDesc *result = 0 ;
  
  result = (StateObjDesc *)new StateObjDesc();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_StateObjDesc(void * jarg1) {
  StateObjDesc *arg1 = (StateObjDesc *) 0 ;
  
  arg1 = (StateObjDesc *)jarg1; 
  delete arg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_StateSerializer() {
  void * jresult ;
  StateSerializer *result = 0 ;
  
  result = (StateSerializer *)new StateSerializer();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_StateSerializer(void * jarg1) {
  StateSerializer *arg1 = (StateSerializer *) 0 ;
  
  arg1 = (StateSerializer *)jarg1; 
  delete arg1;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_StateSerializer_DoRecoverySave(void * jarg1) {
  unsigned int jresult ;
  StateSerializer *arg1 = (StateSerializer *) 0 ;
  bool result;
  
  arg1 = (StateSerializer *)jarg1; 
  result = (bool)(arg1)->DoRecoverySave();
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_StateSerializer_SaveCurrentState(void * jarg1, char * jarg2) {
  unsigned int jresult ;
  StateSerializer *arg1 = (StateSerializer *) 0 ;
  std::string arg2 ;
  bool result;
  
  arg1 = (StateSerializer *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  (&arg2)->assign(jarg2); 
  result = (bool)(arg1)->SaveCurrentState(arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_StateSerializer_SaveState(void * jarg1, void * jarg2, char * jarg3) {
  unsigned int jresult ;
  StateSerializer *arg1 = (StateSerializer *) 0 ;
  BaseState *arg2 = 0 ;
  std::string arg3 ;
  bool result;
  
  arg1 = (StateSerializer *)jarg1; 
  arg2 = (BaseState *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "BaseState & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  (&arg3)->assign(jarg3); 
  result = (bool)(arg1)->SaveState(*arg2,arg3);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_StateSerializer_LoadState__SWIG_0(void * jarg1, char * jarg2, unsigned int jarg3) {
  StateSerializer *arg1 = (StateSerializer *) 0 ;
  std::string arg2 ;
  bool arg3 ;
  
  arg1 = (StateSerializer *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  (&arg2)->assign(jarg2); 
  arg3 = jarg3 ? true : false; 
  (arg1)->LoadState(arg2,arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_StateSerializer_LoadState__SWIG_1(void * jarg1, char * jarg2) {
  StateSerializer *arg1 = (StateSerializer *) 0 ;
  std::string arg2 ;
  
  arg1 = (StateSerializer *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  (&arg2)->assign(jarg2); 
  (arg1)->LoadState(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_StateSerializer_MergeStates__SWIG_0(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  StateSerializer *arg1 = (StateSerializer *) 0 ;
  BaseState *arg2 = (BaseState *) 0 ;
  BaseState *arg3 = (BaseState *) 0 ;
  std::vector< bool > *arg4 = (std::vector< bool > *) 0 ;
  
  arg1 = (StateSerializer *)jarg1; 
  arg2 = (BaseState *)jarg2; 
  arg3 = (BaseState *)jarg3; 
  arg4 = (std::vector< bool > *)jarg4; 
  (arg1)->MergeStates(arg2,arg3,arg4);
}


SWIGEXPORT void SWIGSTDCALL CSharp_StateSerializer_MergeStates__SWIG_1(void * jarg1, void * jarg2, void * jarg3) {
  StateSerializer *arg1 = (StateSerializer *) 0 ;
  BaseState *arg2 = (BaseState *) 0 ;
  BaseState *arg3 = (BaseState *) 0 ;
  
  arg1 = (StateSerializer *)jarg1; 
  arg2 = (BaseState *)jarg2; 
  arg3 = (BaseState *)jarg3; 
  (arg1)->MergeStates(arg2,arg3);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_StateSerializer_LoadStateInformation__SWIG_0(void * jarg1, char * jarg2, unsigned int jarg3, void * jarg4) {
  void * jresult ;
  StateSerializer *arg1 = (StateSerializer *) 0 ;
  std::string arg2 ;
  bool arg3 ;
  BaseState **arg4 = (BaseState **) 0 ;
  std::vector< StateObjDesc > result;
  
  arg1 = (StateSerializer *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  (&arg2)->assign(jarg2); 
  arg3 = jarg3 ? true : false; 
  arg4 = (BaseState **)jarg4; 
  result = (arg1)->LoadStateInformation(arg2,arg3,arg4);
  jresult = new std::vector< StateObjDesc >((const std::vector< StateObjDesc > &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_StateSerializer_LoadStateInformation__SWIG_1(void * jarg1, char * jarg2, unsigned int jarg3) {
  void * jresult ;
  StateSerializer *arg1 = (StateSerializer *) 0 ;
  std::string arg2 ;
  bool arg3 ;
  std::vector< StateObjDesc > result;
  
  arg1 = (StateSerializer *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  (&arg2)->assign(jarg2); 
  arg3 = jarg3 ? true : false; 
  result = (arg1)->LoadStateInformation(arg2,arg3);
  jresult = new std::vector< StateObjDesc >((const std::vector< StateObjDesc > &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_StateSerializer_LoadStateInformation__SWIG_2(void * jarg1, char * jarg2) {
  void * jresult ;
  StateSerializer *arg1 = (StateSerializer *) 0 ;
  std::string arg2 ;
  std::vector< StateObjDesc > result;
  
  arg1 = (StateSerializer *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  (&arg2)->assign(jarg2); 
  result = (arg1)->LoadStateInformation(arg2);
  jresult = new std::vector< StateObjDesc >((const std::vector< StateObjDesc > &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Map_LoadMapAdditive(char * jarg1) {
  std::string arg1 ;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  (&arg1)->assign(jarg1); 
  Map::LoadMapAdditive(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_Map_LoadMap(char * jarg1) {
  std::string arg1 ;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  (&arg1)->assign(jarg1); 
  Map::LoadMap(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_Map_LoadMapDontUnload(char * jarg1) {
  std::string arg1 ;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  (&arg1)->assign(jarg1); 
  Map::LoadMapDontUnload(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_Map_UnloadMap() {
  Map::UnloadMap();
}


SWIGEXPORT void SWIGSTDCALL CSharp_Map_LoadOnlyMap(char * jarg1) {
  std::string arg1 ;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  (&arg1)->assign(jarg1); 
  Map::LoadOnlyMap(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_Map_DeloadZone(void * jarg1) {
  IZone *arg1 = (IZone *) 0 ;
  
  arg1 = (IZone *)jarg1; 
  Map::DeloadZone(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_Map_ReloadMap() {
  Map::ReloadMap();
}


SWIGEXPORT void SWIGSTDCALL CSharp_Map_ReloadPreviousMap() {
  Map::ReloadPreviousMap();
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Map() {
  void * jresult ;
  Map *result = 0 ;
  
  result = (Map *)new Map();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_Map(void * jarg1) {
  Map *arg1 = (Map *) 0 ;
  
  arg1 = (Map *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_OperationList_Clear(void * jarg1) {
  std::vector< Barrista::operation_info > *arg1 = (std::vector< Barrista::operation_info > *) 0 ;
  
  arg1 = (std::vector< Barrista::operation_info > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_OperationList_Add(void * jarg1, void * jarg2) {
  std::vector< Barrista::operation_info > *arg1 = (std::vector< Barrista::operation_info > *) 0 ;
  Barrista::operation_info *arg2 = 0 ;
  
  arg1 = (std::vector< Barrista::operation_info > *)jarg1; 
  arg2 = (Barrista::operation_info *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Barrista::operation_info const & type is null", 0);
    return ;
  } 
  (arg1)->push_back((Barrista::operation_info const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_OperationList_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< Barrista::operation_info > *arg1 = (std::vector< Barrista::operation_info > *) 0 ;
  std::vector< Barrista::operation_info >::size_type result;
  
  arg1 = (std::vector< Barrista::operation_info > *)jarg1; 
  result = ((std::vector< Barrista::operation_info > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_OperationList_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< Barrista::operation_info > *arg1 = (std::vector< Barrista::operation_info > *) 0 ;
  std::vector< Barrista::operation_info >::size_type result;
  
  arg1 = (std::vector< Barrista::operation_info > *)jarg1; 
  result = ((std::vector< Barrista::operation_info > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_OperationList_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< Barrista::operation_info > *arg1 = (std::vector< Barrista::operation_info > *) 0 ;
  std::vector< Barrista::operation_info >::size_type arg2 ;
  
  arg1 = (std::vector< Barrista::operation_info > *)jarg1; 
  arg2 = (std::vector< Barrista::operation_info >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_OperationList__SWIG_0() {
  void * jresult ;
  std::vector< Barrista::operation_info > *result = 0 ;
  
  result = (std::vector< Barrista::operation_info > *)new std::vector< Barrista::operation_info >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_OperationList__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< Barrista::operation_info > *arg1 = 0 ;
  std::vector< Barrista::operation_info > *result = 0 ;
  
  arg1 = (std::vector< Barrista::operation_info > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< Barrista::operation_info > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< Barrista::operation_info > *)new std::vector< Barrista::operation_info >((std::vector< Barrista::operation_info > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_OperationList__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< Barrista::operation_info > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< Barrista::operation_info > *)new_std_vector_Sl_Barrista_operation_info_Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_OperationList_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< Barrista::operation_info > *arg1 = (std::vector< Barrista::operation_info > *) 0 ;
  int arg2 ;
  Barrista::operation_info result;
  
  arg1 = (std::vector< Barrista::operation_info > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_Barrista_operation_info_Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = new Barrista::operation_info((const Barrista::operation_info &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_OperationList_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< Barrista::operation_info > *arg1 = (std::vector< Barrista::operation_info > *) 0 ;
  int arg2 ;
  Barrista::operation_info *result = 0 ;
  
  arg1 = (std::vector< Barrista::operation_info > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (Barrista::operation_info *) &std_vector_Sl_Barrista_operation_info_Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_OperationList_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< Barrista::operation_info > *arg1 = (std::vector< Barrista::operation_info > *) 0 ;
  int arg2 ;
  Barrista::operation_info *arg3 = 0 ;
  
  arg1 = (std::vector< Barrista::operation_info > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (Barrista::operation_info *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Barrista::operation_info const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_Barrista_operation_info_Sg__setitem(arg1,arg2,(Barrista::operation_info const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_OperationList_AddRange(void * jarg1, void * jarg2) {
  std::vector< Barrista::operation_info > *arg1 = (std::vector< Barrista::operation_info > *) 0 ;
  std::vector< Barrista::operation_info > *arg2 = 0 ;
  
  arg1 = (std::vector< Barrista::operation_info > *)jarg1; 
  arg2 = (std::vector< Barrista::operation_info > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< Barrista::operation_info > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_Barrista_operation_info_Sg__AddRange(arg1,(std::vector< Barrista::operation_info > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_OperationList_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< Barrista::operation_info > *arg1 = (std::vector< Barrista::operation_info > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< Barrista::operation_info > *result = 0 ;
  
  arg1 = (std::vector< Barrista::operation_info > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< Barrista::operation_info > *)std_vector_Sl_Barrista_operation_info_Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_OperationList_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< Barrista::operation_info > *arg1 = (std::vector< Barrista::operation_info > *) 0 ;
  int arg2 ;
  Barrista::operation_info *arg3 = 0 ;
  
  arg1 = (std::vector< Barrista::operation_info > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (Barrista::operation_info *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Barrista::operation_info const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_Barrista_operation_info_Sg__Insert(arg1,arg2,(Barrista::operation_info const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_OperationList_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< Barrista::operation_info > *arg1 = (std::vector< Barrista::operation_info > *) 0 ;
  int arg2 ;
  std::vector< Barrista::operation_info > *arg3 = 0 ;
  
  arg1 = (std::vector< Barrista::operation_info > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< Barrista::operation_info > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< Barrista::operation_info > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_Barrista_operation_info_Sg__InsertRange(arg1,arg2,(std::vector< Barrista::operation_info > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_OperationList_RemoveAt(void * jarg1, int jarg2) {
  std::vector< Barrista::operation_info > *arg1 = (std::vector< Barrista::operation_info > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< Barrista::operation_info > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_Barrista_operation_info_Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_OperationList_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< Barrista::operation_info > *arg1 = (std::vector< Barrista::operation_info > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< Barrista::operation_info > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_Barrista_operation_info_Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_OperationList_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  Barrista::operation_info *arg1 = 0 ;
  int arg2 ;
  std::vector< Barrista::operation_info > *result = 0 ;
  
  arg1 = (Barrista::operation_info *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Barrista::operation_info const & type is null", 0);
    return 0;
  } 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< Barrista::operation_info > *)std_vector_Sl_Barrista_operation_info_Sg__Repeat((Barrista::operation_info const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_OperationList_Reverse__SWIG_0(void * jarg1) {
  std::vector< Barrista::operation_info > *arg1 = (std::vector< Barrista::operation_info > *) 0 ;
  
  arg1 = (std::vector< Barrista::operation_info > *)jarg1; 
  std_vector_Sl_Barrista_operation_info_Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_OperationList_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< Barrista::operation_info > *arg1 = (std::vector< Barrista::operation_info > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< Barrista::operation_info > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_Barrista_operation_info_Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_OperationList_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< Barrista::operation_info > *arg1 = (std::vector< Barrista::operation_info > *) 0 ;
  int arg2 ;
  std::vector< Barrista::operation_info > *arg3 = 0 ;
  
  arg1 = (std::vector< Barrista::operation_info > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< Barrista::operation_info > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< Barrista::operation_info > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_Barrista_operation_info_Sg__SetRange(arg1,arg2,(std::vector< Barrista::operation_info > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_OperationList(void * jarg1) {
  std::vector< Barrista::operation_info > *arg1 = (std::vector< Barrista::operation_info > *) 0 ;
  
  arg1 = (std::vector< Barrista::operation_info > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Barrista_operation_info_line_set(void * jarg1, unsigned int jarg2) {
  Barrista::operation_info *arg1 = (Barrista::operation_info *) 0 ;
  unsigned int arg2 ;
  
  arg1 = (Barrista::operation_info *)jarg1; 
  arg2 = (unsigned int)jarg2; 
  if (arg1) (arg1)->line = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_Barrista_operation_info_line_get(void * jarg1) {
  unsigned int jresult ;
  Barrista::operation_info *arg1 = (Barrista::operation_info *) 0 ;
  unsigned int result;
  
  arg1 = (Barrista::operation_info *)jarg1; 
  result = (unsigned int) ((arg1)->line);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Barrista_operation_info_samples_num_set(void * jarg1, long long jarg2) {
  Barrista::operation_info *arg1 = (Barrista::operation_info *) 0 ;
  long long arg2 ;
  
  arg1 = (Barrista::operation_info *)jarg1; 
  arg2 = (long long)jarg2; 
  if (arg1) (arg1)->samples_num = arg2;
}


SWIGEXPORT long long SWIGSTDCALL CSharp_Barrista_operation_info_samples_num_get(void * jarg1) {
  long long jresult ;
  Barrista::operation_info *arg1 = (Barrista::operation_info *) 0 ;
  long long result;
  
  arg1 = (Barrista::operation_info *)jarg1; 
  result = (long long) ((arg1)->samples_num);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Barrista_operation_info_samples_sum_set(void * jarg1, long long jarg2) {
  Barrista::operation_info *arg1 = (Barrista::operation_info *) 0 ;
  long long arg2 ;
  
  arg1 = (Barrista::operation_info *)jarg1; 
  arg2 = (long long)jarg2; 
  if (arg1) (arg1)->samples_sum = arg2;
}


SWIGEXPORT long long SWIGSTDCALL CSharp_Barrista_operation_info_samples_sum_get(void * jarg1) {
  long long jresult ;
  Barrista::operation_info *arg1 = (Barrista::operation_info *) 0 ;
  long long result;
  
  arg1 = (Barrista::operation_info *)jarg1; 
  result = (long long) ((arg1)->samples_sum);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Barrista_operation_info_name_set(void * jarg1, char * jarg2) {
  Barrista::operation_info *arg1 = (Barrista::operation_info *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (Barrista::operation_info *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  if (arg1) (arg1)->name = *arg2;
}


SWIGEXPORT char * SWIGSTDCALL CSharp_Barrista_operation_info_name_get(void * jarg1) {
  char * jresult ;
  Barrista::operation_info *arg1 = (Barrista::operation_info *) 0 ;
  std::string *result = 0 ;
  
  arg1 = (Barrista::operation_info *)jarg1; 
  result = (std::string *) & ((arg1)->name);
  jresult = SWIG_csharp_string_callback(result->c_str()); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Barrista_operation_info() {
  void * jresult ;
  Barrista::operation_info *result = 0 ;
  
  result = (Barrista::operation_info *)new Barrista::operation_info();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_Barrista_operation_info(void * jarg1) {
  Barrista::operation_info *arg1 = (Barrista::operation_info *) 0 ;
  
  arg1 = (Barrista::operation_info *)jarg1; 
  delete arg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Barrista_Schedule_Generate(void * jarg1) {
  void * jresult ;
  Barrista *arg1 = (Barrista *) 0 ;
  std::vector< Barrista::operation_info > result;
  
  arg1 = (Barrista *)jarg1; 
  result = (arg1)->Schedule_Generate();
  jresult = new std::vector< Barrista::operation_info >((const std::vector< Barrista::operation_info > &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Barrista_getInstance() {
  void * jresult ;
  Barrista *result = 0 ;
  
  result = (Barrista *)Barrista::getInstance();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_ScriptSubsystem_Register_Callbacks(void * jarg1, void* jarg2, void* jarg3, void* jarg4, void* jarg5, void* jarg6, void* jarg7, void* jarg8, void* jarg9, void* jarg10, void* jarg11) {
  ScriptSubsystem *arg1 = (ScriptSubsystem *) 0 ;
  MochaDotNetCallback arg2 ;
  MochaDotNetCScriptCopyCallback arg3 ;
  MochaDotNetCScriptEventCallback arg4 ;
  MochaDotNetCallback arg5 ;
  MochaDotNetCallback arg6 ;
  MochaDotNetCallback arg7 ;
  MochaDotNetCScriptCallback arg8 ;
  MochaDotNetCScriptCallback arg9 ;
  MochaDotNetCallback arg10 ;
  MochaDotNetCallback arg11 ;
  
  arg1 = (ScriptSubsystem *)jarg1; 
  arg2 = (MochaDotNetCallback)jarg2; 
  arg3 = (MochaDotNetCScriptCopyCallback)jarg3; 
  arg4 = (MochaDotNetCScriptEventCallback)jarg4; 
  arg5 = (MochaDotNetCallback)jarg5; 
  arg6 = (MochaDotNetCallback)jarg6; 
  arg7 = (MochaDotNetCallback)jarg7; 
  arg8 = (MochaDotNetCScriptCallback)jarg8; 
  arg9 = (MochaDotNetCScriptCallback)jarg9; 
  arg10 = (MochaDotNetCallback)jarg10; 
  arg11 = (MochaDotNetCallback)jarg11; 
  (arg1)->Register_Callbacks(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_ScriptSubsystem_getInstance() {
  void * jresult ;
  ScriptSubsystem *result = 0 ;
  
  result = (ScriptSubsystem *)ScriptSubsystem::getInstance();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_GameObjectVector_Clear(void * jarg1) {
  std::vector< GameObject * > *arg1 = (std::vector< GameObject * > *) 0 ;
  
  arg1 = (std::vector< GameObject * > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_GameObjectVector_Add(void * jarg1, void * jarg2) {
  std::vector< GameObject * > *arg1 = (std::vector< GameObject * > *) 0 ;
  GameObject **arg2 = 0 ;
  GameObject *temp2 = 0 ;
  
  arg1 = (std::vector< GameObject * > *)jarg1; 
  temp2 = (GameObject *)jarg2;
  arg2 = (GameObject **)&temp2; 
  (arg1)->push_back((GameObject *const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_GameObjectVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< GameObject * > *arg1 = (std::vector< GameObject * > *) 0 ;
  std::vector< GameObject * >::size_type result;
  
  arg1 = (std::vector< GameObject * > *)jarg1; 
  result = ((std::vector< GameObject * > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_GameObjectVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< GameObject * > *arg1 = (std::vector< GameObject * > *) 0 ;
  std::vector< GameObject * >::size_type result;
  
  arg1 = (std::vector< GameObject * > *)jarg1; 
  result = ((std::vector< GameObject * > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_GameObjectVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< GameObject * > *arg1 = (std::vector< GameObject * > *) 0 ;
  std::vector< GameObject * >::size_type arg2 ;
  
  arg1 = (std::vector< GameObject * > *)jarg1; 
  arg2 = (std::vector< GameObject * >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_GameObjectVector__SWIG_0() {
  void * jresult ;
  std::vector< GameObject * > *result = 0 ;
  
  result = (std::vector< GameObject * > *)new std::vector< GameObject * >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_GameObjectVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< GameObject * > *arg1 = 0 ;
  std::vector< GameObject * > *result = 0 ;
  
  arg1 = (std::vector< GameObject * > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< GameObject * > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< GameObject * > *)new std::vector< GameObject * >((std::vector< GameObject * > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_GameObjectVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< GameObject * > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< GameObject * > *)new_std_vector_Sl_GameObject_Sm__Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_GameObjectVector_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< GameObject * > *arg1 = (std::vector< GameObject * > *) 0 ;
  int arg2 ;
  GameObject *result = 0 ;
  
  arg1 = (std::vector< GameObject * > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (GameObject *)std_vector_Sl_GameObject_Sm__Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_GameObjectVector_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< GameObject * > *arg1 = (std::vector< GameObject * > *) 0 ;
  int arg2 ;
  GameObject **result = 0 ;
  
  arg1 = (std::vector< GameObject * > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (GameObject **) &std_vector_Sl_GameObject_Sm__Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)*result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_GameObjectVector_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< GameObject * > *arg1 = (std::vector< GameObject * > *) 0 ;
  int arg2 ;
  GameObject **arg3 = 0 ;
  GameObject *temp3 = 0 ;
  
  arg1 = (std::vector< GameObject * > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (GameObject *)jarg3;
  arg3 = (GameObject **)&temp3; 
  try {
    std_vector_Sl_GameObject_Sm__Sg__setitem(arg1,arg2,(GameObject *const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_GameObjectVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< GameObject * > *arg1 = (std::vector< GameObject * > *) 0 ;
  std::vector< GameObject * > *arg2 = 0 ;
  
  arg1 = (std::vector< GameObject * > *)jarg1; 
  arg2 = (std::vector< GameObject * > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< GameObject * > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_GameObject_Sm__Sg__AddRange(arg1,(std::vector< GameObject * > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_GameObjectVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< GameObject * > *arg1 = (std::vector< GameObject * > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< GameObject * > *result = 0 ;
  
  arg1 = (std::vector< GameObject * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< GameObject * > *)std_vector_Sl_GameObject_Sm__Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_GameObjectVector_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< GameObject * > *arg1 = (std::vector< GameObject * > *) 0 ;
  int arg2 ;
  GameObject **arg3 = 0 ;
  GameObject *temp3 = 0 ;
  
  arg1 = (std::vector< GameObject * > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (GameObject *)jarg3;
  arg3 = (GameObject **)&temp3; 
  try {
    std_vector_Sl_GameObject_Sm__Sg__Insert(arg1,arg2,(GameObject *const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_GameObjectVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< GameObject * > *arg1 = (std::vector< GameObject * > *) 0 ;
  int arg2 ;
  std::vector< GameObject * > *arg3 = 0 ;
  
  arg1 = (std::vector< GameObject * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< GameObject * > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< GameObject * > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_GameObject_Sm__Sg__InsertRange(arg1,arg2,(std::vector< GameObject * > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_GameObjectVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< GameObject * > *arg1 = (std::vector< GameObject * > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< GameObject * > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_GameObject_Sm__Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_GameObjectVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< GameObject * > *arg1 = (std::vector< GameObject * > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< GameObject * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_GameObject_Sm__Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_GameObjectVector_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  GameObject **arg1 = 0 ;
  int arg2 ;
  GameObject *temp1 = 0 ;
  std::vector< GameObject * > *result = 0 ;
  
  temp1 = (GameObject *)jarg1;
  arg1 = (GameObject **)&temp1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< GameObject * > *)std_vector_Sl_GameObject_Sm__Sg__Repeat((GameObject *const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_GameObjectVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< GameObject * > *arg1 = (std::vector< GameObject * > *) 0 ;
  
  arg1 = (std::vector< GameObject * > *)jarg1; 
  std_vector_Sl_GameObject_Sm__Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_GameObjectVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< GameObject * > *arg1 = (std::vector< GameObject * > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< GameObject * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_GameObject_Sm__Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_GameObjectVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< GameObject * > *arg1 = (std::vector< GameObject * > *) 0 ;
  int arg2 ;
  std::vector< GameObject * > *arg3 = 0 ;
  
  arg1 = (std::vector< GameObject * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< GameObject * > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< GameObject * > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_GameObject_Sm__Sg__SetRange(arg1,arg2,(std::vector< GameObject * > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_GameObjectVector_Contains(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::vector< GameObject * > *arg1 = (std::vector< GameObject * > *) 0 ;
  GameObject **arg2 = 0 ;
  GameObject *temp2 = 0 ;
  bool result;
  
  arg1 = (std::vector< GameObject * > *)jarg1; 
  temp2 = (GameObject *)jarg2;
  arg2 = (GameObject **)&temp2; 
  result = (bool)std_vector_Sl_GameObject_Sm__Sg__Contains(arg1,(GameObject *const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_GameObjectVector_IndexOf(void * jarg1, void * jarg2) {
  int jresult ;
  std::vector< GameObject * > *arg1 = (std::vector< GameObject * > *) 0 ;
  GameObject **arg2 = 0 ;
  GameObject *temp2 = 0 ;
  int result;
  
  arg1 = (std::vector< GameObject * > *)jarg1; 
  temp2 = (GameObject *)jarg2;
  arg2 = (GameObject **)&temp2; 
  result = (int)std_vector_Sl_GameObject_Sm__Sg__IndexOf(arg1,(GameObject *const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_GameObjectVector_LastIndexOf(void * jarg1, void * jarg2) {
  int jresult ;
  std::vector< GameObject * > *arg1 = (std::vector< GameObject * > *) 0 ;
  GameObject **arg2 = 0 ;
  GameObject *temp2 = 0 ;
  int result;
  
  arg1 = (std::vector< GameObject * > *)jarg1; 
  temp2 = (GameObject *)jarg2;
  arg2 = (GameObject **)&temp2; 
  result = (int)std_vector_Sl_GameObject_Sm__Sg__LastIndexOf(arg1,(GameObject *const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_GameObjectVector_Remove(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::vector< GameObject * > *arg1 = (std::vector< GameObject * > *) 0 ;
  GameObject **arg2 = 0 ;
  GameObject *temp2 = 0 ;
  bool result;
  
  arg1 = (std::vector< GameObject * > *)jarg1; 
  temp2 = (GameObject *)jarg2;
  arg2 = (GameObject **)&temp2; 
  result = (bool)std_vector_Sl_GameObject_Sm__Sg__Remove(arg1,(GameObject *const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_GameObjectVector(void * jarg1) {
  std::vector< GameObject * > *arg1 = (std::vector< GameObject * > *) 0 ;
  
  arg1 = (std::vector< GameObject * > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_WidgetManager_GetAttachedObjFromWidgetObj(void * jarg1, void * jarg2) {
  void * jresult ;
  EditorSubsystemTools::WidgetManager *arg1 = (EditorSubsystemTools::WidgetManager *) 0 ;
  GameObject *arg2 = (GameObject *) 0 ;
  GameObject *result = 0 ;
  
  arg1 = (EditorSubsystemTools::WidgetManager *)jarg1; 
  arg2 = (GameObject *)jarg2; 
  result = (GameObject *)(arg1)->GetAttachedObjFromWidgetObj(arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_EditorSubsystem_IsTesting(void * jarg1) {
  unsigned int jresult ;
  EditorSubsystem *arg1 = (EditorSubsystem *) 0 ;
  bool result;
  
  arg1 = (EditorSubsystem *)jarg1; 
  result = (bool)(arg1)->IsTesting();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_EditorSubsystem_GetEditorState(void * jarg1) {
  void * jresult ;
  EditorSubsystem *arg1 = (EditorSubsystem *) 0 ;
  EditorState *result = 0 ;
  
  arg1 = (EditorSubsystem *)jarg1; 
  result = (EditorState *)((EditorSubsystem const *)arg1)->GetEditorState();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_EditorSubsystem_EditorCamera(void * jarg1) {
  void * jresult ;
  EditorSubsystem *arg1 = (EditorSubsystem *) 0 ;
  CCamera *result = 0 ;
  
  arg1 = (EditorSubsystem *)jarg1; 
  result = (CCamera *)((EditorSubsystem const *)arg1)->EditorCamera();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_EditorSubsystem_EditorTransformWidget(void * jarg1) {
  void * jresult ;
  EditorSubsystem *arg1 = (EditorSubsystem *) 0 ;
  GameObject *result = 0 ;
  
  arg1 = (EditorSubsystem *)jarg1; 
  result = (GameObject *)((EditorSubsystem const *)arg1)->EditorTransformWidget();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_EditorSubsystem_Register_Tick(void * jarg1, void* jarg2) {
  EditorSubsystem *arg1 = (EditorSubsystem *) 0 ;
  MochaDotNetCallback arg2 ;
  
  arg1 = (EditorSubsystem *)jarg1; 
  arg2 = (MochaDotNetCallback)jarg2; 
  (arg1)->Register_Tick(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_EditorSubsystem_SetSelectedObjects(void * jarg1, void * jarg2) {
  EditorSubsystem *arg1 = (EditorSubsystem *) 0 ;
  std::vector< GameObject * > arg2 ;
  std::vector< GameObject * > *argp2 ;
  
  arg1 = (EditorSubsystem *)jarg1; 
  argp2 = (std::vector< GameObject * > *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null std::vector< GameObject * >", 0);
    return ;
  }
  arg2 = *argp2; 
  (arg1)->SetSelectedObjects(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_EditorSubsystem_BeginTesting(void * jarg1) {
  EditorSubsystem *arg1 = (EditorSubsystem *) 0 ;
  
  arg1 = (EditorSubsystem *)jarg1; 
  (arg1)->BeginTesting();
}


SWIGEXPORT void SWIGSTDCALL CSharp_EditorSubsystem_EndTesting(void * jarg1) {
  EditorSubsystem *arg1 = (EditorSubsystem *) 0 ;
  
  arg1 = (EditorSubsystem *)jarg1; 
  (arg1)->EndTesting();
}


SWIGEXPORT void SWIGSTDCALL CSharp_EditorSubsystem_widgetManager_set(void * jarg1, void * jarg2) {
  EditorSubsystem *arg1 = (EditorSubsystem *) 0 ;
  EditorSubsystemTools::WidgetManager *arg2 = (EditorSubsystemTools::WidgetManager *) 0 ;
  
  arg1 = (EditorSubsystem *)jarg1; 
  arg2 = (EditorSubsystemTools::WidgetManager *)jarg2; 
  if (arg1) (arg1)->widgetManager = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_EditorSubsystem_widgetManager_get(void * jarg1) {
  void * jresult ;
  EditorSubsystem *arg1 = (EditorSubsystem *) 0 ;
  EditorSubsystemTools::WidgetManager *result = 0 ;
  
  arg1 = (EditorSubsystem *)jarg1; 
  result = (EditorSubsystemTools::WidgetManager *)& ((arg1)->widgetManager);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_EditorSubsystem_getInstance() {
  void * jresult ;
  EditorSubsystem *result = 0 ;
  
  result = (EditorSubsystem *)EditorSubsystem::getInstance();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_EditorSubsystem_gridSize_set(void * jarg1, int jarg2) {
  EditorSubsystem *arg1 = (EditorSubsystem *) 0 ;
  int arg2 ;
  
  arg1 = (EditorSubsystem *)jarg1; 
  arg2 = (int)jarg2; 
  if (arg1) (arg1)->gridSize = arg2;
}


SWIGEXPORT int SWIGSTDCALL CSharp_EditorSubsystem_gridSize_get(void * jarg1) {
  int jresult ;
  EditorSubsystem *arg1 = (EditorSubsystem *) 0 ;
  int result;
  
  arg1 = (EditorSubsystem *)jarg1; 
  result = (int) ((arg1)->gridSize);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Material_SetTexture(void * jarg1, char * jarg2) {
  Material *arg1 = (Material *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (Material *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  (arg1)->SetTexture((std::string const &)*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_Material_SetTextureOffset(void * jarg1, void * jarg2, int jarg3) {
  Material *arg1 = (Material *) 0 ;
  Vector2 *arg2 = 0 ;
  int arg3 ;
  
  arg1 = (Material *)jarg1; 
  arg2 = (Vector2 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Vector2 & type is null", 0);
    return ;
  } 
  arg3 = (int)jarg3; 
  (arg1)->SetTextureOffset(*arg2,arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_Material_SetTextureScale(void * jarg1, void * jarg2, int jarg3) {
  Material *arg1 = (Material *) 0 ;
  Vector2 *arg2 = 0 ;
  int arg3 ;
  
  arg1 = (Material *)jarg1; 
  arg2 = (Vector2 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Vector2 & type is null", 0);
    return ;
  } 
  arg3 = (int)jarg3; 
  (arg1)->SetTextureScale(*arg2,arg3);
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_Material_GetTextureWidth(void * jarg1, unsigned int jarg2) {
  unsigned int jresult ;
  Material *arg1 = (Material *) 0 ;
  unsigned int arg2 ;
  unsigned int result;
  
  arg1 = (Material *)jarg1; 
  arg2 = (unsigned int)jarg2; 
  result = (unsigned int)(arg1)->GetTextureWidth(arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_Material_GetTextureHeight(void * jarg1, unsigned int jarg2) {
  unsigned int jresult ;
  Material *arg1 = (Material *) 0 ;
  unsigned int arg2 ;
  unsigned int result;
  
  arg1 = (Material *)jarg1; 
  arg2 = (unsigned int)jarg2; 
  result = (unsigned int)(arg1)->GetTextureHeight(arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_Material_GetColorAlpha(void * jarg1) {
  float jresult ;
  Material *arg1 = (Material *) 0 ;
  float result;
  
  arg1 = (Material *)jarg1; 
  result = (float)(arg1)->GetColorAlpha();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Material_SetColorAlpha(void * jarg1, float jarg2) {
  Material *arg1 = (Material *) 0 ;
  float arg2 ;
  
  arg1 = (Material *)jarg1; 
  arg2 = (float)jarg2; 
  (arg1)->SetColorAlpha(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_Material_SetColor__SWIG_0(void * jarg1, void * jarg2) {
  Material *arg1 = (Material *) 0 ;
  Color *arg2 = 0 ;
  
  arg1 = (Material *)jarg1; 
  arg2 = (Color *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Color const & type is null", 0);
    return ;
  } 
  (arg1)->SetColor((Color const &)*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_Material_SetColor__SWIG_1(void * jarg1, float jarg2, float jarg3, float jarg4, float jarg5) {
  Material *arg1 = (Material *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  
  arg1 = (Material *)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  arg5 = (float)jarg5; 
  (arg1)->SetColor(arg2,arg3,arg4,arg5);
}


SWIGEXPORT void SWIGSTDCALL CSharp_Material_SetColor__SWIG_2(void * jarg1, float jarg2, float jarg3, float jarg4) {
  Material *arg1 = (Material *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  arg1 = (Material *)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  (arg1)->SetColor(arg2,arg3,arg4);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Material_GetColor(void * jarg1) {
  void * jresult ;
  Material *arg1 = (Material *) 0 ;
  Color result;
  
  arg1 = (Material *)jarg1; 
  result = (arg1)->GetColor();
  jresult = new Color((const Color &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Material_mMaterialData_set(void * jarg1, void * jarg2) {
  Material *arg1 = (Material *) 0 ;
  MaterialImpl *arg2 = (MaterialImpl *) 0 ;
  
  arg1 = (Material *)jarg1; 
  arg2 = (MaterialImpl *)jarg2; 
  if (arg1) (arg1)->mMaterialData = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Material_mMaterialData_get(void * jarg1) {
  void * jresult ;
  Material *arg1 = (Material *) 0 ;
  MaterialImpl *result = 0 ;
  
  arg1 = (Material *)jarg1; 
  result = (MaterialImpl *)& ((arg1)->mMaterialData);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_MatAttribNode_mNodeType_set(void * jarg1, int jarg2) {
  MatAttribNode *arg1 = (MatAttribNode *) 0 ;
  MatAttribNode_Type::TypeEnum arg2 ;
  
  arg1 = (MatAttribNode *)jarg1; 
  arg2 = (MatAttribNode_Type::TypeEnum)jarg2; 
  if (arg1) (arg1)->mNodeType = arg2;
}


SWIGEXPORT int SWIGSTDCALL CSharp_MatAttribNode_mNodeType_get(void * jarg1) {
  int jresult ;
  MatAttribNode *arg1 = (MatAttribNode *) 0 ;
  MatAttribNode_Type::TypeEnum result;
  
  arg1 = (MatAttribNode *)jarg1; 
  result = (MatAttribNode_Type::TypeEnum) ((arg1)->mNodeType);
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_MatAttribNode_NodeType(void * jarg1) {
  int jresult ;
  MatAttribNode *arg1 = (MatAttribNode *) 0 ;
  MatAttribNode_Type::TypeEnum result;
  
  arg1 = (MatAttribNode *)jarg1; 
  result = (MatAttribNode_Type::TypeEnum)((MatAttribNode const *)arg1)->NodeType();
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_TextureNode_mTexture_set(void * jarg1, void * jarg2) {
  TextureNode *arg1 = (TextureNode *) 0 ;
  AssetHandle *arg2 = (AssetHandle *) 0 ;
  
  arg1 = (TextureNode *)jarg1; 
  arg2 = (AssetHandle *)jarg2; 
  if (arg1) (arg1)->mTexture = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_TextureNode_mTexture_get(void * jarg1) {
  void * jresult ;
  TextureNode *arg1 = (TextureNode *) 0 ;
  AssetHandle *result = 0 ;
  
  arg1 = (TextureNode *)jarg1; 
  result = (AssetHandle *)& ((arg1)->mTexture);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_TextureNode_mTextureRegister_set(void * jarg1, int jarg2) {
  TextureNode *arg1 = (TextureNode *) 0 ;
  TextureNode::TextureRegisterType arg2 ;
  
  arg1 = (TextureNode *)jarg1; 
  arg2 = (TextureNode::TextureRegisterType)jarg2; 
  if (arg1) (arg1)->mTextureRegister = arg2;
}


SWIGEXPORT int SWIGSTDCALL CSharp_TextureNode_mTextureRegister_get(void * jarg1) {
  int jresult ;
  TextureNode *arg1 = (TextureNode *) 0 ;
  TextureNode::TextureRegisterType result;
  
  arg1 = (TextureNode *)jarg1; 
  result = (TextureNode::TextureRegisterType) ((arg1)->mTextureRegister);
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_TextureNode_SetTexture__SWIG_0(void * jarg1, void * jarg2) {
  TextureNode *arg1 = (TextureNode *) 0 ;
  AssetHandle arg2 ;
  AssetHandle *argp2 ;
  
  arg1 = (TextureNode *)jarg1; 
  argp2 = (AssetHandle *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null AssetHandle", 0);
    return ;
  }
  arg2 = *argp2; 
  (arg1)->SetTexture(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_TextureNode_SetTexture__SWIG_1(void * jarg1, char * jarg2) {
  TextureNode *arg1 = (TextureNode *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (TextureNode *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  (arg1)->SetTexture((std::string const &)*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_TextureNode_SetTextureRegister(void * jarg1, int jarg2) {
  TextureNode *arg1 = (TextureNode *) 0 ;
  TextureNode::TextureRegisterType arg2 ;
  
  arg1 = (TextureNode *)jarg1; 
  arg2 = (TextureNode::TextureRegisterType)jarg2; 
  (arg1)->SetTextureRegister(arg2);
}


SWIGEXPORT float SWIGSTDCALL CSharp_TextureNode_GetTextureWidth(void * jarg1) {
  float jresult ;
  TextureNode *arg1 = (TextureNode *) 0 ;
  float result;
  
  arg1 = (TextureNode *)jarg1; 
  result = (float)(arg1)->GetTextureWidth();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_TextureNode_GetTextureHeight(void * jarg1) {
  float jresult ;
  TextureNode *arg1 = (TextureNode *) 0 ;
  float result;
  
  arg1 = (TextureNode *)jarg1; 
  result = (float)(arg1)->GetTextureHeight();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_TextureNode_GetTexture(void * jarg1) {
  void * jresult ;
  TextureNode *arg1 = (TextureNode *) 0 ;
  AssetHandle *result = 0 ;
  
  arg1 = (TextureNode *)jarg1; 
  result = (AssetHandle *) &(arg1)->GetTexture();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_ColorNode_color_set(void * jarg1, void * jarg2) {
  ColorNode *arg1 = (ColorNode *) 0 ;
  Color *arg2 = (Color *) 0 ;
  
  arg1 = (ColorNode *)jarg1; 
  arg2 = (Color *)jarg2; 
  if (arg1) (arg1)->color = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_ColorNode_color_get(void * jarg1) {
  void * jresult ;
  ColorNode *arg1 = (ColorNode *) 0 ;
  Color *result = 0 ;
  
  arg1 = (ColorNode *)jarg1; 
  result = (Color *)& ((arg1)->color);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_ColorNode_mTextureOffset_set(void * jarg1, void * jarg2) {
  ColorNode *arg1 = (ColorNode *) 0 ;
  Math::Vector2 *arg2 = (Math::Vector2 *) 0 ;
  
  arg1 = (ColorNode *)jarg1; 
  arg2 = (Math::Vector2 *)jarg2; 
  if (arg1) (arg1)->mTextureOffset = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_ColorNode_mTextureOffset_get(void * jarg1) {
  void * jresult ;
  ColorNode *arg1 = (ColorNode *) 0 ;
  Math::Vector2 *result = 0 ;
  
  arg1 = (ColorNode *)jarg1; 
  result = (Math::Vector2 *)& ((arg1)->mTextureOffset);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_ColorNode_mTextureScale_set(void * jarg1, void * jarg2) {
  ColorNode *arg1 = (ColorNode *) 0 ;
  Math::Vector2 *arg2 = (Math::Vector2 *) 0 ;
  
  arg1 = (ColorNode *)jarg1; 
  arg2 = (Math::Vector2 *)jarg2; 
  if (arg1) (arg1)->mTextureScale = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_ColorNode_mTextureScale_get(void * jarg1) {
  void * jresult ;
  ColorNode *arg1 = (ColorNode *) 0 ;
  Math::Vector2 *result = 0 ;
  
  arg1 = (ColorNode *)jarg1; 
  result = (Math::Vector2 *)& ((arg1)->mTextureScale);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_ColorNode_BindAttribute(void * jarg1, void * jarg2) {
  ColorNode *arg1 = (ColorNode *) 0 ;
  Shader *arg2 = (Shader *) 0 ;
  
  arg1 = (ColorNode *)jarg1; 
  arg2 = (Shader *)jarg2; 
  (arg1)->BindAttribute(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_ColorNode_SetColor(void * jarg1, void * jarg2) {
  ColorNode *arg1 = (ColorNode *) 0 ;
  Color *arg2 = 0 ;
  
  arg1 = (ColorNode *)jarg1; 
  arg2 = (Color *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Color const & type is null", 0);
    return ;
  } 
  (arg1)->SetColor((Color const &)*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_ShaderNode_SetShader(void * jarg1, char * jarg2) {
  ShaderNode *arg1 = (ShaderNode *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (ShaderNode *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  (arg1)->SetShader((std::string const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_ShaderNode_GetShader(void * jarg1) {
  void * jresult ;
  ShaderNode *arg1 = (ShaderNode *) 0 ;
  Shader *result = 0 ;
  
  arg1 = (ShaderNode *)jarg1; 
  result = (Shader *)(arg1)->GetShader();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_UVTransformNode_SetTextureOffset(void * jarg1, void * jarg2) {
  UVTransformNode *arg1 = (UVTransformNode *) 0 ;
  Math::Vector2 *arg2 = 0 ;
  
  arg1 = (UVTransformNode *)jarg1; 
  arg2 = (Math::Vector2 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector2 const & type is null", 0);
    return ;
  } 
  (arg1)->SetTextureOffset((Math::Vector2 const &)*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_UVTransformNode_SetTextureScale(void * jarg1, void * jarg2) {
  UVTransformNode *arg1 = (UVTransformNode *) 0 ;
  Math::Vector2 *arg2 = 0 ;
  
  arg1 = (UVTransformNode *)jarg1; 
  arg2 = (Math::Vector2 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector2 const & type is null", 0);
    return ;
  } 
  (arg1)->SetTextureScale((Math::Vector2 const &)*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_UVTransformNode_SetTextureOffsetU(void * jarg1, float jarg2) {
  UVTransformNode *arg1 = (UVTransformNode *) 0 ;
  float arg2 ;
  
  arg1 = (UVTransformNode *)jarg1; 
  arg2 = (float)jarg2; 
  (arg1)->SetTextureOffsetU(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_UVTransformNode_SetTextureOffsetV(void * jarg1, float jarg2) {
  UVTransformNode *arg1 = (UVTransformNode *) 0 ;
  float arg2 ;
  
  arg1 = (UVTransformNode *)jarg1; 
  arg2 = (float)jarg2; 
  (arg1)->SetTextureOffsetV(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_UVTransformNode_SetTextureScaleX(void * jarg1, float jarg2) {
  UVTransformNode *arg1 = (UVTransformNode *) 0 ;
  float arg2 ;
  
  arg1 = (UVTransformNode *)jarg1; 
  arg2 = (float)jarg2; 
  (arg1)->SetTextureScaleX(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_UVTransformNode_SetTextureScaleY(void * jarg1, float jarg2) {
  UVTransformNode *arg1 = (UVTransformNode *) 0 ;
  float arg2 ;
  
  arg1 = (UVTransformNode *)jarg1; 
  arg2 = (float)jarg2; 
  (arg1)->SetTextureScaleY(arg2);
}


SWIGEXPORT float SWIGSTDCALL CSharp_UVTransformNode_GetTextureOffsetU(void * jarg1) {
  float jresult ;
  UVTransformNode *arg1 = (UVTransformNode *) 0 ;
  float result;
  
  arg1 = (UVTransformNode *)jarg1; 
  result = (float)(arg1)->GetTextureOffsetU();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_UVTransformNode_GetTextureOffsetY(void * jarg1) {
  float jresult ;
  UVTransformNode *arg1 = (UVTransformNode *) 0 ;
  float result;
  
  arg1 = (UVTransformNode *)jarg1; 
  result = (float)(arg1)->GetTextureOffsetY();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_UVTransformNode_GetTextureScaleX(void * jarg1) {
  float jresult ;
  UVTransformNode *arg1 = (UVTransformNode *) 0 ;
  float result;
  
  arg1 = (UVTransformNode *)jarg1; 
  result = (float)(arg1)->GetTextureScaleX();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_UVTransformNode_GetTextureScaleY(void * jarg1) {
  float jresult ;
  UVTransformNode *arg1 = (UVTransformNode *) 0 ;
  float result;
  
  arg1 = (UVTransformNode *)jarg1; 
  result = (float)(arg1)->GetTextureScaleY();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_UVTransformNode_GetTextureOffset(void * jarg1) {
  void * jresult ;
  UVTransformNode *arg1 = (UVTransformNode *) 0 ;
  Math::Vector2 result;
  
  arg1 = (UVTransformNode *)jarg1; 
  result = (arg1)->GetTextureOffset();
  jresult = new Math::Vector2((const Math::Vector2 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_UVTransformNode_GetTextureScale(void * jarg1) {
  void * jresult ;
  UVTransformNode *arg1 = (UVTransformNode *) 0 ;
  Math::Vector2 result;
  
  arg1 = (UVTransformNode *)jarg1; 
  result = (arg1)->GetTextureScale();
  jresult = new Math::Vector2((const Math::Vector2 &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_MaterialAttribNodeVector_Clear(void * jarg1) {
  std::vector< MatAttribNode * > *arg1 = (std::vector< MatAttribNode * > *) 0 ;
  
  arg1 = (std::vector< MatAttribNode * > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_MaterialAttribNodeVector_Add(void * jarg1, void * jarg2) {
  std::vector< MatAttribNode * > *arg1 = (std::vector< MatAttribNode * > *) 0 ;
  MatAttribNode **arg2 = 0 ;
  MatAttribNode *temp2 = 0 ;
  
  arg1 = (std::vector< MatAttribNode * > *)jarg1; 
  temp2 = (MatAttribNode *)jarg2;
  arg2 = (MatAttribNode **)&temp2; 
  (arg1)->push_back((MatAttribNode *const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_MaterialAttribNodeVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< MatAttribNode * > *arg1 = (std::vector< MatAttribNode * > *) 0 ;
  std::vector< MatAttribNode * >::size_type result;
  
  arg1 = (std::vector< MatAttribNode * > *)jarg1; 
  result = ((std::vector< MatAttribNode * > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_MaterialAttribNodeVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< MatAttribNode * > *arg1 = (std::vector< MatAttribNode * > *) 0 ;
  std::vector< MatAttribNode * >::size_type result;
  
  arg1 = (std::vector< MatAttribNode * > *)jarg1; 
  result = ((std::vector< MatAttribNode * > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_MaterialAttribNodeVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< MatAttribNode * > *arg1 = (std::vector< MatAttribNode * > *) 0 ;
  std::vector< MatAttribNode * >::size_type arg2 ;
  
  arg1 = (std::vector< MatAttribNode * > *)jarg1; 
  arg2 = (std::vector< MatAttribNode * >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_MaterialAttribNodeVector__SWIG_0() {
  void * jresult ;
  std::vector< MatAttribNode * > *result = 0 ;
  
  result = (std::vector< MatAttribNode * > *)new std::vector< MatAttribNode * >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_MaterialAttribNodeVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< MatAttribNode * > *arg1 = 0 ;
  std::vector< MatAttribNode * > *result = 0 ;
  
  arg1 = (std::vector< MatAttribNode * > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< MatAttribNode * > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< MatAttribNode * > *)new std::vector< MatAttribNode * >((std::vector< MatAttribNode * > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_MaterialAttribNodeVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< MatAttribNode * > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< MatAttribNode * > *)new_std_vector_Sl_MatAttribNode_Sm__Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MaterialAttribNodeVector_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< MatAttribNode * > *arg1 = (std::vector< MatAttribNode * > *) 0 ;
  int arg2 ;
  MatAttribNode *result = 0 ;
  
  arg1 = (std::vector< MatAttribNode * > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (MatAttribNode *)std_vector_Sl_MatAttribNode_Sm__Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MaterialAttribNodeVector_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< MatAttribNode * > *arg1 = (std::vector< MatAttribNode * > *) 0 ;
  int arg2 ;
  MatAttribNode **result = 0 ;
  
  arg1 = (std::vector< MatAttribNode * > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (MatAttribNode **) &std_vector_Sl_MatAttribNode_Sm__Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)*result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_MaterialAttribNodeVector_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< MatAttribNode * > *arg1 = (std::vector< MatAttribNode * > *) 0 ;
  int arg2 ;
  MatAttribNode **arg3 = 0 ;
  MatAttribNode *temp3 = 0 ;
  
  arg1 = (std::vector< MatAttribNode * > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (MatAttribNode *)jarg3;
  arg3 = (MatAttribNode **)&temp3; 
  try {
    std_vector_Sl_MatAttribNode_Sm__Sg__setitem(arg1,arg2,(MatAttribNode *const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_MaterialAttribNodeVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< MatAttribNode * > *arg1 = (std::vector< MatAttribNode * > *) 0 ;
  std::vector< MatAttribNode * > *arg2 = 0 ;
  
  arg1 = (std::vector< MatAttribNode * > *)jarg1; 
  arg2 = (std::vector< MatAttribNode * > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< MatAttribNode * > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_MatAttribNode_Sm__Sg__AddRange(arg1,(std::vector< MatAttribNode * > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MaterialAttribNodeVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< MatAttribNode * > *arg1 = (std::vector< MatAttribNode * > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< MatAttribNode * > *result = 0 ;
  
  arg1 = (std::vector< MatAttribNode * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< MatAttribNode * > *)std_vector_Sl_MatAttribNode_Sm__Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_MaterialAttribNodeVector_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< MatAttribNode * > *arg1 = (std::vector< MatAttribNode * > *) 0 ;
  int arg2 ;
  MatAttribNode **arg3 = 0 ;
  MatAttribNode *temp3 = 0 ;
  
  arg1 = (std::vector< MatAttribNode * > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (MatAttribNode *)jarg3;
  arg3 = (MatAttribNode **)&temp3; 
  try {
    std_vector_Sl_MatAttribNode_Sm__Sg__Insert(arg1,arg2,(MatAttribNode *const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_MaterialAttribNodeVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< MatAttribNode * > *arg1 = (std::vector< MatAttribNode * > *) 0 ;
  int arg2 ;
  std::vector< MatAttribNode * > *arg3 = 0 ;
  
  arg1 = (std::vector< MatAttribNode * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< MatAttribNode * > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< MatAttribNode * > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_MatAttribNode_Sm__Sg__InsertRange(arg1,arg2,(std::vector< MatAttribNode * > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_MaterialAttribNodeVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< MatAttribNode * > *arg1 = (std::vector< MatAttribNode * > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< MatAttribNode * > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_MatAttribNode_Sm__Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_MaterialAttribNodeVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< MatAttribNode * > *arg1 = (std::vector< MatAttribNode * > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< MatAttribNode * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_MatAttribNode_Sm__Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MaterialAttribNodeVector_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  MatAttribNode **arg1 = 0 ;
  int arg2 ;
  MatAttribNode *temp1 = 0 ;
  std::vector< MatAttribNode * > *result = 0 ;
  
  temp1 = (MatAttribNode *)jarg1;
  arg1 = (MatAttribNode **)&temp1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< MatAttribNode * > *)std_vector_Sl_MatAttribNode_Sm__Sg__Repeat((MatAttribNode *const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_MaterialAttribNodeVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< MatAttribNode * > *arg1 = (std::vector< MatAttribNode * > *) 0 ;
  
  arg1 = (std::vector< MatAttribNode * > *)jarg1; 
  std_vector_Sl_MatAttribNode_Sm__Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_MaterialAttribNodeVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< MatAttribNode * > *arg1 = (std::vector< MatAttribNode * > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< MatAttribNode * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_MatAttribNode_Sm__Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_MaterialAttribNodeVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< MatAttribNode * > *arg1 = (std::vector< MatAttribNode * > *) 0 ;
  int arg2 ;
  std::vector< MatAttribNode * > *arg3 = 0 ;
  
  arg1 = (std::vector< MatAttribNode * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< MatAttribNode * > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< MatAttribNode * > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_MatAttribNode_Sm__Sg__SetRange(arg1,arg2,(std::vector< MatAttribNode * > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_MaterialAttribNodeVector_Contains(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::vector< MatAttribNode * > *arg1 = (std::vector< MatAttribNode * > *) 0 ;
  MatAttribNode **arg2 = 0 ;
  MatAttribNode *temp2 = 0 ;
  bool result;
  
  arg1 = (std::vector< MatAttribNode * > *)jarg1; 
  temp2 = (MatAttribNode *)jarg2;
  arg2 = (MatAttribNode **)&temp2; 
  result = (bool)std_vector_Sl_MatAttribNode_Sm__Sg__Contains(arg1,(MatAttribNode *const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_MaterialAttribNodeVector_IndexOf(void * jarg1, void * jarg2) {
  int jresult ;
  std::vector< MatAttribNode * > *arg1 = (std::vector< MatAttribNode * > *) 0 ;
  MatAttribNode **arg2 = 0 ;
  MatAttribNode *temp2 = 0 ;
  int result;
  
  arg1 = (std::vector< MatAttribNode * > *)jarg1; 
  temp2 = (MatAttribNode *)jarg2;
  arg2 = (MatAttribNode **)&temp2; 
  result = (int)std_vector_Sl_MatAttribNode_Sm__Sg__IndexOf(arg1,(MatAttribNode *const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_MaterialAttribNodeVector_LastIndexOf(void * jarg1, void * jarg2) {
  int jresult ;
  std::vector< MatAttribNode * > *arg1 = (std::vector< MatAttribNode * > *) 0 ;
  MatAttribNode **arg2 = 0 ;
  MatAttribNode *temp2 = 0 ;
  int result;
  
  arg1 = (std::vector< MatAttribNode * > *)jarg1; 
  temp2 = (MatAttribNode *)jarg2;
  arg2 = (MatAttribNode **)&temp2; 
  result = (int)std_vector_Sl_MatAttribNode_Sm__Sg__LastIndexOf(arg1,(MatAttribNode *const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_MaterialAttribNodeVector_Remove(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::vector< MatAttribNode * > *arg1 = (std::vector< MatAttribNode * > *) 0 ;
  MatAttribNode **arg2 = 0 ;
  MatAttribNode *temp2 = 0 ;
  bool result;
  
  arg1 = (std::vector< MatAttribNode * > *)jarg1; 
  temp2 = (MatAttribNode *)jarg2;
  arg2 = (MatAttribNode **)&temp2; 
  result = (bool)std_vector_Sl_MatAttribNode_Sm__Sg__Remove(arg1,(MatAttribNode *const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_MaterialAttribNodeVector(void * jarg1) {
  std::vector< MatAttribNode * > *arg1 = (std::vector< MatAttribNode * > *) 0 ;
  
  arg1 = (std::vector< MatAttribNode * > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_MaterialAttribNodeMap__SWIG_0() {
  void * jresult ;
  std::map< unsigned int,std::vector< MatAttribNode * > > *result = 0 ;
  
  result = (std::map< unsigned int,std::vector< MatAttribNode * > > *)new std::map< unsigned int,std::vector< MatAttribNode * > >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_MaterialAttribNodeMap__SWIG_1(void * jarg1) {
  void * jresult ;
  std::map< unsigned int,std::vector< MatAttribNode * >,std::less< unsigned int > > *arg1 = 0 ;
  std::map< unsigned int,std::vector< MatAttribNode * > > *result = 0 ;
  
  arg1 = (std::map< unsigned int,std::vector< MatAttribNode * >,std::less< unsigned int > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::map< unsigned int,std::vector< MatAttribNode * >,std::less< unsigned int > > const & type is null", 0);
    return 0;
  } 
  result = (std::map< unsigned int,std::vector< MatAttribNode * > > *)new std::map< unsigned int,std::vector< MatAttribNode * > >((std::map< unsigned int,std::vector< MatAttribNode * >,std::less< unsigned int > > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_MaterialAttribNodeMap_size(void * jarg1) {
  unsigned long jresult ;
  std::map< unsigned int,std::vector< MatAttribNode * > > *arg1 = (std::map< unsigned int,std::vector< MatAttribNode * > > *) 0 ;
  std::map< unsigned int,std::vector< MatAttribNode * > >::size_type result;
  
  arg1 = (std::map< unsigned int,std::vector< MatAttribNode * > > *)jarg1; 
  result = ((std::map< unsigned int,std::vector< MatAttribNode * > > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_MaterialAttribNodeMap_empty(void * jarg1) {
  unsigned int jresult ;
  std::map< unsigned int,std::vector< MatAttribNode * > > *arg1 = (std::map< unsigned int,std::vector< MatAttribNode * > > *) 0 ;
  bool result;
  
  arg1 = (std::map< unsigned int,std::vector< MatAttribNode * > > *)jarg1; 
  result = (bool)((std::map< unsigned int,std::vector< MatAttribNode * > > const *)arg1)->empty();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_MaterialAttribNodeMap_Clear(void * jarg1) {
  std::map< unsigned int,std::vector< MatAttribNode * > > *arg1 = (std::map< unsigned int,std::vector< MatAttribNode * > > *) 0 ;
  
  arg1 = (std::map< unsigned int,std::vector< MatAttribNode * > > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MaterialAttribNodeMap_getitem(void * jarg1, unsigned int jarg2) {
  void * jresult ;
  std::map< unsigned int,std::vector< MatAttribNode * > > *arg1 = (std::map< unsigned int,std::vector< MatAttribNode * > > *) 0 ;
  std::map< unsigned int,std::vector< MatAttribNode * > >::key_type *arg2 = 0 ;
  std::map< unsigned int,std::vector< MatAttribNode * > >::key_type temp2 ;
  std::map< unsigned int,std::vector< MatAttribNode * > >::mapped_type *result = 0 ;
  
  arg1 = (std::map< unsigned int,std::vector< MatAttribNode * > > *)jarg1; 
  temp2 = (std::map< unsigned int,std::vector< MatAttribNode * > >::key_type)jarg2; 
  arg2 = &temp2; 
  try {
    result = (std::map< unsigned int,std::vector< MatAttribNode * > >::mapped_type *) &std_map_Sl_unsigned_SS_int_Sc_std_vector_Sl_MatAttribNode_Sm__Sg__Sg__getitem(arg1,(unsigned int const &)*arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_MaterialAttribNodeMap_setitem(void * jarg1, unsigned int jarg2, void * jarg3) {
  std::map< unsigned int,std::vector< MatAttribNode * > > *arg1 = (std::map< unsigned int,std::vector< MatAttribNode * > > *) 0 ;
  std::map< unsigned int,std::vector< MatAttribNode * > >::key_type *arg2 = 0 ;
  std::map< unsigned int,std::vector< MatAttribNode * > >::mapped_type *arg3 = 0 ;
  std::map< unsigned int,std::vector< MatAttribNode * > >::key_type temp2 ;
  
  arg1 = (std::map< unsigned int,std::vector< MatAttribNode * > > *)jarg1; 
  temp2 = (std::map< unsigned int,std::vector< MatAttribNode * > >::key_type)jarg2; 
  arg2 = &temp2; 
  arg3 = (std::map< unsigned int,std::vector< MatAttribNode * > >::mapped_type *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::map< unsigned int,std::vector< MatAttribNode * > >::mapped_type const & type is null", 0);
    return ;
  } 
  std_map_Sl_unsigned_SS_int_Sc_std_vector_Sl_MatAttribNode_Sm__Sg__Sg__setitem(arg1,(unsigned int const &)*arg2,(std::vector< MatAttribNode * > const &)*arg3);
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_MaterialAttribNodeMap_ContainsKey(void * jarg1, unsigned int jarg2) {
  unsigned int jresult ;
  std::map< unsigned int,std::vector< MatAttribNode * > > *arg1 = (std::map< unsigned int,std::vector< MatAttribNode * > > *) 0 ;
  std::map< unsigned int,std::vector< MatAttribNode * > >::key_type *arg2 = 0 ;
  std::map< unsigned int,std::vector< MatAttribNode * > >::key_type temp2 ;
  bool result;
  
  arg1 = (std::map< unsigned int,std::vector< MatAttribNode * > > *)jarg1; 
  temp2 = (std::map< unsigned int,std::vector< MatAttribNode * > >::key_type)jarg2; 
  arg2 = &temp2; 
  result = (bool)std_map_Sl_unsigned_SS_int_Sc_std_vector_Sl_MatAttribNode_Sm__Sg__Sg__ContainsKey(arg1,(unsigned int const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_MaterialAttribNodeMap_Add(void * jarg1, unsigned int jarg2, void * jarg3) {
  std::map< unsigned int,std::vector< MatAttribNode * > > *arg1 = (std::map< unsigned int,std::vector< MatAttribNode * > > *) 0 ;
  std::map< unsigned int,std::vector< MatAttribNode * > >::key_type *arg2 = 0 ;
  std::map< unsigned int,std::vector< MatAttribNode * > >::mapped_type *arg3 = 0 ;
  std::map< unsigned int,std::vector< MatAttribNode * > >::key_type temp2 ;
  
  arg1 = (std::map< unsigned int,std::vector< MatAttribNode * > > *)jarg1; 
  temp2 = (std::map< unsigned int,std::vector< MatAttribNode * > >::key_type)jarg2; 
  arg2 = &temp2; 
  arg3 = (std::map< unsigned int,std::vector< MatAttribNode * > >::mapped_type *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::map< unsigned int,std::vector< MatAttribNode * > >::mapped_type const & type is null", 0);
    return ;
  } 
  try {
    std_map_Sl_unsigned_SS_int_Sc_std_vector_Sl_MatAttribNode_Sm__Sg__Sg__Add(arg1,(unsigned int const &)*arg2,(std::vector< MatAttribNode * > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_MaterialAttribNodeMap_Remove(void * jarg1, unsigned int jarg2) {
  unsigned int jresult ;
  std::map< unsigned int,std::vector< MatAttribNode * > > *arg1 = (std::map< unsigned int,std::vector< MatAttribNode * > > *) 0 ;
  std::map< unsigned int,std::vector< MatAttribNode * > >::key_type *arg2 = 0 ;
  std::map< unsigned int,std::vector< MatAttribNode * > >::key_type temp2 ;
  bool result;
  
  arg1 = (std::map< unsigned int,std::vector< MatAttribNode * > > *)jarg1; 
  temp2 = (std::map< unsigned int,std::vector< MatAttribNode * > >::key_type)jarg2; 
  arg2 = &temp2; 
  result = (bool)std_map_Sl_unsigned_SS_int_Sc_std_vector_Sl_MatAttribNode_Sm__Sg__Sg__Remove(arg1,(unsigned int const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MaterialAttribNodeMap_create_iterator_begin(void * jarg1) {
  void * jresult ;
  std::map< unsigned int,std::vector< MatAttribNode * > > *arg1 = (std::map< unsigned int,std::vector< MatAttribNode * > > *) 0 ;
  std::map< unsigned int,std::vector< MatAttribNode * >,std::less< unsigned int > >::iterator *result = 0 ;
  
  arg1 = (std::map< unsigned int,std::vector< MatAttribNode * > > *)jarg1; 
  result = (std::map< unsigned int,std::vector< MatAttribNode * >,std::less< unsigned int > >::iterator *)std_map_Sl_unsigned_SS_int_Sc_std_vector_Sl_MatAttribNode_Sm__Sg__Sg__create_iterator_begin(arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_MaterialAttribNodeMap_get_next_key(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::map< unsigned int,std::vector< MatAttribNode * > > *arg1 = (std::map< unsigned int,std::vector< MatAttribNode * > > *) 0 ;
  std::map< unsigned int,std::vector< MatAttribNode * >,std::less< unsigned int > >::iterator *arg2 = (std::map< unsigned int,std::vector< MatAttribNode * >,std::less< unsigned int > >::iterator *) 0 ;
  std::map< unsigned int,std::vector< MatAttribNode * > >::key_type *result = 0 ;
  
  arg1 = (std::map< unsigned int,std::vector< MatAttribNode * > > *)jarg1; 
  arg2 = (std::map< unsigned int,std::vector< MatAttribNode * >,std::less< unsigned int > >::iterator *)jarg2; 
  result = (std::map< unsigned int,std::vector< MatAttribNode * > >::key_type *) &std_map_Sl_unsigned_SS_int_Sc_std_vector_Sl_MatAttribNode_Sm__Sg__Sg__get_next_key(arg1,arg2);
  jresult = *result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_MaterialAttribNodeMap_destroy_iterator(void * jarg1, void * jarg2) {
  std::map< unsigned int,std::vector< MatAttribNode * > > *arg1 = (std::map< unsigned int,std::vector< MatAttribNode * > > *) 0 ;
  std::map< unsigned int,std::vector< MatAttribNode * >,std::less< unsigned int > >::iterator *arg2 = (std::map< unsigned int,std::vector< MatAttribNode * >,std::less< unsigned int > >::iterator *) 0 ;
  
  arg1 = (std::map< unsigned int,std::vector< MatAttribNode * > > *)jarg1; 
  arg2 = (std::map< unsigned int,std::vector< MatAttribNode * >,std::less< unsigned int > >::iterator *)jarg2; 
  std_map_Sl_unsigned_SS_int_Sc_std_vector_Sl_MatAttribNode_Sm__Sg__Sg__destroy_iterator(arg1,arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_MaterialAttribNodeMap(void * jarg1) {
  std::map< unsigned int,std::vector< MatAttribNode * > > *arg1 = (std::map< unsigned int,std::vector< MatAttribNode * > > *) 0 ;
  
  arg1 = (std::map< unsigned int,std::vector< MatAttribNode * > > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_MaterialImpl_mAttributeMetaLookup_set(void * jarg1, void * jarg2) {
  MaterialImpl *arg1 = (MaterialImpl *) 0 ;
  MaterialImpl::AttributeMetaLookup *arg2 = (MaterialImpl::AttributeMetaLookup *) 0 ;
  
  arg1 = (MaterialImpl *)jarg1; 
  arg2 = (MaterialImpl::AttributeMetaLookup *)jarg2; 
  if (arg1) (arg1)->mAttributeMetaLookup = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_MaterialImpl_mAttributeMetaLookup_get(void * jarg1) {
  void * jresult ;
  MaterialImpl *arg1 = (MaterialImpl *) 0 ;
  MaterialImpl::AttributeMetaLookup *result = 0 ;
  
  arg1 = (MaterialImpl *)jarg1; 
  result = (MaterialImpl::AttributeMetaLookup *)& ((arg1)->mAttributeMetaLookup);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_FrameController_GetDeltaTime(void * jarg1) {
  float jresult ;
  FrameController *arg1 = (FrameController *) 0 ;
  float result;
  
  arg1 = (FrameController *)jarg1; 
  result = (float)(arg1)->GetDeltaTime();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_FrameController_CapOn(void * jarg1, float jarg2) {
  FrameController *arg1 = (FrameController *) 0 ;
  float arg2 ;
  
  arg1 = (FrameController *)jarg1; 
  arg2 = (float)jarg2; 
  (arg1)->CapOn(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_FrameController_CapOff(void * jarg1) {
  FrameController *arg1 = (FrameController *) 0 ;
  
  arg1 = (FrameController *)jarg1; 
  (arg1)->CapOff();
}


SWIGEXPORT float SWIGSTDCALL CSharp_FrameController_FPSMax(void * jarg1) {
  float jresult ;
  FrameController *arg1 = (FrameController *) 0 ;
  float result;
  
  arg1 = (FrameController *)jarg1; 
  result = (float)((FrameController const *)arg1)->FPSMax();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_FrameController_getInstance() {
  void * jresult ;
  FrameController *result = 0 ;
  
  result = (FrameController *)FrameController::getInstance();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_FrameController_DT() {
  float jresult ;
  float result;
  
  result = (float)FrameController::DT();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_Input_GetReleased(int jarg1, char * jarg2) {
  float jresult ;
  int arg1 ;
  std::string arg2 ;
  float result;
  
  arg1 = (int)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  (&arg2)->assign(jarg2); 
  result = (float)Input::GetReleased(arg1,arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_Input_GetTriggered(int jarg1, char * jarg2) {
  float jresult ;
  int arg1 ;
  std::string arg2 ;
  float result;
  
  arg1 = (int)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  (&arg2)->assign(jarg2); 
  result = (float)Input::GetTriggered(arg1,arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_Input_GetHeld(int jarg1, char * jarg2) {
  float jresult ;
  int arg1 ;
  std::string arg2 ;
  float result;
  
  arg1 = (int)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  (&arg2)->assign(jarg2); 
  result = (float)Input::GetHeld(arg1,arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_Input_GetValue(int jarg1, char * jarg2) {
  float jresult ;
  int arg1 ;
  std::string arg2 ;
  float result;
  
  arg1 = (int)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  (&arg2)->assign(jarg2); 
  result = (float)Input::GetValue(arg1,arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_Input_GetMouseX(unsigned int jarg1) {
  int jresult ;
  bool arg1 ;
  int result;
  
  arg1 = jarg1 ? true : false; 
  result = (int)Input::GetMouseX(arg1);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_Input_GetMouseY(unsigned int jarg1) {
  int jresult ;
  bool arg1 ;
  int result;
  
  arg1 = jarg1 ? true : false; 
  result = (int)Input::GetMouseY(arg1);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_Input_GetMouseDeltaX() {
  int jresult ;
  int result;
  
  result = (int)Input::GetMouseDeltaX();
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_Input_GetMouseDeltaY() {
  int jresult ;
  int result;
  
  result = (int)Input::GetMouseDeltaY();
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_Input_GetMouseWheelDeltaY() {
  int jresult ;
  int result;
  
  result = (int)Input::GetMouseWheelDeltaY();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Input_SetMouseLock(unsigned int jarg1) {
  bool arg1 ;
  
  arg1 = jarg1 ? true : false; 
  Input::SetMouseLock(arg1);
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_Input_GetLockMouse() {
  unsigned int jresult ;
  bool result;
  
  result = (bool)Input::GetLockMouse();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Input_SetMouseVisible(unsigned int jarg1) {
  bool arg1 ;
  
  arg1 = jarg1 ? true : false; 
  Input::SetMouseVisible(arg1);
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_Input_GetMouseVisible() {
  unsigned int jresult ;
  bool result;
  
  result = (bool)Input::GetMouseVisible();
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_Input_GetIsMouseInWindow(unsigned int jarg1) {
  unsigned int jresult ;
  bool arg1 ;
  bool result;
  
  arg1 = jarg1 ? true : false; 
  result = (bool)Input::GetIsMouseInWindow(arg1);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_Input_IsPlayerUsingKeyboard(int jarg1) {
  unsigned int jresult ;
  int arg1 ;
  bool result;
  
  arg1 = (int)jarg1; 
  result = (bool)Input::IsPlayerUsingKeyboard(arg1);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_Input_GetCtrlAltDel() {
  unsigned int jresult ;
  bool result;
  
  result = (bool)Input::GetCtrlAltDel();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_RayCastResult_hit_set(void * jarg1, unsigned int jarg2) {
  RayCastResult *arg1 = (RayCastResult *) 0 ;
  bool arg2 ;
  
  arg1 = (RayCastResult *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->hit = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_RayCastResult_hit_get(void * jarg1) {
  unsigned int jresult ;
  RayCastResult *arg1 = (RayCastResult *) 0 ;
  bool result;
  
  arg1 = (RayCastResult *)jarg1; 
  result = (bool) ((arg1)->hit);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_RayCastResult_t_set(void * jarg1, float jarg2) {
  RayCastResult *arg1 = (RayCastResult *) 0 ;
  float arg2 ;
  
  arg1 = (RayCastResult *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->t = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_RayCastResult_t_get(void * jarg1) {
  float jresult ;
  RayCastResult *arg1 = (RayCastResult *) 0 ;
  float result;
  
  arg1 = (RayCastResult *)jarg1; 
  result = (float) ((arg1)->t);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_RayCastResult_intersection_set(void * jarg1, void * jarg2) {
  RayCastResult *arg1 = (RayCastResult *) 0 ;
  Math::Vector3 *arg2 = (Math::Vector3 *) 0 ;
  
  arg1 = (RayCastResult *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2; 
  if (arg1) (arg1)->intersection = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_RayCastResult_intersection_get(void * jarg1) {
  void * jresult ;
  RayCastResult *arg1 = (RayCastResult *) 0 ;
  Math::Vector3 *result = 0 ;
  
  arg1 = (RayCastResult *)jarg1; 
  result = (Math::Vector3 *)& ((arg1)->intersection);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_RayCastResult_normal_set(void * jarg1, void * jarg2) {
  RayCastResult *arg1 = (RayCastResult *) 0 ;
  Math::Vector3 *arg2 = (Math::Vector3 *) 0 ;
  
  arg1 = (RayCastResult *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2; 
  if (arg1) (arg1)->normal = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_RayCastResult_normal_get(void * jarg1) {
  void * jresult ;
  RayCastResult *arg1 = (RayCastResult *) 0 ;
  Math::Vector3 *result = 0 ;
  
  arg1 = (RayCastResult *)jarg1; 
  result = (Math::Vector3 *)& ((arg1)->normal);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_RayCastResult_collider_set(void * jarg1, void * jarg2) {
  RayCastResult *arg1 = (RayCastResult *) 0 ;
  Collider *arg2 = (Collider *) 0 ;
  
  arg1 = (RayCastResult *)jarg1; 
  arg2 = (Collider *)jarg2; 
  if (arg1) (arg1)->collider = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_RayCastResult_collider_get(void * jarg1) {
  void * jresult ;
  RayCastResult *arg1 = (RayCastResult *) 0 ;
  Collider *result = 0 ;
  
  arg1 = (RayCastResult *)jarg1; 
  result = (Collider *) ((arg1)->collider);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_RayCastResult_go_set(void * jarg1, void * jarg2) {
  RayCastResult *arg1 = (RayCastResult *) 0 ;
  GameObject *arg2 = (GameObject *) 0 ;
  
  arg1 = (RayCastResult *)jarg1; 
  arg2 = (GameObject *)jarg2; 
  if (arg1) (arg1)->go = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_RayCastResult_go_get(void * jarg1) {
  void * jresult ;
  RayCastResult *arg1 = (RayCastResult *) 0 ;
  GameObject *result = 0 ;
  
  arg1 = (RayCastResult *)jarg1; 
  result = (GameObject *) ((arg1)->go);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_PhysicEngine_DragObject(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  PhysicEngine *arg1 = (PhysicEngine *) 0 ;
  Point3 arg2 ;
  Point3 arg3 ;
  Point3 *argp2 ;
  Point3 *argp3 ;
  GameObject *result = 0 ;
  
  arg1 = (PhysicEngine *)jarg1; 
  argp2 = (Point3 *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null Point3", 0);
    return 0;
  }
  arg2 = *argp2; 
  argp3 = (Point3 *)jarg3; 
  if (!argp3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null Point3", 0);
    return 0;
  }
  arg3 = *argp3; 
  result = (GameObject *)(arg1)->DragObject(arg2,arg3);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_PhysicEngine_DragObject_DoRaycast(void * jarg1, void * jarg2, void * jarg3, void * jarg4, float jarg5) {
  void * jresult ;
  PhysicEngine *arg1 = (PhysicEngine *) 0 ;
  Point3 arg2 ;
  Point3 arg3 ;
  GameObject *arg4 = (GameObject *) 0 ;
  float arg5 ;
  Point3 *argp2 ;
  Point3 *argp3 ;
  GameObject *result = 0 ;
  
  arg1 = (PhysicEngine *)jarg1; 
  argp2 = (Point3 *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null Point3", 0);
    return 0;
  }
  arg2 = *argp2; 
  argp3 = (Point3 *)jarg3; 
  if (!argp3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null Point3", 0);
    return 0;
  }
  arg3 = *argp3; 
  arg4 = (GameObject *)jarg4; 
  arg5 = (float)jarg5; 
  result = (GameObject *)(arg1)->DragObject_DoRaycast(arg2,arg3,arg4,arg5);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_PhysicEngine_RayCasting(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  void * jresult ;
  PhysicEngine *arg1 = (PhysicEngine *) 0 ;
  Point3 arg2 ;
  Point3 arg3 ;
  Color arg4 ;
  Point3 *argp2 ;
  Point3 *argp3 ;
  Color *argp4 ;
  GameObject *result = 0 ;
  
  arg1 = (PhysicEngine *)jarg1; 
  argp2 = (Point3 *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null Point3", 0);
    return 0;
  }
  arg2 = *argp2; 
  argp3 = (Point3 *)jarg3; 
  if (!argp3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null Point3", 0);
    return 0;
  }
  arg3 = *argp3; 
  argp4 = (Color *)jarg4; 
  if (!argp4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null Color", 0);
    return 0;
  }
  arg4 = *argp4; 
  result = (GameObject *)(arg1)->RayCasting(arg2,arg3,arg4);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_PhysicEngine_RayCast(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  void * jresult ;
  PhysicEngine *arg1 = (PhysicEngine *) 0 ;
  Point3 arg2 ;
  Vector arg3 ;
  Color arg4 ;
  Point3 *argp2 ;
  Vector *argp3 ;
  Color *argp4 ;
  GameObject *result = 0 ;
  
  arg1 = (PhysicEngine *)jarg1; 
  argp2 = (Point3 *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null Point3", 0);
    return 0;
  }
  arg2 = *argp2; 
  argp3 = (Vector *)jarg3; 
  if (!argp3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null Vector", 0);
    return 0;
  }
  arg3 = *argp3; 
  argp4 = (Color *)jarg4; 
  if (!argp4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null Color", 0);
    return 0;
  }
  arg4 = *argp4; 
  result = (GameObject *)(arg1)->RayCast(arg2,arg3,arg4);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_PhysicEngine_RayCast3D__SWIG_0(void * jarg1, void * jarg2, void * jarg3, float jarg4) {
  void * jresult ;
  PhysicEngine *arg1 = (PhysicEngine *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  Math::Vector3 *arg3 = 0 ;
  float arg4 ;
  GameObject *result = 0 ;
  
  arg1 = (PhysicEngine *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return 0;
  } 
  arg3 = (Math::Vector3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return 0;
  } 
  arg4 = (float)jarg4; 
  result = (GameObject *)(arg1)->RayCast3D((Math::Vector3 const &)*arg2,(Math::Vector3 const &)*arg3,arg4);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_PhysicEngine_RayCast3D__SWIG_1(void * jarg1, void * jarg2, void * jarg3, void * jarg4, int jarg5, int jarg6, float jarg7) {
  void * jresult ;
  PhysicEngine *arg1 = (PhysicEngine *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  Math::Vector3 *arg3 = 0 ;
  CCamera *arg4 = (CCamera *) 0 ;
  int arg5 ;
  int arg6 ;
  float arg7 ;
  GameObject *result = 0 ;
  
  arg1 = (PhysicEngine *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return 0;
  } 
  arg3 = (Math::Vector3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return 0;
  } 
  arg4 = (CCamera *)jarg4; 
  arg5 = (int)jarg5; 
  arg6 = (int)jarg6; 
  arg7 = (float)jarg7; 
  result = (GameObject *)(arg1)->RayCast3D((Math::Vector3 const &)*arg2,(Math::Vector3 const &)*arg3,arg4,arg5,arg6,arg7);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_PhysicEngine_RayCast3DWithTag__SWIG_0(void * jarg1, void * jarg2, void * jarg3, void * jarg4, int jarg5, int jarg6, float jarg7, char * jarg8) {
  void * jresult ;
  PhysicEngine *arg1 = (PhysicEngine *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  Math::Vector3 *arg3 = 0 ;
  CCamera *arg4 = (CCamera *) 0 ;
  int arg5 ;
  int arg6 ;
  float arg7 ;
  std::string arg8 ;
  GameObject *result = 0 ;
  
  arg1 = (PhysicEngine *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return 0;
  } 
  arg3 = (Math::Vector3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return 0;
  } 
  arg4 = (CCamera *)jarg4; 
  arg5 = (int)jarg5; 
  arg6 = (int)jarg6; 
  arg7 = (float)jarg7; 
  if (!jarg8) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  (&arg8)->assign(jarg8); 
  result = (GameObject *)(arg1)->RayCast3DWithTag((Math::Vector3 const &)*arg2,(Math::Vector3 const &)*arg3,arg4,arg5,arg6,arg7,arg8);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_PhysicEngine_RayCast3DWithTag__SWIG_1(void * jarg1, void * jarg2, void * jarg3, float jarg4, char * jarg5) {
  void * jresult ;
  PhysicEngine *arg1 = (PhysicEngine *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  Math::Vector3 *arg3 = 0 ;
  float arg4 ;
  std::string arg5 ;
  GameObject *result = 0 ;
  
  arg1 = (PhysicEngine *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return 0;
  } 
  arg3 = (Math::Vector3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return 0;
  } 
  arg4 = (float)jarg4; 
  if (!jarg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  (&arg5)->assign(jarg5); 
  result = (GameObject *)(arg1)->RayCast3DWithTag((Math::Vector3 const &)*arg2,(Math::Vector3 const &)*arg3,arg4,arg5);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_PhysicEngine_RayCast3D_Output(void * jarg1, void * jarg2, void * jarg3, float jarg4) {
  void * jresult ;
  PhysicEngine *arg1 = (PhysicEngine *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  Math::Vector3 *arg3 = 0 ;
  float arg4 ;
  SwigValueWrapper< RayCastResult > result;
  
  arg1 = (PhysicEngine *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return 0;
  } 
  arg3 = (Math::Vector3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return 0;
  } 
  arg4 = (float)jarg4; 
  result = (arg1)->RayCast3D_Output((Math::Vector3 const &)*arg2,(Math::Vector3 const &)*arg3,arg4);
  jresult = new RayCastResult((const RayCastResult &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_PhysicEngine_RayCast3DWithTag_Output(void * jarg1, void * jarg2, void * jarg3, float jarg4, void * jarg5) {
  void * jresult ;
  PhysicEngine *arg1 = (PhysicEngine *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  Math::Vector3 *arg3 = 0 ;
  float arg4 ;
  std::string *arg5 = 0 ;
  SwigValueWrapper< RayCastResult > result;
  
  arg1 = (PhysicEngine *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return 0;
  } 
  arg3 = (Math::Vector3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return 0;
  } 
  arg4 = (float)jarg4; 
  arg5 = (std::string *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::string & type is null", 0);
    return 0;
  } 
  result = (arg1)->RayCast3DWithTag_Output((Math::Vector3 const &)*arg2,(Math::Vector3 const &)*arg3,arg4,*arg5);
  jresult = new RayCastResult((const RayCastResult &)result); 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_PhysicEngine_IsActive__SWIG_0(void * jarg1) {
  unsigned int jresult ;
  PhysicEngine *arg1 = (PhysicEngine *) 0 ;
  bool result;
  
  arg1 = (PhysicEngine *)jarg1; 
  result = (bool)((PhysicEngine const *)arg1)->IsActive();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_PhysicEngine_IsActive__SWIG_1(void * jarg1, unsigned int jarg2) {
  PhysicEngine *arg1 = (PhysicEngine *) 0 ;
  bool arg2 ;
  
  arg1 = (PhysicEngine *)jarg1; 
  arg2 = jarg2 ? true : false; 
  (arg1)->IsActive(arg2);
}


SWIGEXPORT float SWIGSTDCALL CSharp_PhysicEngine_GetTimeStep(void * jarg1) {
  float jresult ;
  PhysicEngine *arg1 = (PhysicEngine *) 0 ;
  float result;
  
  arg1 = (PhysicEngine *)jarg1; 
  result = (float)((PhysicEngine const *)arg1)->GetTimeStep();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_PhysicEngine_GetGravity(void * jarg1) {
  void * jresult ;
  PhysicEngine *arg1 = (PhysicEngine *) 0 ;
  Vector *result = 0 ;
  
  arg1 = (PhysicEngine *)jarg1; 
  result = (Vector *) &((PhysicEngine const *)arg1)->GetGravity();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_PhysicEngine_getInstance() {
  void * jresult ;
  PhysicEngine *result = 0 ;
  
  result = (PhysicEngine *)PhysicEngine::getInstance();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_KeyFrame_Time_set(void * jarg1, float jarg2) {
  KeyFrame *arg1 = (KeyFrame *) 0 ;
  float arg2 ;
  
  arg1 = (KeyFrame *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->Time = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_KeyFrame_Time_get(void * jarg1) {
  float jresult ;
  KeyFrame *arg1 = (KeyFrame *) 0 ;
  float result;
  
  arg1 = (KeyFrame *)jarg1; 
  result = (float) ((arg1)->Time);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_KeyFrame_LocalTransform_set(void * jarg1, void * jarg2) {
  KeyFrame *arg1 = (KeyFrame *) 0 ;
  VQS arg2 ;
  VQS *argp2 ;
  
  arg1 = (KeyFrame *)jarg1; 
  argp2 = (VQS *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null VQS", 0);
    return ;
  }
  arg2 = *argp2; 
  if (arg1) (arg1)->LocalTransform = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_KeyFrame_LocalTransform_get(void * jarg1) {
  void * jresult ;
  KeyFrame *arg1 = (KeyFrame *) 0 ;
  VQS result;
  
  arg1 = (KeyFrame *)jarg1; 
  result =  ((arg1)->LocalTransform);
  jresult = new VQS((const VQS &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_KeyFrame() {
  void * jresult ;
  KeyFrame *result = 0 ;
  
  result = (KeyFrame *)new KeyFrame();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_KeyFrame(void * jarg1) {
  KeyFrame *arg1 = (KeyFrame *) 0 ;
  
  arg1 = (KeyFrame *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Track_mKeyFrames_set(void * jarg1, void * jarg2) {
  Track *arg1 = (Track *) 0 ;
  std::vector< KeyFrame > *arg2 = (std::vector< KeyFrame > *) 0 ;
  
  arg1 = (Track *)jarg1; 
  arg2 = (std::vector< KeyFrame > *)jarg2; 
  if (arg1) (arg1)->mKeyFrames = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Track_mKeyFrames_get(void * jarg1) {
  void * jresult ;
  Track *arg1 = (Track *) 0 ;
  std::vector< KeyFrame > *result = 0 ;
  
  arg1 = (Track *)jarg1; 
  result = (std::vector< KeyFrame > *)& ((arg1)->mKeyFrames);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Track() {
  void * jresult ;
  Track *result = 0 ;
  
  result = (Track *)new Track();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_Track(void * jarg1) {
  Track *arg1 = (Track *) 0 ;
  
  arg1 = (Track *)jarg1; 
  delete arg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Animation__SWIG_0(char * jarg1) {
  void * jresult ;
  std::string arg1 ;
  Animation *result = 0 ;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  (&arg1)->assign(jarg1); 
  result = (Animation *)new Animation(arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Animation__SWIG_1() {
  void * jresult ;
  Animation *result = 0 ;
  
  result = (Animation *)new Animation();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Animation_OnAssetFileChanged(void * jarg1) {
  Animation *arg1 = (Animation *) 0 ;
  
  arg1 = (Animation *)jarg1; 
  (arg1)->OnAssetFileChanged();
}


SWIGEXPORT float SWIGSTDCALL CSharp_Animation_GetDuration(void * jarg1) {
  float jresult ;
  Animation *arg1 = (Animation *) 0 ;
  float result;
  
  arg1 = (Animation *)jarg1; 
  result = (float)((Animation const *)arg1)->GetDuration();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Animation_GetTracks(void * jarg1) {
  void * jresult ;
  Animation *arg1 = (Animation *) 0 ;
  std::vector< Track > *result = 0 ;
  
  arg1 = (Animation *)jarg1; 
  result = (std::vector< Track > *) &(arg1)->GetTracks();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT char * SWIGSTDCALL CSharp_Animation_GetName(void * jarg1) {
  char * jresult ;
  Animation *arg1 = (Animation *) 0 ;
  std::string result;
  
  arg1 = (Animation *)jarg1; 
  result = (arg1)->GetName();
  jresult = SWIG_csharp_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_OculusVR_IsConnected(void * jarg1) {
  unsigned int jresult ;
  OculusVR *arg1 = (OculusVR *) 0 ;
  bool result;
  
  arg1 = (OculusVR *)jarg1; 
  result = (bool)(arg1)->IsConnected();
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_OculusVR_GetRecommendedWidth(void * jarg1) {
  unsigned int jresult ;
  OculusVR *arg1 = (OculusVR *) 0 ;
  unsigned int result;
  
  arg1 = (OculusVR *)jarg1; 
  result = (unsigned int)(arg1)->GetRecommendedWidth();
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_OculusVR_GetRecommendedHeight(void * jarg1) {
  unsigned int jresult ;
  OculusVR *arg1 = (OculusVR *) 0 ;
  unsigned int result;
  
  arg1 = (OculusVR *)jarg1; 
  result = (unsigned int)(arg1)->GetRecommendedHeight();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_OculusVR_getInstance() {
  void * jresult ;
  OculusVR *result = 0 ;
  
  result = (OculusVR *)OculusVR::getInstance();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_OculusVR_GetEyePos(void * jarg1, unsigned int jarg2) {
  void * jresult ;
  OculusVR *arg1 = (OculusVR *) 0 ;
  unsigned int arg2 ;
  Math::Vector3 result;
  
  arg1 = (OculusVR *)jarg1; 
  arg2 = (unsigned int)jarg2; 
  result = (arg1)->GetEyePos(arg2);
  jresult = new Math::Vector3((const Math::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_OculusVR() {
  void * jresult ;
  OculusVR *result = 0 ;
  
  result = (OculusVR *)new OculusVR();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_OculusVR(void * jarg1) {
  OculusVR *arg1 = (OculusVR *) 0 ;
  
  arg1 = (OculusVR *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Renderer_mGlobalAmbient_set(void * jarg1, void * jarg2) {
  Renderer *arg1 = (Renderer *) 0 ;
  Math::Vector4 *arg2 = (Math::Vector4 *) 0 ;
  
  arg1 = (Renderer *)jarg1; 
  arg2 = (Math::Vector4 *)jarg2; 
  if (arg1) (arg1)->mGlobalAmbient = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Renderer_mGlobalAmbient_get(void * jarg1) {
  void * jresult ;
  Renderer *arg1 = (Renderer *) 0 ;
  Math::Vector4 *result = 0 ;
  
  arg1 = (Renderer *)jarg1; 
  result = (Math::Vector4 *)& ((arg1)->mGlobalAmbient);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Renderer_getInstance() {
  void * jresult ;
  Renderer *result = 0 ;
  
  result = (Renderer *)Renderer::getInstance();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Renderer_DrawBoxPerma__SWIG_0(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  Renderer *arg1 = (Renderer *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  Math::Vector3 *arg3 = 0 ;
  Color *arg4 = 0 ;
  
  arg1 = (Renderer *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  arg3 = (Math::Vector3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  arg4 = (Color *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Color const & type is null", 0);
    return ;
  } 
  (arg1)->DrawBoxPerma((Math::Vector3 const &)*arg2,(Math::Vector3 const &)*arg3,(Color const &)*arg4);
}


SWIGEXPORT void SWIGSTDCALL CSharp_Renderer_DrawBoxPerma__SWIG_1(void * jarg1, void * jarg2, void * jarg3) {
  Renderer *arg1 = (Renderer *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  Math::Vector3 *arg3 = 0 ;
  
  arg1 = (Renderer *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  arg3 = (Math::Vector3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  (arg1)->DrawBoxPerma((Math::Vector3 const &)*arg2,(Math::Vector3 const &)*arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_Renderer_DrawLine(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  Renderer *arg1 = (Renderer *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  Math::Vector3 *arg3 = 0 ;
  Color *arg4 = 0 ;
  
  arg1 = (Renderer *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  arg3 = (Math::Vector3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  arg4 = (Color *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Color const & type is null", 0);
    return ;
  } 
  (arg1)->DrawLine((Math::Vector3 const &)*arg2,(Math::Vector3 const &)*arg3,(Color const &)*arg4);
}


SWIGEXPORT void SWIGSTDCALL CSharp_Renderer_DrawLinePerma(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  Renderer *arg1 = (Renderer *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  Math::Vector3 *arg3 = 0 ;
  Color *arg4 = 0 ;
  
  arg1 = (Renderer *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  arg3 = (Math::Vector3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  arg4 = (Color *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Color const & type is null", 0);
    return ;
  } 
  (arg1)->DrawLinePerma((Math::Vector3 const &)*arg2,(Math::Vector3 const &)*arg3,(Color const &)*arg4);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Renderer() {
  void * jresult ;
  Renderer *result = 0 ;
  
  result = (Renderer *)new Renderer();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_Renderer(void * jarg1) {
  Renderer *arg1 = (Renderer *) 0 ;
  
  arg1 = (Renderer *)jarg1; 
  delete arg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Prefab_MakePrefabFrom(void * jarg1) {
  void * jresult ;
  GameObject *arg1 = (GameObject *) 0 ;
  Prefab *result = 0 ;
  
  arg1 = (GameObject *)jarg1; 
  result = (Prefab *)Prefab::MakePrefabFrom(arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Prefab_name_set(void * jarg1, char * jarg2) {
  Prefab *arg1 = (Prefab *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (Prefab *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  if (arg1) (arg1)->name = *arg2;
}


SWIGEXPORT char * SWIGSTDCALL CSharp_Prefab_name_get(void * jarg1) {
  char * jresult ;
  Prefab *arg1 = (Prefab *) 0 ;
  std::string *result = 0 ;
  
  arg1 = (Prefab *)jarg1; 
  result = (std::string *) & ((arg1)->name);
  jresult = SWIG_csharp_string_callback(result->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Prefab_filename_set(void * jarg1, char * jarg2) {
  Prefab *arg1 = (Prefab *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (Prefab *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  if (arg1) (arg1)->filename = *arg2;
}


SWIGEXPORT char * SWIGSTDCALL CSharp_Prefab_filename_get(void * jarg1) {
  char * jresult ;
  Prefab *arg1 = (Prefab *) 0 ;
  std::string *result = 0 ;
  
  arg1 = (Prefab *)jarg1; 
  result = (std::string *) & ((arg1)->filename);
  jresult = SWIG_csharp_string_callback(result->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Prefab_isTransient_set(void * jarg1, unsigned int jarg2) {
  Prefab *arg1 = (Prefab *) 0 ;
  bool arg2 ;
  
  arg1 = (Prefab *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->isTransient = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_Prefab_isTransient_get(void * jarg1) {
  unsigned int jresult ;
  Prefab *arg1 = (Prefab *) 0 ;
  bool result;
  
  arg1 = (Prefab *)jarg1; 
  result = (bool) ((arg1)->isTransient);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Prefab_stringBuf_set(void * jarg1, char * jarg2) {
  Prefab *arg1 = (Prefab *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (Prefab *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  if (arg1) (arg1)->stringBuf = *arg2;
}


SWIGEXPORT char * SWIGSTDCALL CSharp_Prefab_stringBuf_get(void * jarg1) {
  char * jresult ;
  Prefab *arg1 = (Prefab *) 0 ;
  std::string *result = 0 ;
  
  arg1 = (Prefab *)jarg1; 
  result = (std::string *) & ((arg1)->stringBuf);
  jresult = SWIG_csharp_string_callback(result->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Prefab_dormantObject_set(void * jarg1, void * jarg2) {
  Prefab *arg1 = (Prefab *) 0 ;
  GameObject *arg2 = (GameObject *) 0 ;
  
  arg1 = (Prefab *)jarg1; 
  arg2 = (GameObject *)jarg2; 
  if (arg1) (arg1)->dormantObject = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Prefab_dormantObject_get(void * jarg1) {
  void * jresult ;
  Prefab *arg1 = (Prefab *) 0 ;
  GameObject *result = 0 ;
  
  arg1 = (Prefab *)jarg1; 
  result = (GameObject *) ((arg1)->dormantObject);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Prefab_CreateInstance(void * jarg1, void * jarg2) {
  Prefab *arg1 = (Prefab *) 0 ;
  GameObject *arg2 = (GameObject *) 0 ;
  
  arg1 = (Prefab *)jarg1; 
  arg2 = (GameObject *)jarg2; 
  ((Prefab const *)arg1)->CreateInstance(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_Prefab_Rename(void * jarg1, void * jarg2) {
  Prefab *arg1 = (Prefab *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (Prefab *)jarg1; 
  arg2 = (std::string *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::string & type is null", 0);
    return ;
  } 
  (arg1)->Rename(*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_AudioManager_PlayAll(void * jarg1) {
  AudioManager *arg1 = (AudioManager *) 0 ;
  
  arg1 = (AudioManager *)jarg1; 
  (arg1)->PlayAll();
}


SWIGEXPORT void SWIGSTDCALL CSharp_AudioManager_StopAll(void * jarg1) {
  AudioManager *arg1 = (AudioManager *) 0 ;
  
  arg1 = (AudioManager *)jarg1; 
  (arg1)->StopAll();
}


SWIGEXPORT void SWIGSTDCALL CSharp_AudioManager_ResumeAll(void * jarg1) {
  AudioManager *arg1 = (AudioManager *) 0 ;
  
  arg1 = (AudioManager *)jarg1; 
  (arg1)->ResumeAll();
}


SWIGEXPORT void SWIGSTDCALL CSharp_AudioManager_PauseAll(void * jarg1) {
  AudioManager *arg1 = (AudioManager *) 0 ;
  
  arg1 = (AudioManager *)jarg1; 
  (arg1)->PauseAll();
}


SWIGEXPORT void SWIGSTDCALL CSharp_AudioManager_SetMusicVolume(void * jarg1, float jarg2) {
  AudioManager *arg1 = (AudioManager *) 0 ;
  float arg2 ;
  
  arg1 = (AudioManager *)jarg1; 
  arg2 = (float)jarg2; 
  (arg1)->SetMusicVolume(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_AudioManager_SetSoundVolume(void * jarg1, float jarg2) {
  AudioManager *arg1 = (AudioManager *) 0 ;
  float arg2 ;
  
  arg1 = (AudioManager *)jarg1; 
  arg2 = (float)jarg2; 
  (arg1)->SetSoundVolume(arg2);
}


SWIGEXPORT float SWIGSTDCALL CSharp_AudioManager_GetMusicVolume(void * jarg1) {
  float jresult ;
  AudioManager *arg1 = (AudioManager *) 0 ;
  float result;
  
  arg1 = (AudioManager *)jarg1; 
  result = (float)((AudioManager const *)arg1)->GetMusicVolume();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_AudioManager_GetSoundVolume(void * jarg1) {
  float jresult ;
  AudioManager *arg1 = (AudioManager *) 0 ;
  float result;
  
  arg1 = (AudioManager *)jarg1; 
  result = (float)((AudioManager const *)arg1)->GetSoundVolume();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_AudioManager_SetMuteMusic(void * jarg1, unsigned int jarg2) {
  AudioManager *arg1 = (AudioManager *) 0 ;
  bool arg2 ;
  
  arg1 = (AudioManager *)jarg1; 
  arg2 = jarg2 ? true : false; 
  (arg1)->SetMuteMusic(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_AudioManager_SetMuteSound(void * jarg1, unsigned int jarg2) {
  AudioManager *arg1 = (AudioManager *) 0 ;
  bool arg2 ;
  
  arg1 = (AudioManager *)jarg1; 
  arg2 = jarg2 ? true : false; 
  (arg1)->SetMuteSound(arg2);
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_AudioManager_GetMuteMusic(void * jarg1) {
  unsigned int jresult ;
  AudioManager *arg1 = (AudioManager *) 0 ;
  bool result;
  
  arg1 = (AudioManager *)jarg1; 
  result = (bool)((AudioManager const *)arg1)->GetMuteMusic();
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_AudioManager_GetMuteSound(void * jarg1) {
  unsigned int jresult ;
  AudioManager *arg1 = (AudioManager *) 0 ;
  bool result;
  
  arg1 = (AudioManager *)jarg1; 
  result = (bool)((AudioManager const *)arg1)->GetMuteSound();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_AudioManager_getInstance() {
  void * jresult ;
  AudioManager *result = 0 ;
  
  result = (AudioManager *)AudioManager::getInstance();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_Component_isEnabled(void * jarg1) {
  unsigned int jresult ;
  Component *arg1 = (Component *) 0 ;
  bool result;
  
  arg1 = (Component *)jarg1; 
  result = (bool)(arg1)->isEnabled();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Component_setEnabled(void * jarg1, unsigned int jarg2) {
  Component *arg1 = (Component *) 0 ;
  bool arg2 ;
  
  arg1 = (Component *)jarg1; 
  arg2 = jarg2 ? true : false; 
  (arg1)->setEnabled(arg2);
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_Component_globalEnabled(void * jarg1) {
  unsigned int jresult ;
  Component *arg1 = (Component *) 0 ;
  bool result;
  
  arg1 = (Component *)jarg1; 
  result = (bool)(arg1)->globalEnabled();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Component_gameObject_set(void * jarg1, void * jarg2) {
  Component *arg1 = (Component *) 0 ;
  GameObject *arg2 = (GameObject *) 0 ;
  
  arg1 = (Component *)jarg1; 
  arg2 = (GameObject *)jarg2; 
  if (arg1) (arg1)->gameObject = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Component_gameObject_get(void * jarg1) {
  void * jresult ;
  Component *arg1 = (Component *) 0 ;
  GameObject *result = 0 ;
  
  arg1 = (Component *)jarg1; 
  result = (GameObject *) ((arg1)->gameObject);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Component_myType_set(void * jarg1, char * jarg2) {
  Component *arg1 = (Component *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (Component *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  if (arg1) (arg1)->myType = *arg2;
}


SWIGEXPORT char * SWIGSTDCALL CSharp_Component_myType_get(void * jarg1) {
  char * jresult ;
  Component *arg1 = (Component *) 0 ;
  std::string *result = 0 ;
  
  arg1 = (Component *)jarg1; 
  result = (std::string *) & ((arg1)->myType);
  jresult = SWIG_csharp_string_callback(result->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Component_CopyFrom(void * jarg1, void * jarg2) {
  Component *arg1 = (Component *) 0 ;
  ::Component *arg2 = (::Component *) 0 ;
  
  arg1 = (Component *)jarg1; 
  arg2 = (::Component *)jarg2; 
  (arg1)->CopyFrom((::Component const *)arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_Component_Destroy(void * jarg1) {
  Component *arg1 = (Component *) 0 ;
  
  arg1 = (Component *)jarg1; 
  (arg1)->Destroy();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransformVector_Clear(void * jarg1) {
  std::vector< CTransform * > *arg1 = (std::vector< CTransform * > *) 0 ;
  
  arg1 = (std::vector< CTransform * > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransformVector_Add(void * jarg1, void * jarg2) {
  std::vector< CTransform * > *arg1 = (std::vector< CTransform * > *) 0 ;
  CTransform **arg2 = 0 ;
  CTransform *temp2 = 0 ;
  
  arg1 = (std::vector< CTransform * > *)jarg1; 
  temp2 = (CTransform *)jarg2;
  arg2 = (CTransform **)&temp2; 
  (arg1)->push_back((CTransform *const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CTransformVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< CTransform * > *arg1 = (std::vector< CTransform * > *) 0 ;
  std::vector< CTransform * >::size_type result;
  
  arg1 = (std::vector< CTransform * > *)jarg1; 
  result = ((std::vector< CTransform * > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CTransformVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< CTransform * > *arg1 = (std::vector< CTransform * > *) 0 ;
  std::vector< CTransform * >::size_type result;
  
  arg1 = (std::vector< CTransform * > *)jarg1; 
  result = ((std::vector< CTransform * > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransformVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< CTransform * > *arg1 = (std::vector< CTransform * > *) 0 ;
  std::vector< CTransform * >::size_type arg2 ;
  
  arg1 = (std::vector< CTransform * > *)jarg1; 
  arg2 = (std::vector< CTransform * >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_CTransformVector__SWIG_0() {
  void * jresult ;
  std::vector< CTransform * > *result = 0 ;
  
  result = (std::vector< CTransform * > *)new std::vector< CTransform * >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_CTransformVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< CTransform * > *arg1 = 0 ;
  std::vector< CTransform * > *result = 0 ;
  
  arg1 = (std::vector< CTransform * > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CTransform * > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< CTransform * > *)new std::vector< CTransform * >((std::vector< CTransform * > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_CTransformVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< CTransform * > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< CTransform * > *)new_std_vector_Sl_CTransform_Sm__Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CTransformVector_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< CTransform * > *arg1 = (std::vector< CTransform * > *) 0 ;
  int arg2 ;
  CTransform *result = 0 ;
  
  arg1 = (std::vector< CTransform * > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (CTransform *)std_vector_Sl_CTransform_Sm__Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CTransformVector_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< CTransform * > *arg1 = (std::vector< CTransform * > *) 0 ;
  int arg2 ;
  CTransform **result = 0 ;
  
  arg1 = (std::vector< CTransform * > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (CTransform **) &std_vector_Sl_CTransform_Sm__Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)*result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransformVector_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< CTransform * > *arg1 = (std::vector< CTransform * > *) 0 ;
  int arg2 ;
  CTransform **arg3 = 0 ;
  CTransform *temp3 = 0 ;
  
  arg1 = (std::vector< CTransform * > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (CTransform *)jarg3;
  arg3 = (CTransform **)&temp3; 
  try {
    std_vector_Sl_CTransform_Sm__Sg__setitem(arg1,arg2,(CTransform *const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransformVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< CTransform * > *arg1 = (std::vector< CTransform * > *) 0 ;
  std::vector< CTransform * > *arg2 = 0 ;
  
  arg1 = (std::vector< CTransform * > *)jarg1; 
  arg2 = (std::vector< CTransform * > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CTransform * > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_CTransform_Sm__Sg__AddRange(arg1,(std::vector< CTransform * > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CTransformVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< CTransform * > *arg1 = (std::vector< CTransform * > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< CTransform * > *result = 0 ;
  
  arg1 = (std::vector< CTransform * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< CTransform * > *)std_vector_Sl_CTransform_Sm__Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransformVector_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< CTransform * > *arg1 = (std::vector< CTransform * > *) 0 ;
  int arg2 ;
  CTransform **arg3 = 0 ;
  CTransform *temp3 = 0 ;
  
  arg1 = (std::vector< CTransform * > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (CTransform *)jarg3;
  arg3 = (CTransform **)&temp3; 
  try {
    std_vector_Sl_CTransform_Sm__Sg__Insert(arg1,arg2,(CTransform *const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransformVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< CTransform * > *arg1 = (std::vector< CTransform * > *) 0 ;
  int arg2 ;
  std::vector< CTransform * > *arg3 = 0 ;
  
  arg1 = (std::vector< CTransform * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< CTransform * > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CTransform * > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_CTransform_Sm__Sg__InsertRange(arg1,arg2,(std::vector< CTransform * > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransformVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< CTransform * > *arg1 = (std::vector< CTransform * > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< CTransform * > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_CTransform_Sm__Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransformVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< CTransform * > *arg1 = (std::vector< CTransform * > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< CTransform * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_CTransform_Sm__Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CTransformVector_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  CTransform **arg1 = 0 ;
  int arg2 ;
  CTransform *temp1 = 0 ;
  std::vector< CTransform * > *result = 0 ;
  
  temp1 = (CTransform *)jarg1;
  arg1 = (CTransform **)&temp1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< CTransform * > *)std_vector_Sl_CTransform_Sm__Sg__Repeat((CTransform *const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransformVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< CTransform * > *arg1 = (std::vector< CTransform * > *) 0 ;
  
  arg1 = (std::vector< CTransform * > *)jarg1; 
  std_vector_Sl_CTransform_Sm__Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransformVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< CTransform * > *arg1 = (std::vector< CTransform * > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< CTransform * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_CTransform_Sm__Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransformVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< CTransform * > *arg1 = (std::vector< CTransform * > *) 0 ;
  int arg2 ;
  std::vector< CTransform * > *arg3 = 0 ;
  
  arg1 = (std::vector< CTransform * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< CTransform * > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CTransform * > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_CTransform_Sm__Sg__SetRange(arg1,arg2,(std::vector< CTransform * > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CTransformVector_Contains(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::vector< CTransform * > *arg1 = (std::vector< CTransform * > *) 0 ;
  CTransform **arg2 = 0 ;
  CTransform *temp2 = 0 ;
  bool result;
  
  arg1 = (std::vector< CTransform * > *)jarg1; 
  temp2 = (CTransform *)jarg2;
  arg2 = (CTransform **)&temp2; 
  result = (bool)std_vector_Sl_CTransform_Sm__Sg__Contains(arg1,(CTransform *const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CTransformVector_IndexOf(void * jarg1, void * jarg2) {
  int jresult ;
  std::vector< CTransform * > *arg1 = (std::vector< CTransform * > *) 0 ;
  CTransform **arg2 = 0 ;
  CTransform *temp2 = 0 ;
  int result;
  
  arg1 = (std::vector< CTransform * > *)jarg1; 
  temp2 = (CTransform *)jarg2;
  arg2 = (CTransform **)&temp2; 
  result = (int)std_vector_Sl_CTransform_Sm__Sg__IndexOf(arg1,(CTransform *const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CTransformVector_LastIndexOf(void * jarg1, void * jarg2) {
  int jresult ;
  std::vector< CTransform * > *arg1 = (std::vector< CTransform * > *) 0 ;
  CTransform **arg2 = 0 ;
  CTransform *temp2 = 0 ;
  int result;
  
  arg1 = (std::vector< CTransform * > *)jarg1; 
  temp2 = (CTransform *)jarg2;
  arg2 = (CTransform **)&temp2; 
  result = (int)std_vector_Sl_CTransform_Sm__Sg__LastIndexOf(arg1,(CTransform *const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CTransformVector_Remove(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::vector< CTransform * > *arg1 = (std::vector< CTransform * > *) 0 ;
  CTransform **arg2 = 0 ;
  CTransform *temp2 = 0 ;
  bool result;
  
  arg1 = (std::vector< CTransform * > *)jarg1; 
  temp2 = (CTransform *)jarg2;
  arg2 = (CTransform **)&temp2; 
  result = (bool)std_vector_Sl_CTransform_Sm__Sg__Remove(arg1,(CTransform *const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_CTransformVector(void * jarg1) {
  std::vector< CTransform * > *arg1 = (std::vector< CTransform * > *) 0 ;
  
  arg1 = (std::vector< CTransform * > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransform_localPosition_set(void * jarg1, void * jarg2) {
  CTransform *arg1 = (CTransform *) 0 ;
  Math::Vector3 *arg2 = (Math::Vector3 *) 0 ;
  
  arg1 = (CTransform *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2; 
  if (arg1) (arg1)->localPosition = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CTransform_localPosition_get(void * jarg1) {
  void * jresult ;
  CTransform *arg1 = (CTransform *) 0 ;
  Math::Vector3 *result = 0 ;
  
  arg1 = (CTransform *)jarg1; 
  result = (Math::Vector3 *)& ((arg1)->localPosition);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransform_scale_set(void * jarg1, void * jarg2) {
  CTransform *arg1 = (CTransform *) 0 ;
  Math::Vector3 *arg2 = (Math::Vector3 *) 0 ;
  
  arg1 = (CTransform *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2; 
  if (arg1) (arg1)->scale = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CTransform_scale_get(void * jarg1) {
  void * jresult ;
  CTransform *arg1 = (CTransform *) 0 ;
  Math::Vector3 *result = 0 ;
  
  arg1 = (CTransform *)jarg1; 
  result = (Math::Vector3 *)& ((arg1)->scale);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransform_rotation_set(void * jarg1, void * jarg2) {
  CTransform *arg1 = (CTransform *) 0 ;
  Math::EulerAngles *arg2 = (Math::EulerAngles *) 0 ;
  
  arg1 = (CTransform *)jarg1; 
  arg2 = (Math::EulerAngles *)jarg2; 
  if (arg1) (arg1)->rotation = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CTransform_rotation_get(void * jarg1) {
  void * jresult ;
  CTransform *arg1 = (CTransform *) 0 ;
  Math::EulerAngles *result = 0 ;
  
  arg1 = (CTransform *)jarg1; 
  result = (Math::EulerAngles *)& ((arg1)->rotation);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CTransform_GetForwardVector(void * jarg1) {
  void * jresult ;
  CTransform *arg1 = (CTransform *) 0 ;
  Math::Vector3 result;
  
  arg1 = (CTransform *)jarg1; 
  result = (arg1)->GetForwardVector();
  jresult = new Math::Vector3((const Math::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CTransform_GetUpVector(void * jarg1) {
  void * jresult ;
  CTransform *arg1 = (CTransform *) 0 ;
  Math::Vector3 result;
  
  arg1 = (CTransform *)jarg1; 
  result = (arg1)->GetUpVector();
  jresult = new Math::Vector3((const Math::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CTransform_GetRightVector(void * jarg1) {
  void * jresult ;
  CTransform *arg1 = (CTransform *) 0 ;
  Math::Vector3 result;
  
  arg1 = (CTransform *)jarg1; 
  result = (arg1)->GetRightVector();
  jresult = new Math::Vector3((const Math::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CTransform_GetGlobalPosition(void * jarg1) {
  void * jresult ;
  CTransform *arg1 = (CTransform *) 0 ;
  Math::Vector3 result;
  
  arg1 = (CTransform *)jarg1; 
  result = (arg1)->GetGlobalPosition();
  jresult = new Math::Vector3((const Math::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransform_LookAt__SWIG_0(void * jarg1, void * jarg2, void * jarg3) {
  CTransform *arg1 = (CTransform *) 0 ;
  Math::Vector3 *arg2 = (Math::Vector3 *) 0 ;
  Math::Vector3 arg3 ;
  Math::Vector3 *argp3 ;
  
  arg1 = (CTransform *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2; 
  argp3 = (Math::Vector3 *)jarg3; 
  if (!argp3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null Math::Vector3", 0);
    return ;
  }
  arg3 = *argp3; 
  (arg1)->LookAt((Math::Vector3 const *)arg2,arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransform_LookAt__SWIG_1(void * jarg1, void * jarg2) {
  CTransform *arg1 = (CTransform *) 0 ;
  Math::Vector3 *arg2 = (Math::Vector3 *) 0 ;
  
  arg1 = (CTransform *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2; 
  (arg1)->LookAt((Math::Vector3 const *)arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransform_Rotate__SWIG_0(void * jarg1, float jarg2, float jarg3, float jarg4, int jarg5) {
  CTransform *arg1 = (CTransform *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  CTransform::TransformSpace arg5 ;
  
  arg1 = (CTransform *)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  arg5 = (CTransform::TransformSpace)jarg5; 
  (arg1)->Rotate(arg2,arg3,arg4,arg5);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransform_Rotate__SWIG_1(void * jarg1, float jarg2, float jarg3, float jarg4) {
  CTransform *arg1 = (CTransform *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  arg1 = (CTransform *)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  (arg1)->Rotate(arg2,arg3,arg4);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransform_Rotate__SWIG_2(void * jarg1, void * jarg2, int jarg3) {
  CTransform *arg1 = (CTransform *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  CTransform::TransformSpace arg3 ;
  
  arg1 = (CTransform *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  arg3 = (CTransform::TransformSpace)jarg3; 
  (arg1)->Rotate((Math::Vector3 const &)*arg2,arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransform_Rotate__SWIG_3(void * jarg1, void * jarg2) {
  CTransform *arg1 = (CTransform *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  
  arg1 = (CTransform *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  (arg1)->Rotate((Math::Vector3 const &)*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransform_SetRotation__SWIG_0(void * jarg1, void * jarg2, float jarg3, int jarg4) {
  CTransform *arg1 = (CTransform *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  float arg3 ;
  CTransform::TransformSpace arg4 ;
  
  arg1 = (CTransform *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  arg3 = (float)jarg3; 
  arg4 = (CTransform::TransformSpace)jarg4; 
  (arg1)->SetRotation((Math::Vector3 const &)*arg2,arg3,arg4);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransform_SetRotation__SWIG_1(void * jarg1, void * jarg2, float jarg3) {
  CTransform *arg1 = (CTransform *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  float arg3 ;
  
  arg1 = (CTransform *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  arg3 = (float)jarg3; 
  (arg1)->SetRotation((Math::Vector3 const &)*arg2,arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransform_SetRotation__SWIG_2(void * jarg1, float jarg2, float jarg3, float jarg4, float jarg5, int jarg6) {
  CTransform *arg1 = (CTransform *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  CTransform::TransformSpace arg6 ;
  
  arg1 = (CTransform *)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  arg5 = (float)jarg5; 
  arg6 = (CTransform::TransformSpace)jarg6; 
  (arg1)->SetRotation(arg2,arg3,arg4,arg5,arg6);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransform_SetRotation__SWIG_3(void * jarg1, float jarg2, float jarg3, float jarg4, float jarg5) {
  CTransform *arg1 = (CTransform *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  
  arg1 = (CTransform *)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  arg5 = (float)jarg5; 
  (arg1)->SetRotation(arg2,arg3,arg4,arg5);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CTransform_GetConstrainedRotation(void * jarg1) {
  void * jresult ;
  CTransform *arg1 = (CTransform *) 0 ;
  Math::Vector3 result;
  
  arg1 = (CTransform *)jarg1; 
  result = (arg1)->GetConstrainedRotation();
  jresult = new Math::Vector3((const Math::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CTransform_GetRotation__SWIG_0(void * jarg1, int jarg2) {
  void * jresult ;
  CTransform *arg1 = (CTransform *) 0 ;
  CTransform::TransformSpace arg2 ;
  Math::Vector3 result;
  
  arg1 = (CTransform *)jarg1; 
  arg2 = (CTransform::TransformSpace)jarg2; 
  result = (arg1)->GetRotation(arg2);
  jresult = new Math::Vector3((const Math::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CTransform_GetRotation__SWIG_1(void * jarg1) {
  void * jresult ;
  CTransform *arg1 = (CTransform *) 0 ;
  Math::Vector3 result;
  
  arg1 = (CTransform *)jarg1; 
  result = (arg1)->GetRotation();
  jresult = new Math::Vector3((const Math::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransform_RotateAround__SWIG_0(void * jarg1, float jarg2, float jarg3, float jarg4, float jarg5, int jarg6) {
  CTransform *arg1 = (CTransform *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  CTransform::TransformSpace arg6 ;
  
  arg1 = (CTransform *)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  arg5 = (float)jarg5; 
  arg6 = (CTransform::TransformSpace)jarg6; 
  (arg1)->RotateAround(arg2,arg3,arg4,arg5,arg6);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransform_RotateAround__SWIG_1(void * jarg1, float jarg2, float jarg3, float jarg4, float jarg5) {
  CTransform *arg1 = (CTransform *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  
  arg1 = (CTransform *)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  arg5 = (float)jarg5; 
  (arg1)->RotateAround(arg2,arg3,arg4,arg5);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransform_RotateAround__SWIG_2(void * jarg1, void * jarg2, float jarg3, int jarg4) {
  CTransform *arg1 = (CTransform *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  float arg3 ;
  CTransform::TransformSpace arg4 ;
  
  arg1 = (CTransform *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  arg3 = (float)jarg3; 
  arg4 = (CTransform::TransformSpace)jarg4; 
  (arg1)->RotateAround((Math::Vector3 const &)*arg2,arg3,arg4);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransform_RotateAround__SWIG_3(void * jarg1, void * jarg2, float jarg3) {
  CTransform *arg1 = (CTransform *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  float arg3 ;
  
  arg1 = (CTransform *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  arg3 = (float)jarg3; 
  (arg1)->RotateAround((Math::Vector3 const &)*arg2,arg3);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CTransform_GetPosition(void * jarg1, int jarg2) {
  void * jresult ;
  CTransform *arg1 = (CTransform *) 0 ;
  CTransform::TransformSpace arg2 ;
  Math::Vector3 result;
  
  arg1 = (CTransform *)jarg1; 
  arg2 = (CTransform::TransformSpace)jarg2; 
  result = (arg1)->GetPosition(arg2);
  jresult = new Math::Vector3((const Math::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransform_SetPosition__SWIG_0(void * jarg1, void * jarg2, int jarg3) {
  CTransform *arg1 = (CTransform *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  CTransform::TransformSpace arg3 ;
  
  arg1 = (CTransform *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  arg3 = (CTransform::TransformSpace)jarg3; 
  (arg1)->SetPosition((Math::Vector3 const &)*arg2,arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransform_SetPosition__SWIG_1(void * jarg1, void * jarg2) {
  CTransform *arg1 = (CTransform *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  
  arg1 = (CTransform *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  (arg1)->SetPosition((Math::Vector3 const &)*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransform_SetPosition__SWIG_2(void * jarg1, float jarg2, float jarg3, float jarg4, int jarg5) {
  CTransform *arg1 = (CTransform *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  CTransform::TransformSpace arg5 ;
  
  arg1 = (CTransform *)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  arg5 = (CTransform::TransformSpace)jarg5; 
  (arg1)->SetPosition(arg2,arg3,arg4,arg5);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransform_SetPosition__SWIG_3(void * jarg1, float jarg2, float jarg3, float jarg4) {
  CTransform *arg1 = (CTransform *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  arg1 = (CTransform *)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  (arg1)->SetPosition(arg2,arg3,arg4);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransform_SetPositionX__SWIG_0(void * jarg1, float jarg2, int jarg3) {
  CTransform *arg1 = (CTransform *) 0 ;
  float arg2 ;
  CTransform::TransformSpace arg3 ;
  
  arg1 = (CTransform *)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (CTransform::TransformSpace)jarg3; 
  (arg1)->SetPositionX(arg2,arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransform_SetPositionX__SWIG_1(void * jarg1, float jarg2) {
  CTransform *arg1 = (CTransform *) 0 ;
  float arg2 ;
  
  arg1 = (CTransform *)jarg1; 
  arg2 = (float)jarg2; 
  (arg1)->SetPositionX(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransform_SetPositionY__SWIG_0(void * jarg1, float jarg2, int jarg3) {
  CTransform *arg1 = (CTransform *) 0 ;
  float arg2 ;
  CTransform::TransformSpace arg3 ;
  
  arg1 = (CTransform *)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (CTransform::TransformSpace)jarg3; 
  (arg1)->SetPositionY(arg2,arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransform_SetPositionY__SWIG_1(void * jarg1, float jarg2) {
  CTransform *arg1 = (CTransform *) 0 ;
  float arg2 ;
  
  arg1 = (CTransform *)jarg1; 
  arg2 = (float)jarg2; 
  (arg1)->SetPositionY(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransform_SetPositionZ__SWIG_0(void * jarg1, float jarg2, int jarg3) {
  CTransform *arg1 = (CTransform *) 0 ;
  float arg2 ;
  CTransform::TransformSpace arg3 ;
  
  arg1 = (CTransform *)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (CTransform::TransformSpace)jarg3; 
  (arg1)->SetPositionZ(arg2,arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransform_SetPositionZ__SWIG_1(void * jarg1, float jarg2) {
  CTransform *arg1 = (CTransform *) 0 ;
  float arg2 ;
  
  arg1 = (CTransform *)jarg1; 
  arg2 = (float)jarg2; 
  (arg1)->SetPositionZ(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransform_Translate__SWIG_0(void * jarg1, float jarg2, float jarg3, float jarg4) {
  CTransform *arg1 = (CTransform *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  arg1 = (CTransform *)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  (arg1)->Translate(arg2,arg3,arg4);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransform_Translate__SWIG_1(void * jarg1, void * jarg2) {
  CTransform *arg1 = (CTransform *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  
  arg1 = (CTransform *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  (arg1)->Translate((Math::Vector3 const &)*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransform_SetScale__SWIG_0(void * jarg1, void * jarg2, int jarg3) {
  CTransform *arg1 = (CTransform *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  CTransform::TransformSpace arg3 ;
  
  arg1 = (CTransform *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  arg3 = (CTransform::TransformSpace)jarg3; 
  (arg1)->SetScale((Math::Vector3 const &)*arg2,arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransform_SetScale__SWIG_1(void * jarg1, void * jarg2) {
  CTransform *arg1 = (CTransform *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  
  arg1 = (CTransform *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  (arg1)->SetScale((Math::Vector3 const &)*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransform_SetScale__SWIG_2(void * jarg1, float jarg2, float jarg3, float jarg4, int jarg5) {
  CTransform *arg1 = (CTransform *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  CTransform::TransformSpace arg5 ;
  
  arg1 = (CTransform *)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  arg5 = (CTransform::TransformSpace)jarg5; 
  (arg1)->SetScale(arg2,arg3,arg4,arg5);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransform_SetScale__SWIG_3(void * jarg1, float jarg2, float jarg3, float jarg4) {
  CTransform *arg1 = (CTransform *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  arg1 = (CTransform *)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  (arg1)->SetScale(arg2,arg3,arg4);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CTransform_GetScale__SWIG_0(void * jarg1, int jarg2) {
  void * jresult ;
  CTransform *arg1 = (CTransform *) 0 ;
  CTransform::TransformSpace arg2 ;
  Math::Vector3 result;
  
  arg1 = (CTransform *)jarg1; 
  arg2 = (CTransform::TransformSpace)jarg2; 
  result = (arg1)->GetScale(arg2);
  jresult = new Math::Vector3((const Math::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CTransform_GetScale__SWIG_1(void * jarg1) {
  void * jresult ;
  CTransform *arg1 = (CTransform *) 0 ;
  Math::Vector3 result;
  
  arg1 = (CTransform *)jarg1; 
  result = (arg1)->GetScale();
  jresult = new Math::Vector3((const Math::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransform_children_set(void * jarg1, void * jarg2) {
  CTransform *arg1 = (CTransform *) 0 ;
  std::vector< CTransform * > *arg2 = (std::vector< CTransform * > *) 0 ;
  
  arg1 = (CTransform *)jarg1; 
  arg2 = (std::vector< CTransform * > *)jarg2; 
  if (arg1) (arg1)->children = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CTransform_children_get(void * jarg1) {
  void * jresult ;
  CTransform *arg1 = (CTransform *) 0 ;
  std::vector< CTransform * > *result = 0 ;
  
  arg1 = (CTransform *)jarg1; 
  result = (std::vector< CTransform * > *)& ((arg1)->children);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CTransform_GetNumberOfChildren(void * jarg1) {
  unsigned int jresult ;
  CTransform *arg1 = (CTransform *) 0 ;
  unsigned int result;
  
  arg1 = (CTransform *)jarg1; 
  result = (unsigned int)(arg1)->GetNumberOfChildren();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CTransform_GetChild(void * jarg1, unsigned int jarg2) {
  void * jresult ;
  CTransform *arg1 = (CTransform *) 0 ;
  unsigned int arg2 ;
  CTransform *result = 0 ;
  
  arg1 = (CTransform *)jarg1; 
  arg2 = (unsigned int)jarg2; 
  result = (CTransform *)(arg1)->GetChild(arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CTransform_SetParent(void * jarg1, void * jarg2) {
  CTransform *arg1 = (CTransform *) 0 ;
  CTransform *arg2 = (CTransform *) 0 ;
  
  arg1 = (CTransform *)jarg1; 
  arg2 = (CTransform *)jarg2; 
  (arg1)->SetParent(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CTransform_GetParent(void * jarg1) {
  void * jresult ;
  CTransform *arg1 = (CTransform *) 0 ;
  CTransform *result = 0 ;
  
  arg1 = (CTransform *)jarg1; 
  result = (CTransform *)((CTransform const *)arg1)->GetParent();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_AABB() {
  void * jresult ;
  AABB *result = 0 ;
  
  result = (AABB *)new AABB();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_AABB(void * jarg1) {
  AABB *arg1 = (AABB *) 0 ;
  
  arg1 = (AABB *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_AABB_minPoint_set(void * jarg1, void * jarg2) {
  AABB *arg1 = (AABB *) 0 ;
  Math::Vector3 *arg2 = (Math::Vector3 *) 0 ;
  
  arg1 = (AABB *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2; 
  if (arg1) (arg1)->minPoint = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_AABB_minPoint_get(void * jarg1) {
  void * jresult ;
  AABB *arg1 = (AABB *) 0 ;
  Math::Vector3 *result = 0 ;
  
  arg1 = (AABB *)jarg1; 
  result = (Math::Vector3 *)& ((arg1)->minPoint);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_AABB_maxPoint_set(void * jarg1, void * jarg2) {
  AABB *arg1 = (AABB *) 0 ;
  Math::Vector3 *arg2 = (Math::Vector3 *) 0 ;
  
  arg1 = (AABB *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2; 
  if (arg1) (arg1)->maxPoint = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_AABB_maxPoint_get(void * jarg1) {
  void * jresult ;
  AABB *arg1 = (AABB *) 0 ;
  Math::Vector3 *result = 0 ;
  
  arg1 = (AABB *)jarg1; 
  result = (Math::Vector3 *)& ((arg1)->maxPoint);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CRenderer_SetMesh(void * jarg1, void * jarg2) {
  CRenderer *arg1 = (CRenderer *) 0 ;
  AssetHandle *arg2 = 0 ;
  
  arg1 = (CRenderer *)jarg1; 
  arg2 = (AssetHandle *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "AssetHandle & type is null", 0);
    return ;
  } 
  (arg1)->SetMesh(*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CRenderer_SetMaterial(void * jarg1, void * jarg2) {
  CRenderer *arg1 = (CRenderer *) 0 ;
  Material *arg2 = 0 ;
  
  arg1 = (CRenderer *)jarg1; 
  arg2 = (Material *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Material & type is null", 0);
    return ;
  } 
  (arg1)->SetMaterial(*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CRenderer_GetMesh(void * jarg1) {
  void * jresult ;
  CRenderer *arg1 = (CRenderer *) 0 ;
  Mesh *result = 0 ;
  
  arg1 = (CRenderer *)jarg1; 
  result = (Mesh *)(arg1)->GetMesh();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CRenderer_GetMaterial(void * jarg1) {
  void * jresult ;
  CRenderer *arg1 = (CRenderer *) 0 ;
  Material *result = 0 ;
  
  arg1 = (CRenderer *)jarg1; 
  result = (Material *)(arg1)->GetMaterial();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CRenderer_GetCopyMaterial(void * jarg1) {
  void * jresult ;
  CRenderer *arg1 = (CRenderer *) 0 ;
  Material *result = 0 ;
  
  arg1 = (CRenderer *)jarg1; 
  result = (Material *)(arg1)->GetCopyMaterial();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CRenderer_GetMeshDimension(void * jarg1) {
  void * jresult ;
  CRenderer *arg1 = (CRenderer *) 0 ;
  Math::Vector3 result;
  
  arg1 = (CRenderer *)jarg1; 
  result = ((CRenderer const *)arg1)->GetMeshDimension();
  jresult = new Math::Vector3((const Math::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CRenderer_GetBoundingBox(void * jarg1) {
  void * jresult ;
  CRenderer *arg1 = (CRenderer *) 0 ;
  AABB result;
  
  arg1 = (CRenderer *)jarg1; 
  result = ((CRenderer const *)arg1)->GetBoundingBox();
  jresult = new AABB((const AABB &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CRenderer_mMesh_set(void * jarg1, void * jarg2) {
  CRenderer *arg1 = (CRenderer *) 0 ;
  AssetHandle *arg2 = (AssetHandle *) 0 ;
  
  arg1 = (CRenderer *)jarg1; 
  arg2 = (AssetHandle *)jarg2; 
  if (arg1) (arg1)->mMesh = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CRenderer_mMesh_get(void * jarg1) {
  void * jresult ;
  CRenderer *arg1 = (CRenderer *) 0 ;
  AssetHandle *result = 0 ;
  
  arg1 = (CRenderer *)jarg1; 
  result = (AssetHandle *)& ((arg1)->mMesh);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CRenderer_mMaterial_set(void * jarg1, void * jarg2) {
  CRenderer *arg1 = (CRenderer *) 0 ;
  Material *arg2 = (Material *) 0 ;
  
  arg1 = (CRenderer *)jarg1; 
  arg2 = (Material *)jarg2; 
  if (arg1) (arg1)->mMaterial = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CRenderer_mMaterial_get(void * jarg1) {
  void * jresult ;
  CRenderer *arg1 = (CRenderer *) 0 ;
  Material *result = 0 ;
  
  arg1 = (CRenderer *)jarg1; 
  result = (Material *)& ((arg1)->mMaterial);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CRenderer_mBlendState_set(void * jarg1, int jarg2) {
  CRenderer *arg1 = (CRenderer *) 0 ;
  CRenderer::BlendState arg2 ;
  
  arg1 = (CRenderer *)jarg1; 
  arg2 = (CRenderer::BlendState)jarg2; 
  if (arg1) (arg1)->mBlendState = arg2;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CRenderer_mBlendState_get(void * jarg1) {
  int jresult ;
  CRenderer *arg1 = (CRenderer *) 0 ;
  CRenderer::BlendState result;
  
  arg1 = (CRenderer *)jarg1; 
  result = (CRenderer::BlendState) ((arg1)->mBlendState);
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CRenderer_mBumpFactor_set(void * jarg1, float jarg2) {
  CRenderer *arg1 = (CRenderer *) 0 ;
  float arg2 ;
  
  arg1 = (CRenderer *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mBumpFactor = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CRenderer_mBumpFactor_get(void * jarg1) {
  float jresult ;
  CRenderer *arg1 = (CRenderer *) 0 ;
  float result;
  
  arg1 = (CRenderer *)jarg1; 
  result = (float) ((arg1)->mBumpFactor);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CRenderer_mMetallicFactor_set(void * jarg1, float jarg2) {
  CRenderer *arg1 = (CRenderer *) 0 ;
  float arg2 ;
  
  arg1 = (CRenderer *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mMetallicFactor = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CRenderer_mMetallicFactor_get(void * jarg1) {
  float jresult ;
  CRenderer *arg1 = (CRenderer *) 0 ;
  float result;
  
  arg1 = (CRenderer *)jarg1; 
  result = (float) ((arg1)->mMetallicFactor);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CRenderer_mRoughnessFactor_set(void * jarg1, float jarg2) {
  CRenderer *arg1 = (CRenderer *) 0 ;
  float arg2 ;
  
  arg1 = (CRenderer *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mRoughnessFactor = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CRenderer_mRoughnessFactor_get(void * jarg1) {
  float jresult ;
  CRenderer *arg1 = (CRenderer *) 0 ;
  float result;
  
  arg1 = (CRenderer *)jarg1; 
  result = (float) ((arg1)->mRoughnessFactor);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CRenderer_mEmissiveColor_set(void * jarg1, void * jarg2) {
  CRenderer *arg1 = (CRenderer *) 0 ;
  Color *arg2 = (Color *) 0 ;
  
  arg1 = (CRenderer *)jarg1; 
  arg2 = (Color *)jarg2; 
  if (arg1) (arg1)->mEmissiveColor = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CRenderer_mEmissiveColor_get(void * jarg1) {
  void * jresult ;
  CRenderer *arg1 = (CRenderer *) 0 ;
  Color *result = 0 ;
  
  arg1 = (CRenderer *)jarg1; 
  result = (Color *)& ((arg1)->mEmissiveColor);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CRenderer_mPerspective_set(void * jarg1, unsigned int jarg2) {
  CRenderer *arg1 = (CRenderer *) 0 ;
  bool arg2 ;
  
  arg1 = (CRenderer *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->mPerspective = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CRenderer_mPerspective_get(void * jarg1) {
  unsigned int jresult ;
  CRenderer *arg1 = (CRenderer *) 0 ;
  bool result;
  
  arg1 = (CRenderer *)jarg1; 
  result = (bool) ((arg1)->mPerspective);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CRenderer_mReceiveShadows_set(void * jarg1, unsigned int jarg2) {
  CRenderer *arg1 = (CRenderer *) 0 ;
  bool arg2 ;
  
  arg1 = (CRenderer *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->mReceiveShadows = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CRenderer_mReceiveShadows_get(void * jarg1) {
  unsigned int jresult ;
  CRenderer *arg1 = (CRenderer *) 0 ;
  bool result;
  
  arg1 = (CRenderer *)jarg1; 
  result = (bool) ((arg1)->mReceiveShadows);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CMeshRenderer_SetMesh(void * jarg1, void * jarg2) {
  CMeshRenderer *arg1 = (CMeshRenderer *) 0 ;
  AssetHandle *arg2 = 0 ;
  
  arg1 = (CMeshRenderer *)jarg1; 
  arg2 = (AssetHandle *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "AssetHandle & type is null", 0);
    return ;
  } 
  (arg1)->SetMesh(*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CSkinMeshRenderer_SetMesh(void * jarg1, void * jarg2) {
  CSkinMeshRenderer *arg1 = (CSkinMeshRenderer *) 0 ;
  AssetHandle *arg2 = 0 ;
  
  arg1 = (CSkinMeshRenderer *)jarg1; 
  arg2 = (AssetHandle *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "AssetHandle & type is null", 0);
    return ;
  } 
  (arg1)->SetMesh(*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_AnimContainer_Clear(void * jarg1) {
  std::vector< AssetHandle > *arg1 = (std::vector< AssetHandle > *) 0 ;
  
  arg1 = (std::vector< AssetHandle > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_AnimContainer_Add(void * jarg1, void * jarg2) {
  std::vector< AssetHandle > *arg1 = (std::vector< AssetHandle > *) 0 ;
  AssetHandle *arg2 = 0 ;
  
  arg1 = (std::vector< AssetHandle > *)jarg1; 
  arg2 = (AssetHandle *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "AssetHandle const & type is null", 0);
    return ;
  } 
  (arg1)->push_back((AssetHandle const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_AnimContainer_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< AssetHandle > *arg1 = (std::vector< AssetHandle > *) 0 ;
  std::vector< AssetHandle >::size_type result;
  
  arg1 = (std::vector< AssetHandle > *)jarg1; 
  result = ((std::vector< AssetHandle > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_AnimContainer_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< AssetHandle > *arg1 = (std::vector< AssetHandle > *) 0 ;
  std::vector< AssetHandle >::size_type result;
  
  arg1 = (std::vector< AssetHandle > *)jarg1; 
  result = ((std::vector< AssetHandle > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_AnimContainer_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< AssetHandle > *arg1 = (std::vector< AssetHandle > *) 0 ;
  std::vector< AssetHandle >::size_type arg2 ;
  
  arg1 = (std::vector< AssetHandle > *)jarg1; 
  arg2 = (std::vector< AssetHandle >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_AnimContainer__SWIG_0() {
  void * jresult ;
  std::vector< AssetHandle > *result = 0 ;
  
  result = (std::vector< AssetHandle > *)new std::vector< AssetHandle >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_AnimContainer__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< AssetHandle > *arg1 = 0 ;
  std::vector< AssetHandle > *result = 0 ;
  
  arg1 = (std::vector< AssetHandle > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< AssetHandle > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< AssetHandle > *)new std::vector< AssetHandle >((std::vector< AssetHandle > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_AnimContainer__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< AssetHandle > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< AssetHandle > *)new_std_vector_Sl_AssetHandle_Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_AnimContainer_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< AssetHandle > *arg1 = (std::vector< AssetHandle > *) 0 ;
  int arg2 ;
  AssetHandle result;
  
  arg1 = (std::vector< AssetHandle > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_AssetHandle_Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = new AssetHandle((const AssetHandle &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_AnimContainer_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< AssetHandle > *arg1 = (std::vector< AssetHandle > *) 0 ;
  int arg2 ;
  AssetHandle *result = 0 ;
  
  arg1 = (std::vector< AssetHandle > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (AssetHandle *) &std_vector_Sl_AssetHandle_Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_AnimContainer_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< AssetHandle > *arg1 = (std::vector< AssetHandle > *) 0 ;
  int arg2 ;
  AssetHandle *arg3 = 0 ;
  
  arg1 = (std::vector< AssetHandle > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (AssetHandle *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "AssetHandle const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_AssetHandle_Sg__setitem(arg1,arg2,(AssetHandle const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_AnimContainer_AddRange(void * jarg1, void * jarg2) {
  std::vector< AssetHandle > *arg1 = (std::vector< AssetHandle > *) 0 ;
  std::vector< AssetHandle > *arg2 = 0 ;
  
  arg1 = (std::vector< AssetHandle > *)jarg1; 
  arg2 = (std::vector< AssetHandle > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< AssetHandle > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_AssetHandle_Sg__AddRange(arg1,(std::vector< AssetHandle > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_AnimContainer_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< AssetHandle > *arg1 = (std::vector< AssetHandle > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< AssetHandle > *result = 0 ;
  
  arg1 = (std::vector< AssetHandle > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< AssetHandle > *)std_vector_Sl_AssetHandle_Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_AnimContainer_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< AssetHandle > *arg1 = (std::vector< AssetHandle > *) 0 ;
  int arg2 ;
  AssetHandle *arg3 = 0 ;
  
  arg1 = (std::vector< AssetHandle > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (AssetHandle *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "AssetHandle const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_AssetHandle_Sg__Insert(arg1,arg2,(AssetHandle const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_AnimContainer_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< AssetHandle > *arg1 = (std::vector< AssetHandle > *) 0 ;
  int arg2 ;
  std::vector< AssetHandle > *arg3 = 0 ;
  
  arg1 = (std::vector< AssetHandle > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< AssetHandle > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< AssetHandle > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_AssetHandle_Sg__InsertRange(arg1,arg2,(std::vector< AssetHandle > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_AnimContainer_RemoveAt(void * jarg1, int jarg2) {
  std::vector< AssetHandle > *arg1 = (std::vector< AssetHandle > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< AssetHandle > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_AssetHandle_Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_AnimContainer_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< AssetHandle > *arg1 = (std::vector< AssetHandle > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< AssetHandle > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_AssetHandle_Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_AnimContainer_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  AssetHandle *arg1 = 0 ;
  int arg2 ;
  std::vector< AssetHandle > *result = 0 ;
  
  arg1 = (AssetHandle *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "AssetHandle const & type is null", 0);
    return 0;
  } 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< AssetHandle > *)std_vector_Sl_AssetHandle_Sg__Repeat((AssetHandle const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_AnimContainer_Reverse__SWIG_0(void * jarg1) {
  std::vector< AssetHandle > *arg1 = (std::vector< AssetHandle > *) 0 ;
  
  arg1 = (std::vector< AssetHandle > *)jarg1; 
  std_vector_Sl_AssetHandle_Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_AnimContainer_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< AssetHandle > *arg1 = (std::vector< AssetHandle > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< AssetHandle > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_AssetHandle_Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_AnimContainer_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< AssetHandle > *arg1 = (std::vector< AssetHandle > *) 0 ;
  int arg2 ;
  std::vector< AssetHandle > *arg3 = 0 ;
  
  arg1 = (std::vector< AssetHandle > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< AssetHandle > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< AssetHandle > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_AssetHandle_Sg__SetRange(arg1,arg2,(std::vector< AssetHandle > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_AnimContainer(void * jarg1) {
  std::vector< AssetHandle > *arg1 = (std::vector< AssetHandle > *) 0 ;
  
  arg1 = (std::vector< AssetHandle > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CAnimationController_SetAnimation(void * jarg1, char * jarg2) {
  CAnimationController *arg1 = (CAnimationController *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (CAnimationController *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  (arg1)->SetAnimation((std::string const &)*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CAnimationController_AddAnimation(void * jarg1, void * jarg2) {
  CAnimationController *arg1 = (CAnimationController *) 0 ;
  AssetHandle *arg2 = 0 ;
  
  arg1 = (CAnimationController *)jarg1; 
  arg2 = (AssetHandle *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "AssetHandle & type is null", 0);
    return ;
  } 
  (arg1)->AddAnimation(*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CAnimationController_GetActiveAnimation(void * jarg1) {
  void * jresult ;
  CAnimationController *arg1 = (CAnimationController *) 0 ;
  Animation *result = 0 ;
  
  arg1 = (CAnimationController *)jarg1; 
  result = (Animation *)(arg1)->GetActiveAnimation();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CAnimationController_mIsPlaying_set(void * jarg1, unsigned int jarg2) {
  CAnimationController *arg1 = (CAnimationController *) 0 ;
  bool arg2 ;
  
  arg1 = (CAnimationController *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->mIsPlaying = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CAnimationController_mIsPlaying_get(void * jarg1) {
  unsigned int jresult ;
  CAnimationController *arg1 = (CAnimationController *) 0 ;
  bool result;
  
  arg1 = (CAnimationController *)jarg1; 
  result = (bool) ((arg1)->mIsPlaying);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CAnimationController_mAnimSpeed_set(void * jarg1, float jarg2) {
  CAnimationController *arg1 = (CAnimationController *) 0 ;
  float arg2 ;
  
  arg1 = (CAnimationController *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mAnimSpeed = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CAnimationController_mAnimSpeed_get(void * jarg1) {
  float jresult ;
  CAnimationController *arg1 = (CAnimationController *) 0 ;
  float result;
  
  arg1 = (CAnimationController *)jarg1; 
  result = (float) ((arg1)->mAnimSpeed);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CAnimationController_mSingleAnim_set(void * jarg1, void * jarg2) {
  CAnimationController *arg1 = (CAnimationController *) 0 ;
  AssetHandle *arg2 = (AssetHandle *) 0 ;
  
  arg1 = (CAnimationController *)jarg1; 
  arg2 = (AssetHandle *)jarg2; 
  if (arg1) (arg1)->mSingleAnim = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CAnimationController_mSingleAnim_get(void * jarg1) {
  void * jresult ;
  CAnimationController *arg1 = (CAnimationController *) 0 ;
  AssetHandle *result = 0 ;
  
  arg1 = (CAnimationController *)jarg1; 
  result = (AssetHandle *)& ((arg1)->mSingleAnim);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CAnimationController_mAnimations_set(void * jarg1, void * jarg2) {
  CAnimationController *arg1 = (CAnimationController *) 0 ;
  std::vector< AssetHandle > *arg2 = (std::vector< AssetHandle > *) 0 ;
  
  arg1 = (CAnimationController *)jarg1; 
  arg2 = (std::vector< AssetHandle > *)jarg2; 
  if (arg1) (arg1)->mAnimations = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CAnimationController_mAnimations_get(void * jarg1) {
  void * jresult ;
  CAnimationController *arg1 = (CAnimationController *) 0 ;
  std::vector< AssetHandle > *result = 0 ;
  
  arg1 = (CAnimationController *)jarg1; 
  result = (std::vector< AssetHandle > *)& ((arg1)->mAnimations);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CLight_GetDiffuse(void * jarg1) {
  void * jresult ;
  CLight *arg1 = (CLight *) 0 ;
  Color result;
  
  arg1 = (CLight *)jarg1; 
  result = ((CLight const *)arg1)->GetDiffuse();
  jresult = new Color((const Color &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLight_SetDiffuse(void * jarg1, void * jarg2) {
  CLight *arg1 = (CLight *) 0 ;
  Color arg2 ;
  Color *argp2 ;
  
  arg1 = (CLight *)jarg1; 
  argp2 = (Color *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null Color", 0);
    return ;
  }
  arg2 = *argp2; 
  (arg1)->SetDiffuse(arg2);
}


SWIGEXPORT float SWIGSTDCALL CSharp_CLight_GetRange(void * jarg1) {
  float jresult ;
  CLight *arg1 = (CLight *) 0 ;
  float result;
  
  arg1 = (CLight *)jarg1; 
  result = (float)((CLight const *)arg1)->GetRange();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLight_SetRange(void * jarg1, float jarg2) {
  CLight *arg1 = (CLight *) 0 ;
  float arg2 ;
  
  arg1 = (CLight *)jarg1; 
  arg2 = (float)jarg2; 
  (arg1)->SetRange(arg2);
}


SWIGEXPORT float SWIGSTDCALL CSharp_CLight_GetSpot(void * jarg1) {
  float jresult ;
  CLight *arg1 = (CLight *) 0 ;
  float result;
  
  arg1 = (CLight *)jarg1; 
  result = (float)((CLight const *)arg1)->GetSpot();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLight_SetSpot(void * jarg1, float jarg2) {
  CLight *arg1 = (CLight *) 0 ;
  float arg2 ;
  
  arg1 = (CLight *)jarg1; 
  arg2 = (float)jarg2; 
  (arg1)->SetSpot(arg2);
}


SWIGEXPORT float SWIGSTDCALL CSharp_CLight_GetAtt(void * jarg1) {
  float jresult ;
  CLight *arg1 = (CLight *) 0 ;
  float result;
  
  arg1 = (CLight *)jarg1; 
  result = (float)((CLight const *)arg1)->GetAtt();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLight_SetAtt(void * jarg1, float jarg2) {
  CLight *arg1 = (CLight *) 0 ;
  float arg2 ;
  
  arg1 = (CLight *)jarg1; 
  arg2 = (float)jarg2; 
  (arg1)->SetAtt(arg2);
}


SWIGEXPORT int SWIGSTDCALL CSharp_CLight_GetLightType(void * jarg1) {
  int jresult ;
  CLight *arg1 = (CLight *) 0 ;
  int result;
  
  arg1 = (CLight *)jarg1; 
  result = (int)((CLight const *)arg1)->GetLightType();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLight_SetLightType(void * jarg1, int jarg2) {
  CLight *arg1 = (CLight *) 0 ;
  CLight::LIGHTTYPE arg2 ;
  
  arg1 = (CLight *)jarg1; 
  arg2 = (CLight::LIGHTTYPE)jarg2; 
  (arg1)->SetLightType(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLight_mDiffuse_set(void * jarg1, void * jarg2) {
  CLight *arg1 = (CLight *) 0 ;
  Color *arg2 = (Color *) 0 ;
  
  arg1 = (CLight *)jarg1; 
  arg2 = (Color *)jarg2; 
  if (arg1) (arg1)->mDiffuse = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CLight_mDiffuse_get(void * jarg1) {
  void * jresult ;
  CLight *arg1 = (CLight *) 0 ;
  Color *result = 0 ;
  
  arg1 = (CLight *)jarg1; 
  result = (Color *)& ((arg1)->mDiffuse);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLight_mRange_set(void * jarg1, float jarg2) {
  CLight *arg1 = (CLight *) 0 ;
  float arg2 ;
  
  arg1 = (CLight *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mRange = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CLight_mRange_get(void * jarg1) {
  float jresult ;
  CLight *arg1 = (CLight *) 0 ;
  float result;
  
  arg1 = (CLight *)jarg1; 
  result = (float) ((arg1)->mRange);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLight_mAtt_set(void * jarg1, float jarg2) {
  CLight *arg1 = (CLight *) 0 ;
  float arg2 ;
  
  arg1 = (CLight *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mAtt = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CLight_mAtt_get(void * jarg1) {
  float jresult ;
  CLight *arg1 = (CLight *) 0 ;
  float result;
  
  arg1 = (CLight *)jarg1; 
  result = (float) ((arg1)->mAtt);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLight_mInnerAngle_set(void * jarg1, float jarg2) {
  CLight *arg1 = (CLight *) 0 ;
  float arg2 ;
  
  arg1 = (CLight *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mInnerAngle = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CLight_mInnerAngle_get(void * jarg1) {
  float jresult ;
  CLight *arg1 = (CLight *) 0 ;
  float result;
  
  arg1 = (CLight *)jarg1; 
  result = (float) ((arg1)->mInnerAngle);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLight_mOuterAngle_set(void * jarg1, float jarg2) {
  CLight *arg1 = (CLight *) 0 ;
  float arg2 ;
  
  arg1 = (CLight *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mOuterAngle = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CLight_mOuterAngle_get(void * jarg1) {
  float jresult ;
  CLight *arg1 = (CLight *) 0 ;
  float result;
  
  arg1 = (CLight *)jarg1; 
  result = (float) ((arg1)->mOuterAngle);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLight_mSpot_set(void * jarg1, float jarg2) {
  CLight *arg1 = (CLight *) 0 ;
  float arg2 ;
  
  arg1 = (CLight *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mSpot = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CLight_mSpot_get(void * jarg1) {
  float jresult ;
  CLight *arg1 = (CLight *) 0 ;
  float result;
  
  arg1 = (CLight *)jarg1; 
  result = (float) ((arg1)->mSpot);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLight_mIntensity_set(void * jarg1, float jarg2) {
  CLight *arg1 = (CLight *) 0 ;
  float arg2 ;
  
  arg1 = (CLight *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mIntensity = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CLight_mIntensity_get(void * jarg1) {
  float jresult ;
  CLight *arg1 = (CLight *) 0 ;
  float result;
  
  arg1 = (CLight *)jarg1; 
  result = (float) ((arg1)->mIntensity);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLight_mLightType_set(void * jarg1, int jarg2) {
  CLight *arg1 = (CLight *) 0 ;
  CLight::LIGHTTYPE arg2 ;
  
  arg1 = (CLight *)jarg1; 
  arg2 = (CLight::LIGHTTYPE)jarg2; 
  if (arg1) (arg1)->mLightType = arg2;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CLight_mLightType_get(void * jarg1) {
  int jresult ;
  CLight *arg1 = (CLight *) 0 ;
  CLight::LIGHTTYPE result;
  
  arg1 = (CLight *)jarg1; 
  result = (CLight::LIGHTTYPE) ((arg1)->mLightType);
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLight_mLightDir_set(void * jarg1, void * jarg2) {
  CLight *arg1 = (CLight *) 0 ;
  Math::Vector3 *arg2 = (Math::Vector3 *) 0 ;
  
  arg1 = (CLight *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2; 
  if (arg1) (arg1)->mLightDir = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CLight_mLightDir_get(void * jarg1) {
  void * jresult ;
  CLight *arg1 = (CLight *) 0 ;
  Math::Vector3 *result = 0 ;
  
  arg1 = (CLight *)jarg1; 
  result = (Math::Vector3 *)& ((arg1)->mLightDir);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CPhysics_AddForce__SWIG_0(void * jarg1, void * jarg2) {
  CPhysics *arg1 = (CPhysics *) 0 ;
  Vector arg2 ;
  Vector *argp2 ;
  
  arg1 = (CPhysics *)jarg1; 
  argp2 = (Vector *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null Vector", 0);
    return ;
  }
  arg2 = *argp2; 
  (arg1)->AddForce(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CPhysics_SetVelocity__SWIG_0(void * jarg1, void * jarg2) {
  CPhysics *arg1 = (CPhysics *) 0 ;
  Vector *arg2 = 0 ;
  
  arg1 = (CPhysics *)jarg1; 
  arg2 = (Vector *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Vector const & type is null", 0);
    return ;
  } 
  (arg1)->SetVelocity((Vector const &)*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CPhysics_SetAnguVelocity(void * jarg1, float jarg2) {
  CPhysics *arg1 = (CPhysics *) 0 ;
  float arg2 ;
  
  arg1 = (CPhysics *)jarg1; 
  arg2 = (float)jarg2; 
  (arg1)->SetAnguVelocity(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CPhysics_SetPosition(void * jarg1, void * jarg2) {
  CPhysics *arg1 = (CPhysics *) 0 ;
  Point3 *arg2 = 0 ;
  
  arg1 = (CPhysics *)jarg1; 
  arg2 = (Point3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Point3 const & type is null", 0);
    return ;
  } 
  (arg1)->SetPosition((Point3 const &)*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CPhysics_SetStatus(void * jarg1, unsigned int jarg2) {
  CPhysics *arg1 = (CPhysics *) 0 ;
  bool arg2 ;
  
  arg1 = (CPhysics *)jarg1; 
  arg2 = jarg2 ? true : false; 
  (arg1)->SetStatus(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CPhysics_SetIsControl(void * jarg1, unsigned int jarg2) {
  CPhysics *arg1 = (CPhysics *) 0 ;
  bool arg2 ;
  
  arg1 = (CPhysics *)jarg1; 
  arg2 = jarg2 ? true : false; 
  (arg1)->SetIsControl(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CPhysics_SetIsForceActive(void * jarg1, unsigned int jarg2) {
  CPhysics *arg1 = (CPhysics *) 0 ;
  bool arg2 ;
  
  arg1 = (CPhysics *)jarg1; 
  arg2 = jarg2 ? true : false; 
  (arg1)->SetIsForceActive(arg2);
}


SWIGEXPORT int SWIGSTDCALL CSharp_CPhysics_GetCOllisionID(void * jarg1) {
  int jresult ;
  CPhysics *arg1 = (CPhysics *) 0 ;
  int result;
  
  arg1 = (CPhysics *)jarg1; 
  result = (int)((CPhysics const *)arg1)->GetCOllisionID();
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CPhysics_GetIsStatic(void * jarg1) {
  unsigned int jresult ;
  CPhysics *arg1 = (CPhysics *) 0 ;
  bool result;
  
  arg1 = (CPhysics *)jarg1; 
  result = (bool)((CPhysics const *)arg1)->GetIsStatic();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CPhysics_GetOffSetX(void * jarg1) {
  float jresult ;
  CPhysics *arg1 = (CPhysics *) 0 ;
  float result;
  
  arg1 = (CPhysics *)jarg1; 
  result = (float)((CPhysics const *)arg1)->GetOffSetX();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CPhysics_GetOffSetY(void * jarg1) {
  float jresult ;
  CPhysics *arg1 = (CPhysics *) 0 ;
  float result;
  
  arg1 = (CPhysics *)jarg1; 
  result = (float)((CPhysics const *)arg1)->GetOffSetY();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CPhysics_GetAcceleration(void * jarg1) {
  void * jresult ;
  CPhysics *arg1 = (CPhysics *) 0 ;
  Vector *result = 0 ;
  
  arg1 = (CPhysics *)jarg1; 
  result = (Vector *) &((CPhysics const *)arg1)->GetAcceleration();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CPhysics_GetVelocity(void * jarg1) {
  void * jresult ;
  CPhysics *arg1 = (CPhysics *) 0 ;
  Vector *result = 0 ;
  
  arg1 = (CPhysics *)jarg1; 
  result = (Vector *) &((CPhysics const *)arg1)->GetVelocity();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CPhysics_GetPosition(void * jarg1) {
  void * jresult ;
  CPhysics *arg1 = (CPhysics *) 0 ;
  Point3 *result = 0 ;
  
  arg1 = (CPhysics *)jarg1; 
  result = (Point3 *) &((CPhysics const *)arg1)->GetPosition();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CPhysics_GetPrevPosition(void * jarg1) {
  void * jresult ;
  CPhysics *arg1 = (CPhysics *) 0 ;
  Point3 *result = 0 ;
  
  arg1 = (CPhysics *)jarg1; 
  result = (Point3 *) &((CPhysics const *)arg1)->GetPrevPosition();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CPhysics_GetForce(void * jarg1) {
  void * jresult ;
  CPhysics *arg1 = (CPhysics *) 0 ;
  Vector *result = 0 ;
  
  arg1 = (CPhysics *)jarg1; 
  result = (Vector *) &((CPhysics const *)arg1)->GetForce();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CPhysics_SetMass(void * jarg1, float jarg2) {
  CPhysics *arg1 = (CPhysics *) 0 ;
  float arg2 ;
  
  arg1 = (CPhysics *)jarg1; 
  arg2 = (float)jarg2; 
  (arg1)->SetMass(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CPhysics_SetInertia(void * jarg1, float jarg2) {
  CPhysics *arg1 = (CPhysics *) 0 ;
  float arg2 ;
  
  arg1 = (CPhysics *)jarg1; 
  arg2 = (float)jarg2; 
  (arg1)->SetInertia(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CPhysics_SetFriction(void * jarg1, float jarg2) {
  CPhysics *arg1 = (CPhysics *) 0 ;
  float arg2 ;
  
  arg1 = (CPhysics *)jarg1; 
  arg2 = (float)jarg2; 
  (arg1)->SetFriction(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CPhysics_SetRestitution(void * jarg1, float jarg2) {
  CPhysics *arg1 = (CPhysics *) 0 ;
  float arg2 ;
  
  arg1 = (CPhysics *)jarg1; 
  arg2 = (float)jarg2; 
  (arg1)->SetRestitution(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CPhysics_AddForce__SWIG_1(void * jarg1, float jarg2, float jarg3, float jarg4) {
  CPhysics *arg1 = (CPhysics *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  arg1 = (CPhysics *)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  (arg1)->AddForce(arg2,arg3,arg4);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CPhysics_SetRotation(void * jarg1, float jarg2) {
  CPhysics *arg1 = (CPhysics *) 0 ;
  float arg2 ;
  
  arg1 = (CPhysics *)jarg1; 
  arg2 = (float)jarg2; 
  (arg1)->SetRotation(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CPhysics_SetIsSleep(void * jarg1, unsigned int jarg2) {
  CPhysics *arg1 = (CPhysics *) 0 ;
  bool arg2 ;
  
  arg1 = (CPhysics *)jarg1; 
  arg2 = jarg2 ? true : false; 
  (arg1)->SetIsSleep(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CPhysics_SetForceToZero(void * jarg1) {
  CPhysics *arg1 = (CPhysics *) 0 ;
  
  arg1 = (CPhysics *)jarg1; 
  (arg1)->SetForceToZero();
}


SWIGEXPORT float SWIGSTDCALL CSharp_CPhysics_GetAngVelocity(void * jarg1) {
  float jresult ;
  CPhysics *arg1 = (CPhysics *) 0 ;
  float *result = 0 ;
  
  arg1 = (CPhysics *)jarg1; 
  result = (float *) &((CPhysics const *)arg1)->GetAngVelocity();
  jresult = *result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CPhysics_GetInertia(void * jarg1) {
  float jresult ;
  CPhysics *arg1 = (CPhysics *) 0 ;
  float *result = 0 ;
  
  arg1 = (CPhysics *)jarg1; 
  result = (float *) &((CPhysics const *)arg1)->GetInertia();
  jresult = *result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CPhysics_GetInvInertia(void * jarg1) {
  float jresult ;
  CPhysics *arg1 = (CPhysics *) 0 ;
  float *result = 0 ;
  
  arg1 = (CPhysics *)jarg1; 
  result = (float *) &((CPhysics const *)arg1)->GetInvInertia();
  jresult = *result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CPhysics_GetMass(void * jarg1) {
  float jresult ;
  CPhysics *arg1 = (CPhysics *) 0 ;
  float result;
  
  arg1 = (CPhysics *)jarg1; 
  result = (float)((CPhysics const *)arg1)->GetMass();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CPhysics_GetInverseMass(void * jarg1) {
  float jresult ;
  CPhysics *arg1 = (CPhysics *) 0 ;
  float result;
  
  arg1 = (CPhysics *)jarg1; 
  result = (float)((CPhysics const *)arg1)->GetInverseMass();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CPhysics_GetFriction(void * jarg1) {
  float jresult ;
  CPhysics *arg1 = (CPhysics *) 0 ;
  float result;
  
  arg1 = (CPhysics *)jarg1; 
  result = (float)((CPhysics const *)arg1)->GetFriction();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CPhysics_GetRotation(void * jarg1) {
  float jresult ;
  CPhysics *arg1 = (CPhysics *) 0 ;
  float result;
  
  arg1 = (CPhysics *)jarg1; 
  result = (float)((CPhysics const *)arg1)->GetRotation();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CPhysics_GetRestitution(void * jarg1) {
  float jresult ;
  CPhysics *arg1 = (CPhysics *) 0 ;
  float result;
  
  arg1 = (CPhysics *)jarg1; 
  result = (float)((CPhysics const *)arg1)->GetRestitution();
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CPhysics_GetStatus(void * jarg1) {
  unsigned int jresult ;
  CPhysics *arg1 = (CPhysics *) 0 ;
  bool result;
  
  arg1 = (CPhysics *)jarg1; 
  result = (bool)((CPhysics const *)arg1)->GetStatus();
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CPhysics_GetIsControl(void * jarg1) {
  unsigned int jresult ;
  CPhysics *arg1 = (CPhysics *) 0 ;
  bool result;
  
  arg1 = (CPhysics *)jarg1; 
  result = (bool)((CPhysics const *)arg1)->GetIsControl();
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CPhysics_GetIsCollision(void * jarg1) {
  unsigned int jresult ;
  CPhysics *arg1 = (CPhysics *) 0 ;
  bool result;
  
  arg1 = (CPhysics *)jarg1; 
  result = (bool)((CPhysics const *)arg1)->GetIsCollision();
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CPhysics_GetIsSleep(void * jarg1) {
  unsigned int jresult ;
  CPhysics *arg1 = (CPhysics *) 0 ;
  bool result;
  
  arg1 = (CPhysics *)jarg1; 
  result = (bool)((CPhysics const *)arg1)->GetIsSleep();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CPhysics_SetVelocity__SWIG_1(void * jarg1, float jarg2, float jarg3, float jarg4) {
  CPhysics *arg1 = (CPhysics *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  arg1 = (CPhysics *)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  (arg1)->SetVelocity(arg2,arg3,arg4);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CPhysics_ClearAcceYtoZero(void * jarg1) {
  CPhysics *arg1 = (CPhysics *) 0 ;
  
  arg1 = (CPhysics *)jarg1; 
  (arg1)->ClearAcceYtoZero();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CPhysics_mCollisionID_set(void * jarg1, int jarg2) {
  CPhysics *arg1 = (CPhysics *) 0 ;
  int arg2 ;
  
  arg1 = (CPhysics *)jarg1; 
  arg2 = (int)jarg2; 
  if (arg1) (arg1)->mCollisionID = arg2;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CPhysics_mCollisionID_get(void * jarg1) {
  int jresult ;
  CPhysics *arg1 = (CPhysics *) 0 ;
  int result;
  
  arg1 = (CPhysics *)jarg1; 
  result = (int) ((arg1)->mCollisionID);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CPhysics_mColliderType_set(void * jarg1, int jarg2) {
  CPhysics *arg1 = (CPhysics *) 0 ;
  int arg2 ;
  
  arg1 = (CPhysics *)jarg1; 
  arg2 = (int)jarg2; 
  if (arg1) (arg1)->mColliderType = arg2;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CPhysics_mColliderType_get(void * jarg1) {
  int jresult ;
  CPhysics *arg1 = (CPhysics *) 0 ;
  int result;
  
  arg1 = (CPhysics *)jarg1; 
  result = (int) ((arg1)->mColliderType);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CPhysics_mIsTriggered_set(void * jarg1, unsigned int jarg2) {
  CPhysics *arg1 = (CPhysics *) 0 ;
  bool arg2 ;
  
  arg1 = (CPhysics *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->mIsTriggered = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CPhysics_mIsTriggered_get(void * jarg1) {
  unsigned int jresult ;
  CPhysics *arg1 = (CPhysics *) 0 ;
  bool result;
  
  arg1 = (CPhysics *)jarg1; 
  result = (bool) ((arg1)->mIsTriggered);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CPhysics_mIsGravityOn_set(void * jarg1, unsigned int jarg2) {
  CPhysics *arg1 = (CPhysics *) 0 ;
  bool arg2 ;
  
  arg1 = (CPhysics *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->mIsGravityOn = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CPhysics_mIsGravityOn_get(void * jarg1) {
  unsigned int jresult ;
  CPhysics *arg1 = (CPhysics *) 0 ;
  bool result;
  
  arg1 = (CPhysics *)jarg1; 
  result = (bool) ((arg1)->mIsGravityOn);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CPhysics_mIsRotation_set(void * jarg1, unsigned int jarg2) {
  CPhysics *arg1 = (CPhysics *) 0 ;
  bool arg2 ;
  
  arg1 = (CPhysics *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->mIsRotation = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CPhysics_mIsRotation_get(void * jarg1) {
  unsigned int jresult ;
  CPhysics *arg1 = (CPhysics *) 0 ;
  bool result;
  
  arg1 = (CPhysics *)jarg1; 
  result = (bool) ((arg1)->mIsRotation);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CPhysics_mLockOnX_set(void * jarg1, unsigned int jarg2) {
  CPhysics *arg1 = (CPhysics *) 0 ;
  bool arg2 ;
  
  arg1 = (CPhysics *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->mLockOnX = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CPhysics_mLockOnX_get(void * jarg1) {
  unsigned int jresult ;
  CPhysics *arg1 = (CPhysics *) 0 ;
  bool result;
  
  arg1 = (CPhysics *)jarg1; 
  result = (bool) ((arg1)->mLockOnX);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CPhysics_mLockOnY_set(void * jarg1, unsigned int jarg2) {
  CPhysics *arg1 = (CPhysics *) 0 ;
  bool arg2 ;
  
  arg1 = (CPhysics *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->mLockOnY = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CPhysics_mLockOnY_get(void * jarg1) {
  unsigned int jresult ;
  CPhysics *arg1 = (CPhysics *) 0 ;
  bool result;
  
  arg1 = (CPhysics *)jarg1; 
  result = (bool) ((arg1)->mLockOnY);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CPhysics_mLockOnZ_set(void * jarg1, unsigned int jarg2) {
  CPhysics *arg1 = (CPhysics *) 0 ;
  bool arg2 ;
  
  arg1 = (CPhysics *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->mLockOnZ = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CPhysics_mLockOnZ_get(void * jarg1) {
  unsigned int jresult ;
  CPhysics *arg1 = (CPhysics *) 0 ;
  bool result;
  
  arg1 = (CPhysics *)jarg1; 
  result = (bool) ((arg1)->mLockOnZ);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CPhysics_mFriction_set(void * jarg1, float jarg2) {
  CPhysics *arg1 = (CPhysics *) 0 ;
  float arg2 ;
  
  arg1 = (CPhysics *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mFriction = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CPhysics_mFriction_get(void * jarg1) {
  float jresult ;
  CPhysics *arg1 = (CPhysics *) 0 ;
  float result;
  
  arg1 = (CPhysics *)jarg1; 
  result = (float) ((arg1)->mFriction);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CPhysics_mRestitution_set(void * jarg1, float jarg2) {
  CPhysics *arg1 = (CPhysics *) 0 ;
  float arg2 ;
  
  arg1 = (CPhysics *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mRestitution = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CPhysics_mRestitution_get(void * jarg1) {
  float jresult ;
  CPhysics *arg1 = (CPhysics *) 0 ;
  float result;
  
  arg1 = (CPhysics *)jarg1; 
  result = (float) ((arg1)->mRestitution);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CPhysics_mGravityFactor_set(void * jarg1, void * jarg2) {
  CPhysics *arg1 = (CPhysics *) 0 ;
  Math::Vector3 *arg2 = (Math::Vector3 *) 0 ;
  
  arg1 = (CPhysics *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2; 
  if (arg1) (arg1)->mGravityFactor = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CPhysics_mGravityFactor_get(void * jarg1) {
  void * jresult ;
  CPhysics *arg1 = (CPhysics *) 0 ;
  Math::Vector3 *result = 0 ;
  
  arg1 = (CPhysics *)jarg1; 
  result = (Math::Vector3 *)& ((arg1)->mGravityFactor);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CPhysics_mMass_set(void * jarg1, float jarg2) {
  CPhysics *arg1 = (CPhysics *) 0 ;
  float arg2 ;
  
  arg1 = (CPhysics *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mMass = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CPhysics_mMass_get(void * jarg1) {
  float jresult ;
  CPhysics *arg1 = (CPhysics *) 0 ;
  float result;
  
  arg1 = (CPhysics *)jarg1; 
  result = (float) ((arg1)->mMass);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CPhysics_rigidCom_set(void * jarg1, void * jarg2) {
  CPhysics *arg1 = (CPhysics *) 0 ;
  RigidBodyComponent *arg2 = (RigidBodyComponent *) 0 ;
  
  arg1 = (CPhysics *)jarg1; 
  arg2 = (RigidBodyComponent *)jarg2; 
  if (arg1) (arg1)->rigidCom = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CPhysics_rigidCom_get(void * jarg1) {
  void * jresult ;
  CPhysics *arg1 = (CPhysics *) 0 ;
  RigidBodyComponent *result = 0 ;
  
  arg1 = (CPhysics *)jarg1; 
  result = (RigidBodyComponent *) ((arg1)->rigidCom);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CPhysics_collidarCom_set(void * jarg1, void * jarg2) {
  CPhysics *arg1 = (CPhysics *) 0 ;
  ColliderComponent *arg2 = (ColliderComponent *) 0 ;
  
  arg1 = (CPhysics *)jarg1; 
  arg2 = (ColliderComponent *)jarg2; 
  if (arg1) (arg1)->collidarCom = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CPhysics_collidarCom_get(void * jarg1) {
  void * jresult ;
  CPhysics *arg1 = (CPhysics *) 0 ;
  ColliderComponent *result = 0 ;
  
  arg1 = (CPhysics *)jarg1; 
  result = (ColliderComponent *) ((arg1)->collidarCom);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_RigidBodyComponent_Body(void * jarg1) {
  void * jresult ;
  RigidBodyComponent *arg1 = (RigidBodyComponent *) 0 ;
  RigidBody *result = 0 ;
  
  arg1 = (RigidBodyComponent *)jarg1; 
  result = (RigidBody *) &(arg1)->Body();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_RigidBodyComponent_GetType(void * jarg1) {
  int jresult ;
  RigidBodyComponent *arg1 = (RigidBodyComponent *) 0 ;
  int result;
  
  arg1 = (RigidBodyComponent *)jarg1; 
  result = (int)((RigidBodyComponent const *)arg1)->GetType();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_RigidBodyComponent_SetType(void * jarg1, int jarg2) {
  void * jresult ;
  RigidBodyComponent *arg1 = (RigidBodyComponent *) 0 ;
  int arg2 ;
  RigidBodyComponent *result = 0 ;
  
  arg1 = (RigidBodyComponent *)jarg1; 
  arg2 = (int)jarg2; 
  result = (RigidBodyComponent *) &(arg1)->SetType(arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_RigidBodyComponent_GetAwake(void * jarg1) {
  unsigned int jresult ;
  RigidBodyComponent *arg1 = (RigidBodyComponent *) 0 ;
  bool result;
  
  arg1 = (RigidBodyComponent *)jarg1; 
  result = (bool)((RigidBodyComponent const *)arg1)->GetAwake();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_RigidBodyComponent_SetAwake(void * jarg1, unsigned int jarg2) {
  void * jresult ;
  RigidBodyComponent *arg1 = (RigidBodyComponent *) 0 ;
  bool arg2 ;
  RigidBodyComponent *result = 0 ;
  
  arg1 = (RigidBodyComponent *)jarg1; 
  arg2 = jarg2 ? true : false; 
  result = (RigidBodyComponent *) &(arg1)->SetAwake(arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_RigidBodyComponent_GetCentroid(void * jarg1) {
  void * jresult ;
  RigidBodyComponent *arg1 = (RigidBodyComponent *) 0 ;
  Math::Vector3 *result = 0 ;
  
  arg1 = (RigidBodyComponent *)jarg1; 
  result = (Math::Vector3 *) &((RigidBodyComponent const *)arg1)->GetCentroid();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_RigidBodyComponent_GetPosition(void * jarg1) {
  void * jresult ;
  RigidBodyComponent *arg1 = (RigidBodyComponent *) 0 ;
  Math::Vector3 *result = 0 ;
  
  arg1 = (RigidBodyComponent *)jarg1; 
  result = (Math::Vector3 *) &((RigidBodyComponent const *)arg1)->GetPosition();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_RigidBodyComponent_SetPosition(void * jarg1, void * jarg2) {
  void * jresult ;
  RigidBodyComponent *arg1 = (RigidBodyComponent *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  RigidBodyComponent *result = 0 ;
  
  arg1 = (RigidBodyComponent *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return 0;
  } 
  result = (RigidBodyComponent *) &(arg1)->SetPosition((Math::Vector3 const &)*arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_RigidBodyComponent_GetOrientation(void * jarg1) {
  void * jresult ;
  RigidBodyComponent *arg1 = (RigidBodyComponent *) 0 ;
  Math::Matrix3 *result = 0 ;
  
  arg1 = (RigidBodyComponent *)jarg1; 
  result = (Math::Matrix3 *) &((RigidBodyComponent const *)arg1)->GetOrientation();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_RigidBodyComponent_SetOrientation(void * jarg1, void * jarg2) {
  void * jresult ;
  RigidBodyComponent *arg1 = (RigidBodyComponent *) 0 ;
  Math::Matrix3 *arg2 = 0 ;
  RigidBodyComponent *result = 0 ;
  
  arg1 = (RigidBodyComponent *)jarg1; 
  arg2 = (Math::Matrix3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Matrix3 const & type is null", 0);
    return 0;
  } 
  result = (RigidBodyComponent *) &(arg1)->SetOrientation((Math::Matrix3 const &)*arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_RigidBodyComponent_Forward(void * jarg1) {
  void * jresult ;
  RigidBodyComponent *arg1 = (RigidBodyComponent *) 0 ;
  Math::Vector3 result;
  
  arg1 = (RigidBodyComponent *)jarg1; 
  result = (arg1)->Forward();
  jresult = new Math::Vector3((const Math::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_RigidBodyComponent_Right(void * jarg1) {
  void * jresult ;
  RigidBodyComponent *arg1 = (RigidBodyComponent *) 0 ;
  Math::Vector3 result;
  
  arg1 = (RigidBodyComponent *)jarg1; 
  result = (arg1)->Right();
  jresult = new Math::Vector3((const Math::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_RigidBodyComponent_Up(void * jarg1) {
  void * jresult ;
  RigidBodyComponent *arg1 = (RigidBodyComponent *) 0 ;
  Math::Vector3 result;
  
  arg1 = (RigidBodyComponent *)jarg1; 
  result = (arg1)->Up();
  jresult = new Math::Vector3((const Math::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_RigidBodyComponent_GetLinearVelocity(void * jarg1) {
  void * jresult ;
  RigidBodyComponent *arg1 = (RigidBodyComponent *) 0 ;
  Math::Vector3 result;
  
  arg1 = (RigidBodyComponent *)jarg1; 
  result = ((RigidBodyComponent const *)arg1)->GetLinearVelocity();
  jresult = new Math::Vector3((const Math::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_RigidBodyComponent_SetLinearVelocity(void * jarg1, void * jarg2) {
  void * jresult ;
  RigidBodyComponent *arg1 = (RigidBodyComponent *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  RigidBodyComponent *result = 0 ;
  
  arg1 = (RigidBodyComponent *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return 0;
  } 
  result = (RigidBodyComponent *) &(arg1)->SetLinearVelocity((Math::Vector3 const &)*arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_RigidBodyComponent_GetAngularVelocity(void * jarg1) {
  void * jresult ;
  RigidBodyComponent *arg1 = (RigidBodyComponent *) 0 ;
  Math::Vector3 result;
  
  arg1 = (RigidBodyComponent *)jarg1; 
  result = ((RigidBodyComponent const *)arg1)->GetAngularVelocity();
  jresult = new Math::Vector3((const Math::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_RigidBodyComponent_SetAngularVelocity(void * jarg1, void * jarg2) {
  void * jresult ;
  RigidBodyComponent *arg1 = (RigidBodyComponent *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  RigidBodyComponent *result = 0 ;
  
  arg1 = (RigidBodyComponent *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return 0;
  } 
  result = (RigidBodyComponent *) &(arg1)->SetAngularVelocity((Math::Vector3 const &)*arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_RigidBodyComponent_ApplyForce(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  RigidBodyComponent *arg1 = (RigidBodyComponent *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  Math::Vector3 *arg3 = 0 ;
  RigidBodyComponent *result = 0 ;
  
  arg1 = (RigidBodyComponent *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return 0;
  } 
  arg3 = (Math::Vector3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return 0;
  } 
  result = (RigidBodyComponent *) &(arg1)->ApplyForce((Math::Vector3 const &)*arg2,(Math::Vector3 const &)*arg3);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_RigidBodyComponent_ApplyLinearForce(void * jarg1, void * jarg2) {
  void * jresult ;
  RigidBodyComponent *arg1 = (RigidBodyComponent *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  RigidBodyComponent *result = 0 ;
  
  arg1 = (RigidBodyComponent *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return 0;
  } 
  result = (RigidBodyComponent *) &(arg1)->ApplyLinearForce((Math::Vector3 const &)*arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_RigidBodyComponent_ApplyAngularForce(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  RigidBodyComponent *arg1 = (RigidBodyComponent *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  Math::Vector3 *arg3 = 0 ;
  RigidBodyComponent *result = 0 ;
  
  arg1 = (RigidBodyComponent *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return 0;
  } 
  arg3 = (Math::Vector3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return 0;
  } 
  result = (RigidBodyComponent *) &(arg1)->ApplyAngularForce((Math::Vector3 const &)*arg2,(Math::Vector3 const &)*arg3);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_RigidBodyComponent_ApplyMasslessForce(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  RigidBodyComponent *arg1 = (RigidBodyComponent *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  Math::Vector3 *arg3 = 0 ;
  RigidBodyComponent *result = 0 ;
  
  arg1 = (RigidBodyComponent *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return 0;
  } 
  arg3 = (Math::Vector3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return 0;
  } 
  result = (RigidBodyComponent *) &(arg1)->ApplyMasslessForce((Math::Vector3 const &)*arg2,(Math::Vector3 const &)*arg3);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_RigidBodyComponent_ApplyLinearMasslessForce(void * jarg1, void * jarg2) {
  void * jresult ;
  RigidBodyComponent *arg1 = (RigidBodyComponent *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  RigidBodyComponent *result = 0 ;
  
  arg1 = (RigidBodyComponent *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return 0;
  } 
  result = (RigidBodyComponent *) &(arg1)->ApplyLinearMasslessForce((Math::Vector3 const &)*arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_RigidBodyComponent_ApplyAngularMasslessForce(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  RigidBodyComponent *arg1 = (RigidBodyComponent *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  Math::Vector3 *arg3 = 0 ;
  RigidBodyComponent *result = 0 ;
  
  arg1 = (RigidBodyComponent *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return 0;
  } 
  arg3 = (Math::Vector3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return 0;
  } 
  result = (RigidBodyComponent *) &(arg1)->ApplyAngularMasslessForce((Math::Vector3 const &)*arg2,(Math::Vector3 const &)*arg3);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_RigidBodyComponent_ApplyImpulse(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  RigidBodyComponent *arg1 = (RigidBodyComponent *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  Math::Vector3 *arg3 = 0 ;
  RigidBodyComponent *result = 0 ;
  
  arg1 = (RigidBodyComponent *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return 0;
  } 
  arg3 = (Math::Vector3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return 0;
  } 
  result = (RigidBodyComponent *) &(arg1)->ApplyImpulse((Math::Vector3 const &)*arg2,(Math::Vector3 const &)*arg3);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_RigidBodyComponent_ApplyLinearImpulse(void * jarg1, void * jarg2) {
  void * jresult ;
  RigidBodyComponent *arg1 = (RigidBodyComponent *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  RigidBodyComponent *result = 0 ;
  
  arg1 = (RigidBodyComponent *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return 0;
  } 
  result = (RigidBodyComponent *) &(arg1)->ApplyLinearImpulse((Math::Vector3 const &)*arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_RigidBodyComponent_ApplyAngularImpulse(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  RigidBodyComponent *arg1 = (RigidBodyComponent *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  Math::Vector3 *arg3 = 0 ;
  RigidBodyComponent *result = 0 ;
  
  arg1 = (RigidBodyComponent *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return 0;
  } 
  arg3 = (Math::Vector3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return 0;
  } 
  result = (RigidBodyComponent *) &(arg1)->ApplyAngularImpulse((Math::Vector3 const &)*arg2,(Math::Vector3 const &)*arg3);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_RigidBodyComponent_ApplyImmediateImpulse(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  RigidBodyComponent *arg1 = (RigidBodyComponent *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  Math::Vector3 *arg3 = 0 ;
  RigidBodyComponent *result = 0 ;
  
  arg1 = (RigidBodyComponent *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return 0;
  } 
  arg3 = (Math::Vector3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return 0;
  } 
  result = (RigidBodyComponent *) &(arg1)->ApplyImmediateImpulse((Math::Vector3 const &)*arg2,(Math::Vector3 const &)*arg3);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_RigidBodyComponent_GetAllowRotation(void * jarg1) {
  unsigned int jresult ;
  RigidBodyComponent *arg1 = (RigidBodyComponent *) 0 ;
  bool result;
  
  arg1 = (RigidBodyComponent *)jarg1; 
  result = (bool)((RigidBodyComponent const *)arg1)->GetAllowRotation();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_RigidBodyComponent_SetAllowRotation(void * jarg1, unsigned int jarg2) {
  void * jresult ;
  RigidBodyComponent *arg1 = (RigidBodyComponent *) 0 ;
  bool arg2 ;
  RigidBodyComponent *result = 0 ;
  
  arg1 = (RigidBodyComponent *)jarg1; 
  arg2 = jarg2 ? true : false; 
  result = (RigidBodyComponent *) &(arg1)->SetAllowRotation(arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_RigidBodyComponent_GetHasGravity(void * jarg1) {
  unsigned int jresult ;
  RigidBodyComponent *arg1 = (RigidBodyComponent *) 0 ;
  bool result;
  
  arg1 = (RigidBodyComponent *)jarg1; 
  result = (bool)((RigidBodyComponent const *)arg1)->GetHasGravity();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_RigidBodyComponent_SetHasGravity(void * jarg1, unsigned int jarg2) {
  void * jresult ;
  RigidBodyComponent *arg1 = (RigidBodyComponent *) 0 ;
  bool arg2 ;
  RigidBodyComponent *result = 0 ;
  
  arg1 = (RigidBodyComponent *)jarg1; 
  arg2 = jarg2 ? true : false; 
  result = (RigidBodyComponent *) &(arg1)->SetHasGravity(arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_RigidBody_ApplyForce(void * jarg1, void * jarg2, void * jarg3) {
  RigidBody *arg1 = (RigidBody *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  Math::Vector3 *arg3 = 0 ;
  
  arg1 = (RigidBody *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  arg3 = (Math::Vector3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  (arg1)->ApplyForce((Math::Vector3 const &)*arg2,(Math::Vector3 const &)*arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_RigidBody_ApplyLinearForce(void * jarg1, void * jarg2) {
  RigidBody *arg1 = (RigidBody *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  
  arg1 = (RigidBody *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  (arg1)->ApplyLinearForce((Math::Vector3 const &)*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_RigidBody_ApplyAngularForce(void * jarg1, void * jarg2, void * jarg3) {
  RigidBody *arg1 = (RigidBody *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  Math::Vector3 *arg3 = 0 ;
  
  arg1 = (RigidBody *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  arg3 = (Math::Vector3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  (arg1)->ApplyAngularForce((Math::Vector3 const &)*arg2,(Math::Vector3 const &)*arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_RigidBody_ApplyMasslessForce(void * jarg1, void * jarg2, void * jarg3) {
  RigidBody *arg1 = (RigidBody *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  Math::Vector3 *arg3 = 0 ;
  
  arg1 = (RigidBody *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  arg3 = (Math::Vector3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  (arg1)->ApplyMasslessForce((Math::Vector3 const &)*arg2,(Math::Vector3 const &)*arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_RigidBody_ApplyLinearMasslessForce(void * jarg1, void * jarg2) {
  RigidBody *arg1 = (RigidBody *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  
  arg1 = (RigidBody *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  (arg1)->ApplyLinearMasslessForce((Math::Vector3 const &)*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_RigidBody_ApplyAngularMasslessForce(void * jarg1, void * jarg2, void * jarg3) {
  RigidBody *arg1 = (RigidBody *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  Math::Vector3 *arg3 = 0 ;
  
  arg1 = (RigidBody *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  arg3 = (Math::Vector3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  (arg1)->ApplyAngularMasslessForce((Math::Vector3 const &)*arg2,(Math::Vector3 const &)*arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_RigidBody_ApplyImpulse(void * jarg1, void * jarg2, void * jarg3) {
  RigidBody *arg1 = (RigidBody *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  Math::Vector3 *arg3 = 0 ;
  
  arg1 = (RigidBody *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  arg3 = (Math::Vector3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  (arg1)->ApplyImpulse((Math::Vector3 const &)*arg2,(Math::Vector3 const &)*arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_RigidBody_ApplyLinearImpulse(void * jarg1, void * jarg2) {
  RigidBody *arg1 = (RigidBody *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  
  arg1 = (RigidBody *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  (arg1)->ApplyLinearImpulse((Math::Vector3 const &)*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_RigidBody_ApplyAngularImpulse(void * jarg1, void * jarg2, void * jarg3) {
  RigidBody *arg1 = (RigidBody *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  Math::Vector3 *arg3 = 0 ;
  
  arg1 = (RigidBody *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  arg3 = (Math::Vector3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  (arg1)->ApplyAngularImpulse((Math::Vector3 const &)*arg2,(Math::Vector3 const &)*arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_RigidBody_ApplyImmediateImpulse(void * jarg1, void * jarg2, void * jarg3) {
  RigidBody *arg1 = (RigidBody *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  Math::Vector3 *arg3 = 0 ;
  
  arg1 = (RigidBody *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  arg3 = (Math::Vector3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  (arg1)->ApplyImmediateImpulse((Math::Vector3 const &)*arg2,(Math::Vector3 const &)*arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_RigidBody_SetPosition(void * jarg1, void * jarg2) {
  RigidBody *arg1 = (RigidBody *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  
  arg1 = (RigidBody *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  (arg1)->SetPosition((Math::Vector3 const &)*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_RigidBody_SetOrientation(void * jarg1, void * jarg2) {
  RigidBody *arg1 = (RigidBody *) 0 ;
  Math::Matrix3 arg2 ;
  Math::Matrix3 *argp2 ;
  
  arg1 = (RigidBody *)jarg1; 
  argp2 = (Math::Matrix3 *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null Math::Matrix3", 0);
    return ;
  }
  arg2 = *argp2; 
  (arg1)->SetOrientation(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_RigidBody_SetLinearVelocity(void * jarg1, void * jarg2) {
  RigidBody *arg1 = (RigidBody *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  
  arg1 = (RigidBody *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  (arg1)->SetLinearVelocity((Math::Vector3 const &)*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_RigidBody_SetAngularVelocity(void * jarg1, void * jarg2) {
  RigidBody *arg1 = (RigidBody *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  
  arg1 = (RigidBody *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  (arg1)->SetAngularVelocity((Math::Vector3 const &)*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_RigidBody_SetAwake(void * jarg1, unsigned int jarg2) {
  RigidBody *arg1 = (RigidBody *) 0 ;
  bool arg2 ;
  
  arg1 = (RigidBody *)jarg1; 
  arg2 = jarg2 ? true : false; 
  (arg1)->SetAwake(arg2);
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_RigidBody_AllowRotation(void * jarg1) {
  unsigned int jresult ;
  RigidBody *arg1 = (RigidBody *) 0 ;
  bool result;
  
  arg1 = (RigidBody *)jarg1; 
  result = (bool)((RigidBody const *)arg1)->AllowRotation();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_RigidBody_SetAllowRotation(void * jarg1, unsigned int jarg2) {
  RigidBody *arg1 = (RigidBody *) 0 ;
  bool arg2 ;
  
  arg1 = (RigidBody *)jarg1; 
  arg2 = jarg2 ? true : false; 
  (arg1)->SetAllowRotation(arg2);
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_RigidBody_HasGravity(void * jarg1) {
  unsigned int jresult ;
  RigidBody *arg1 = (RigidBody *) 0 ;
  bool result;
  
  arg1 = (RigidBody *)jarg1; 
  result = (bool)((RigidBody const *)arg1)->HasGravity();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_RigidBody_SetHasGravity(void * jarg1, unsigned int jarg2) {
  RigidBody *arg1 = (RigidBody *) 0 ;
  bool arg2 ;
  
  arg1 = (RigidBody *)jarg1; 
  arg2 = jarg2 ? true : false; 
  (arg1)->SetHasGravity(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_RigidBody_Position(void * jarg1) {
  void * jresult ;
  RigidBody *arg1 = (RigidBody *) 0 ;
  Math::Vector3 *result = 0 ;
  
  arg1 = (RigidBody *)jarg1; 
  result = (Math::Vector3 *) &((RigidBody const *)arg1)->Position();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_RigidBody_LinearVelocity(void * jarg1) {
  void * jresult ;
  RigidBody *arg1 = (RigidBody *) 0 ;
  Math::Vector3 *result = 0 ;
  
  arg1 = (RigidBody *)jarg1; 
  result = (Math::Vector3 *) &((RigidBody const *)arg1)->LinearVelocity();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_RigidBody_Orientation(void * jarg1) {
  void * jresult ;
  RigidBody *arg1 = (RigidBody *) 0 ;
  Math::Matrix3 *result = 0 ;
  
  arg1 = (RigidBody *)jarg1; 
  result = (Math::Matrix3 *) &((RigidBody const *)arg1)->Orientation();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_RigidBody_InverseOrienation(void * jarg1) {
  void * jresult ;
  RigidBody *arg1 = (RigidBody *) 0 ;
  Math::Matrix3 *result = 0 ;
  
  arg1 = (RigidBody *)jarg1; 
  result = (Math::Matrix3 *) &((RigidBody const *)arg1)->InverseOrienation();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_RigidBody_AngularVelocity(void * jarg1) {
  void * jresult ;
  RigidBody *arg1 = (RigidBody *) 0 ;
  Math::Vector3 *result = 0 ;
  
  arg1 = (RigidBody *)jarg1; 
  result = (Math::Vector3 *) &((RigidBody const *)arg1)->AngularVelocity();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Vector3Vector_Clear(void * jarg1) {
  std::vector< Math::Vector3 > *arg1 = (std::vector< Math::Vector3 > *) 0 ;
  
  arg1 = (std::vector< Math::Vector3 > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_Vector3Vector_Add(void * jarg1, void * jarg2) {
  std::vector< Math::Vector3 > *arg1 = (std::vector< Math::Vector3 > *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  
  arg1 = (std::vector< Math::Vector3 > *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  (arg1)->push_back((Math::Vector3 const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_Vector3Vector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< Math::Vector3 > *arg1 = (std::vector< Math::Vector3 > *) 0 ;
  std::vector< Math::Vector3 >::size_type result;
  
  arg1 = (std::vector< Math::Vector3 > *)jarg1; 
  result = ((std::vector< Math::Vector3 > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_Vector3Vector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< Math::Vector3 > *arg1 = (std::vector< Math::Vector3 > *) 0 ;
  std::vector< Math::Vector3 >::size_type result;
  
  arg1 = (std::vector< Math::Vector3 > *)jarg1; 
  result = ((std::vector< Math::Vector3 > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Vector3Vector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< Math::Vector3 > *arg1 = (std::vector< Math::Vector3 > *) 0 ;
  std::vector< Math::Vector3 >::size_type arg2 ;
  
  arg1 = (std::vector< Math::Vector3 > *)jarg1; 
  arg2 = (std::vector< Math::Vector3 >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Vector3Vector__SWIG_0() {
  void * jresult ;
  std::vector< Math::Vector3 > *result = 0 ;
  
  result = (std::vector< Math::Vector3 > *)new std::vector< Math::Vector3 >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Vector3Vector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< Math::Vector3 > *arg1 = 0 ;
  std::vector< Math::Vector3 > *result = 0 ;
  
  arg1 = (std::vector< Math::Vector3 > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< Math::Vector3 > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< Math::Vector3 > *)new std::vector< Math::Vector3 >((std::vector< Math::Vector3 > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Vector3Vector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< Math::Vector3 > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< Math::Vector3 > *)new_std_vector_Sl_Math_Vector3_Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Vector3Vector_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< Math::Vector3 > *arg1 = (std::vector< Math::Vector3 > *) 0 ;
  int arg2 ;
  Math::Vector3 result;
  
  arg1 = (std::vector< Math::Vector3 > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_Math_Vector3_Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = new Math::Vector3((const Math::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Vector3Vector_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< Math::Vector3 > *arg1 = (std::vector< Math::Vector3 > *) 0 ;
  int arg2 ;
  Math::Vector3 *result = 0 ;
  
  arg1 = (std::vector< Math::Vector3 > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (Math::Vector3 *) &std_vector_Sl_Math_Vector3_Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Vector3Vector_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< Math::Vector3 > *arg1 = (std::vector< Math::Vector3 > *) 0 ;
  int arg2 ;
  Math::Vector3 *arg3 = 0 ;
  
  arg1 = (std::vector< Math::Vector3 > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (Math::Vector3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_Math_Vector3_Sg__setitem(arg1,arg2,(Math::Vector3 const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_Vector3Vector_AddRange(void * jarg1, void * jarg2) {
  std::vector< Math::Vector3 > *arg1 = (std::vector< Math::Vector3 > *) 0 ;
  std::vector< Math::Vector3 > *arg2 = 0 ;
  
  arg1 = (std::vector< Math::Vector3 > *)jarg1; 
  arg2 = (std::vector< Math::Vector3 > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< Math::Vector3 > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_Math_Vector3_Sg__AddRange(arg1,(std::vector< Math::Vector3 > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Vector3Vector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< Math::Vector3 > *arg1 = (std::vector< Math::Vector3 > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< Math::Vector3 > *result = 0 ;
  
  arg1 = (std::vector< Math::Vector3 > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< Math::Vector3 > *)std_vector_Sl_Math_Vector3_Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Vector3Vector_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< Math::Vector3 > *arg1 = (std::vector< Math::Vector3 > *) 0 ;
  int arg2 ;
  Math::Vector3 *arg3 = 0 ;
  
  arg1 = (std::vector< Math::Vector3 > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (Math::Vector3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_Math_Vector3_Sg__Insert(arg1,arg2,(Math::Vector3 const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_Vector3Vector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< Math::Vector3 > *arg1 = (std::vector< Math::Vector3 > *) 0 ;
  int arg2 ;
  std::vector< Math::Vector3 > *arg3 = 0 ;
  
  arg1 = (std::vector< Math::Vector3 > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< Math::Vector3 > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< Math::Vector3 > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_Math_Vector3_Sg__InsertRange(arg1,arg2,(std::vector< Math::Vector3 > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_Vector3Vector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< Math::Vector3 > *arg1 = (std::vector< Math::Vector3 > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< Math::Vector3 > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_Math_Vector3_Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_Vector3Vector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< Math::Vector3 > *arg1 = (std::vector< Math::Vector3 > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< Math::Vector3 > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_Math_Vector3_Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Vector3Vector_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  Math::Vector3 *arg1 = 0 ;
  int arg2 ;
  std::vector< Math::Vector3 > *result = 0 ;
  
  arg1 = (Math::Vector3 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return 0;
  } 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< Math::Vector3 > *)std_vector_Sl_Math_Vector3_Sg__Repeat((Math::Vector3 const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Vector3Vector_Reverse__SWIG_0(void * jarg1) {
  std::vector< Math::Vector3 > *arg1 = (std::vector< Math::Vector3 > *) 0 ;
  
  arg1 = (std::vector< Math::Vector3 > *)jarg1; 
  std_vector_Sl_Math_Vector3_Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_Vector3Vector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< Math::Vector3 > *arg1 = (std::vector< Math::Vector3 > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< Math::Vector3 > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_Math_Vector3_Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_Vector3Vector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< Math::Vector3 > *arg1 = (std::vector< Math::Vector3 > *) 0 ;
  int arg2 ;
  std::vector< Math::Vector3 > *arg3 = 0 ;
  
  arg1 = (std::vector< Math::Vector3 > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< Math::Vector3 > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< Math::Vector3 > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_Math_Vector3_Sg__SetRange(arg1,arg2,(std::vector< Math::Vector3 > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_Vector3Vector(void * jarg1) {
  std::vector< Math::Vector3 > *arg1 = (std::vector< Math::Vector3 > *) 0 ;
  
  arg1 = (std::vector< Math::Vector3 > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CollisionData_collidedObj_set(void * jarg1, void * jarg2) {
  CollisionData *arg1 = (CollisionData *) 0 ;
  GameObject *arg2 = (GameObject *) 0 ;
  
  arg1 = (CollisionData *)jarg1; 
  arg2 = (GameObject *)jarg2; 
  if (arg1) (arg1)->collidedObj = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CollisionData_collidedObj_get(void * jarg1) {
  void * jresult ;
  CollisionData *arg1 = (CollisionData *) 0 ;
  GameObject *result = 0 ;
  
  arg1 = (CollisionData *)jarg1; 
  result = (GameObject *) ((arg1)->collidedObj);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CollisionData_selfCPhy_set(void * jarg1, void * jarg2) {
  CollisionData *arg1 = (CollisionData *) 0 ;
  CPhysics *arg2 = (CPhysics *) 0 ;
  
  arg1 = (CollisionData *)jarg1; 
  arg2 = (CPhysics *)jarg2; 
  if (arg1) (arg1)->selfCPhy = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CollisionData_selfCPhy_get(void * jarg1) {
  void * jresult ;
  CollisionData *arg1 = (CollisionData *) 0 ;
  CPhysics *result = 0 ;
  
  arg1 = (CollisionData *)jarg1; 
  result = (CPhysics *) ((arg1)->selfCPhy);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CollisionData_collidedObjCPhy_set(void * jarg1, void * jarg2) {
  CollisionData *arg1 = (CollisionData *) 0 ;
  CPhysics *arg2 = (CPhysics *) 0 ;
  
  arg1 = (CollisionData *)jarg1; 
  arg2 = (CPhysics *)jarg2; 
  if (arg1) (arg1)->collidedObjCPhy = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CollisionData_collidedObjCPhy_get(void * jarg1) {
  void * jresult ;
  CollisionData *arg1 = (CollisionData *) 0 ;
  CPhysics *result = 0 ;
  
  arg1 = (CollisionData *)jarg1; 
  result = (CPhysics *) ((arg1)->collidedObjCPhy);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CollisionData_normals_set(void * jarg1, void * jarg2) {
  CollisionData *arg1 = (CollisionData *) 0 ;
  std::vector< Math::Vector3 > *arg2 = (std::vector< Math::Vector3 > *) 0 ;
  
  arg1 = (CollisionData *)jarg1; 
  arg2 = (std::vector< Math::Vector3 > *)jarg2; 
  if (arg1) (arg1)->normals = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CollisionData_normals_get(void * jarg1) {
  void * jresult ;
  CollisionData *arg1 = (CollisionData *) 0 ;
  std::vector< Math::Vector3 > *result = 0 ;
  
  arg1 = (CollisionData *)jarg1; 
  result = (std::vector< Math::Vector3 > *)& ((arg1)->normals);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CollisionData_numContacts_set(void * jarg1, int jarg2) {
  CollisionData *arg1 = (CollisionData *) 0 ;
  int arg2 ;
  
  arg1 = (CollisionData *)jarg1; 
  arg2 = (int)jarg2; 
  if (arg1) (arg1)->numContacts = arg2;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CollisionData_numContacts_get(void * jarg1) {
  int jresult ;
  CollisionData *arg1 = (CollisionData *) 0 ;
  int result;
  
  arg1 = (CollisionData *)jarg1; 
  result = (int) ((arg1)->numContacts);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CollisionData_isA_set(void * jarg1, unsigned int jarg2) {
  CollisionData *arg1 = (CollisionData *) 0 ;
  bool arg2 ;
  
  arg1 = (CollisionData *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->isA = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CollisionData_isA_get(void * jarg1) {
  unsigned int jresult ;
  CollisionData *arg1 = (CollisionData *) 0 ;
  bool result;
  
  arg1 = (CollisionData *)jarg1; 
  result = (bool) ((arg1)->isA);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_ColliderComponent_GetCollider(void * jarg1) {
  void * jresult ;
  ColliderComponent *arg1 = (ColliderComponent *) 0 ;
  Collider *result = 0 ;
  
  arg1 = (ColliderComponent *)jarg1; 
  result = (Collider *) &((ColliderComponent const *)arg1)->GetCollider();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_ColliderComponent_ContactRecord_numContacts_set(void * jarg1, unsigned char jarg2) {
  ColliderComponent::ContactRecord *arg1 = (ColliderComponent::ContactRecord *) 0 ;
  unsigned char arg2 ;
  
  arg1 = (ColliderComponent::ContactRecord *)jarg1; 
  arg2 = (unsigned char)jarg2; 
  if (arg1) (arg1)->numContacts = arg2;
}


SWIGEXPORT unsigned char SWIGSTDCALL CSharp_ColliderComponent_ContactRecord_numContacts_get(void * jarg1) {
  unsigned char jresult ;
  ColliderComponent::ContactRecord *arg1 = (ColliderComponent::ContactRecord *) 0 ;
  unsigned char result;
  
  arg1 = (ColliderComponent::ContactRecord *)jarg1; 
  result = (unsigned char) ((arg1)->numContacts);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_ColliderComponent_ContactRecord_Contact_position_set(void * jarg1, void * jarg2) {
  ColliderComponent::ContactRecord::Contact *arg1 = (ColliderComponent::ContactRecord::Contact *) 0 ;
  Math::Vector3 *arg2 = (Math::Vector3 *) 0 ;
  
  arg1 = (ColliderComponent::ContactRecord::Contact *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2; 
  if (arg1) (arg1)->position = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_ColliderComponent_ContactRecord_Contact_position_get(void * jarg1) {
  void * jresult ;
  ColliderComponent::ContactRecord::Contact *arg1 = (ColliderComponent::ContactRecord::Contact *) 0 ;
  Math::Vector3 *result = 0 ;
  
  arg1 = (ColliderComponent::ContactRecord::Contact *)jarg1; 
  result = (Math::Vector3 *)& ((arg1)->position);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_ColliderComponent_ContactRecord_Contact_normal_set(void * jarg1, void * jarg2) {
  ColliderComponent::ContactRecord::Contact *arg1 = (ColliderComponent::ContactRecord::Contact *) 0 ;
  Math::Vector3 *arg2 = (Math::Vector3 *) 0 ;
  
  arg1 = (ColliderComponent::ContactRecord::Contact *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2; 
  if (arg1) (arg1)->normal = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_ColliderComponent_ContactRecord_Contact_normal_get(void * jarg1) {
  void * jresult ;
  ColliderComponent::ContactRecord::Contact *arg1 = (ColliderComponent::ContactRecord::Contact *) 0 ;
  Math::Vector3 *result = 0 ;
  
  arg1 = (ColliderComponent::ContactRecord::Contact *)jarg1; 
  result = (Math::Vector3 *)& ((arg1)->normal);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_ColliderComponent_ContactRecord_Contact_penetration_set(void * jarg1, float jarg2) {
  ColliderComponent::ContactRecord::Contact *arg1 = (ColliderComponent::ContactRecord::Contact *) 0 ;
  float arg2 ;
  
  arg1 = (ColliderComponent::ContactRecord::Contact *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->penetration = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_ColliderComponent_ContactRecord_Contact_penetration_get(void * jarg1) {
  float jresult ;
  ColliderComponent::ContactRecord::Contact *arg1 = (ColliderComponent::ContactRecord::Contact *) 0 ;
  float result;
  
  arg1 = (ColliderComponent::ContactRecord::Contact *)jarg1; 
  result = (float) ((arg1)->penetration);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_ColliderComponent_ContactRecord_Contact_normalRelativeVelocity_set(void * jarg1, void * jarg2) {
  ColliderComponent::ContactRecord::Contact *arg1 = (ColliderComponent::ContactRecord::Contact *) 0 ;
  Math::Vector3 *arg2 = (Math::Vector3 *) 0 ;
  
  arg1 = (ColliderComponent::ContactRecord::Contact *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2; 
  if (arg1) (arg1)->normalRelativeVelocity = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_ColliderComponent_ContactRecord_Contact_normalRelativeVelocity_get(void * jarg1) {
  void * jresult ;
  ColliderComponent::ContactRecord::Contact *arg1 = (ColliderComponent::ContactRecord::Contact *) 0 ;
  Math::Vector3 *result = 0 ;
  
  arg1 = (ColliderComponent::ContactRecord::Contact *)jarg1; 
  result = (Math::Vector3 *)& ((arg1)->normalRelativeVelocity);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_ColliderComponent_ContactRecord_Contact_tangentRelativeVelocity_set(void * jarg1, void * jarg2) {
  ColliderComponent::ContactRecord::Contact *arg1 = (ColliderComponent::ContactRecord::Contact *) 0 ;
  Math::Vector3 *arg2 = (Math::Vector3 *) 0 ;
  
  arg1 = (ColliderComponent::ContactRecord::Contact *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2; 
  if (arg1) (arg1)->tangentRelativeVelocity = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_ColliderComponent_ContactRecord_Contact_tangentRelativeVelocity_get(void * jarg1) {
  void * jresult ;
  ColliderComponent::ContactRecord::Contact *arg1 = (ColliderComponent::ContactRecord::Contact *) 0 ;
  Math::Vector3 *result = 0 ;
  
  arg1 = (ColliderComponent::ContactRecord::Contact *)jarg1; 
  result = (Math::Vector3 *)& ((arg1)->tangentRelativeVelocity);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_ColliderComponent_ContactRecord_Contact_normalImpulse_set(void * jarg1, void * jarg2) {
  ColliderComponent::ContactRecord::Contact *arg1 = (ColliderComponent::ContactRecord::Contact *) 0 ;
  Math::Vector3 *arg2 = (Math::Vector3 *) 0 ;
  
  arg1 = (ColliderComponent::ContactRecord::Contact *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2; 
  if (arg1) (arg1)->normalImpulse = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_ColliderComponent_ContactRecord_Contact_normalImpulse_get(void * jarg1) {
  void * jresult ;
  ColliderComponent::ContactRecord::Contact *arg1 = (ColliderComponent::ContactRecord::Contact *) 0 ;
  Math::Vector3 *result = 0 ;
  
  arg1 = (ColliderComponent::ContactRecord::Contact *)jarg1; 
  result = (Math::Vector3 *)& ((arg1)->normalImpulse);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_ColliderComponent_ContactRecord_Contact_tangentImpulse_set(void * jarg1, void * jarg2) {
  ColliderComponent::ContactRecord::Contact *arg1 = (ColliderComponent::ContactRecord::Contact *) 0 ;
  Math::Vector3 *arg2 = (Math::Vector3 *) 0 ;
  
  arg1 = (ColliderComponent::ContactRecord::Contact *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2; 
  if (arg1) (arg1)->tangentImpulse = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_ColliderComponent_ContactRecord_Contact_tangentImpulse_get(void * jarg1) {
  void * jresult ;
  ColliderComponent::ContactRecord::Contact *arg1 = (ColliderComponent::ContactRecord::Contact *) 0 ;
  Math::Vector3 *result = 0 ;
  
  arg1 = (ColliderComponent::ContactRecord::Contact *)jarg1; 
  result = (Math::Vector3 *)& ((arg1)->tangentImpulse);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_ColliderComponent_ContactRecord_Contact() {
  void * jresult ;
  ColliderComponent::ContactRecord::Contact *result = 0 ;
  
  result = (ColliderComponent::ContactRecord::Contact *)new ColliderComponent::ContactRecord::Contact();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_ColliderComponent_ContactRecord_Contact(void * jarg1) {
  ColliderComponent::ContactRecord::Contact *arg1 = (ColliderComponent::ContactRecord::Contact *) 0 ;
  
  arg1 = (ColliderComponent::ContactRecord::Contact *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_ColliderComponent_ContactRecord_contacts_set(void * jarg1, void * jarg2) {
  ColliderComponent::ContactRecord *arg1 = (ColliderComponent::ContactRecord *) 0 ;
  ColliderComponent::ContactRecord::Contact *arg2 ;
  
  arg1 = (ColliderComponent::ContactRecord *)jarg1; 
  arg2 = (ColliderComponent::ContactRecord::Contact *)jarg2; 
  {
    size_t ii;
    ColliderComponent::ContactRecord::Contact *b = (ColliderComponent::ContactRecord::Contact *) arg1->contacts;
    for (ii = 0; ii < (size_t)ContactManifold::k_maxContacts; ii++) b[ii] = *((ColliderComponent::ContactRecord::Contact *) arg2 + ii);
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_ColliderComponent_ContactRecord_contacts_get(void * jarg1) {
  void * jresult ;
  ColliderComponent::ContactRecord *arg1 = (ColliderComponent::ContactRecord *) 0 ;
  ColliderComponent::ContactRecord::Contact *result = 0 ;
  
  arg1 = (ColliderComponent::ContactRecord *)jarg1; 
  result = (ColliderComponent::ContactRecord::Contact *)(ColliderComponent::ContactRecord::Contact *) ((arg1)->contacts);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_ColliderComponent_ContactRecord_wasColliding_set(void * jarg1, unsigned int jarg2) {
  ColliderComponent::ContactRecord *arg1 = (ColliderComponent::ContactRecord *) 0 ;
  bool arg2 ;
  
  arg1 = (ColliderComponent::ContactRecord *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->wasColliding = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_ColliderComponent_ContactRecord_wasColliding_get(void * jarg1) {
  unsigned int jresult ;
  ColliderComponent::ContactRecord *arg1 = (ColliderComponent::ContactRecord *) 0 ;
  bool result;
  
  arg1 = (ColliderComponent::ContactRecord *)jarg1; 
  result = (bool) ((arg1)->wasColliding);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_ColliderComponent_ContactRecord_isColliding_set(void * jarg1, unsigned int jarg2) {
  ColliderComponent::ContactRecord *arg1 = (ColliderComponent::ContactRecord *) 0 ;
  bool arg2 ;
  
  arg1 = (ColliderComponent::ContactRecord *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->isColliding = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_ColliderComponent_ContactRecord_isColliding_get(void * jarg1) {
  unsigned int jresult ;
  ColliderComponent::ContactRecord *arg1 = (ColliderComponent::ContactRecord *) 0 ;
  bool result;
  
  arg1 = (ColliderComponent::ContactRecord *)jarg1; 
  result = (bool) ((arg1)->isColliding);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_ColliderComponent_ContactRecord_Other(void * jarg1) {
  void * jresult ;
  ColliderComponent::ContactRecord *arg1 = (ColliderComponent::ContactRecord *) 0 ;
  ColliderComponent *result = 0 ;
  
  arg1 = (ColliderComponent::ContactRecord *)jarg1; 
  result = (ColliderComponent *) &((ColliderComponent::ContactRecord const *)arg1)->Other();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_ColliderComponent_SetMass(void * jarg1, float jarg2) {
  ColliderComponent *arg1 = (ColliderComponent *) 0 ;
  float arg2 ;
  
  arg1 = (ColliderComponent *)jarg1; 
  arg2 = (float)jarg2; 
  (arg1)->SetMass(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_ColliderComponent_mCollider_set(void * jarg1, void * jarg2) {
  ColliderComponent *arg1 = (ColliderComponent *) 0 ;
  Collider *arg2 = (Collider *) 0 ;
  
  arg1 = (ColliderComponent *)jarg1; 
  arg2 = (Collider *)jarg2; 
  if (arg1) (arg1)->mCollider = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_ColliderComponent_mCollider_get(void * jarg1) {
  void * jresult ;
  ColliderComponent *arg1 = (ColliderComponent *) 0 ;
  Collider *result = 0 ;
  
  arg1 = (ColliderComponent *)jarg1; 
  result = (Collider *) ((arg1)->mCollider);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CBoxColliderComponent_GetCenter(void * jarg1) {
  void * jresult ;
  CBoxColliderComponent *arg1 = (CBoxColliderComponent *) 0 ;
  Math::Vector3 *result = 0 ;
  
  arg1 = (CBoxColliderComponent *)jarg1; 
  result = (Math::Vector3 *) &((CBoxColliderComponent const *)arg1)->GetCenter();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CBoxColliderComponent_SetCenter(void * jarg1, void * jarg2) {
  void * jresult ;
  CBoxColliderComponent *arg1 = (CBoxColliderComponent *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  CBoxColliderComponent *result = 0 ;
  
  arg1 = (CBoxColliderComponent *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return 0;
  } 
  result = (CBoxColliderComponent *) &(arg1)->SetCenter((Math::Vector3 const &)*arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CBoxColliderComponent_GetHalfExtents(void * jarg1) {
  void * jresult ;
  CBoxColliderComponent *arg1 = (CBoxColliderComponent *) 0 ;
  Math::Vector3 *result = 0 ;
  
  arg1 = (CBoxColliderComponent *)jarg1; 
  result = (Math::Vector3 *) &((CBoxColliderComponent const *)arg1)->GetHalfExtents();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CBoxColliderComponent_SetHalfExtents(void * jarg1, void * jarg2) {
  void * jresult ;
  CBoxColliderComponent *arg1 = (CBoxColliderComponent *) 0 ;
  Math::Vector3 *arg2 = 0 ;
  CBoxColliderComponent *result = 0 ;
  
  arg1 = (CBoxColliderComponent *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return 0;
  } 
  result = (CBoxColliderComponent *) &(arg1)->SetHalfExtents((Math::Vector3 const &)*arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCamera_GetNearZ(void * jarg1) {
  float jresult ;
  CCamera *arg1 = (CCamera *) 0 ;
  float result;
  
  arg1 = (CCamera *)jarg1; 
  result = (float)((CCamera const *)arg1)->GetNearZ();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCamera_GetFarZ(void * jarg1) {
  float jresult ;
  CCamera *arg1 = (CCamera *) 0 ;
  float result;
  
  arg1 = (CCamera *)jarg1; 
  result = (float)((CCamera const *)arg1)->GetFarZ();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCamera_GetAspect(void * jarg1) {
  float jresult ;
  CCamera *arg1 = (CCamera *) 0 ;
  float result;
  
  arg1 = (CCamera *)jarg1; 
  result = (float)((CCamera const *)arg1)->GetAspect();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCamera_GetFovY(void * jarg1) {
  float jresult ;
  CCamera *arg1 = (CCamera *) 0 ;
  float result;
  
  arg1 = (CCamera *)jarg1; 
  result = (float)((CCamera const *)arg1)->GetFovY();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCamera_GetFovX(void * jarg1) {
  float jresult ;
  CCamera *arg1 = (CCamera *) 0 ;
  float result;
  
  arg1 = (CCamera *)jarg1; 
  result = (float)((CCamera const *)arg1)->GetFovX();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCamera_GetNearWindowWidth(void * jarg1) {
  float jresult ;
  CCamera *arg1 = (CCamera *) 0 ;
  float result;
  
  arg1 = (CCamera *)jarg1; 
  result = (float)((CCamera const *)arg1)->GetNearWindowWidth();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCamera_GetNearWindowHeight(void * jarg1) {
  float jresult ;
  CCamera *arg1 = (CCamera *) 0 ;
  float result;
  
  arg1 = (CCamera *)jarg1; 
  result = (float)((CCamera const *)arg1)->GetNearWindowHeight();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCamera_GetFarWindowWidth(void * jarg1) {
  float jresult ;
  CCamera *arg1 = (CCamera *) 0 ;
  float result;
  
  arg1 = (CCamera *)jarg1; 
  result = (float)((CCamera const *)arg1)->GetFarWindowWidth();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCamera_GetFarWindowHeight(void * jarg1) {
  float jresult ;
  CCamera *arg1 = (CCamera *) 0 ;
  float result;
  
  arg1 = (CCamera *)jarg1; 
  result = (float)((CCamera const *)arg1)->GetFarWindowHeight();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCamera_ScreenToWorldPosition(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  CCamera *arg1 = (CCamera *) 0 ;
  int arg2 ;
  int arg3 ;
  Math::Vector3 result;
  
  arg1 = (CCamera *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  result = (arg1)->ScreenToWorldPosition(arg2,arg3);
  jresult = new Math::Vector3((const Math::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CCamera_GetCamType(void * jarg1) {
  int jresult ;
  CCamera *arg1 = (CCamera *) 0 ;
  CCamera::CamType result;
  
  arg1 = (CCamera *)jarg1; 
  result = (CCamera::CamType)(arg1)->GetCamType();
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCamera_FoVmodifier__SWIG_0(void * jarg1) {
  float jresult ;
  CCamera *arg1 = (CCamera *) 0 ;
  float result;
  
  arg1 = (CCamera *)jarg1; 
  result = (float)((CCamera const *)arg1)->FoVmodifier();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCamera_FoVmodifier__SWIG_1(void * jarg1, float jarg2) {
  CCamera *arg1 = (CCamera *) 0 ;
  float arg2 ;
  
  arg1 = (CCamera *)jarg1; 
  arg2 = (float)jarg2; 
  (arg1)->FoVmodifier(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCamera_Strafe(void * jarg1, float jarg2) {
  CCamera *arg1 = (CCamera *) 0 ;
  float arg2 ;
  
  arg1 = (CCamera *)jarg1; 
  arg2 = (float)jarg2; 
  (arg1)->Strafe(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCamera_Walk(void * jarg1, float jarg2) {
  CCamera *arg1 = (CCamera *) 0 ;
  float arg2 ;
  
  arg1 = (CCamera *)jarg1; 
  arg2 = (float)jarg2; 
  (arg1)->Walk(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCamera_Pitch(void * jarg1, float jarg2) {
  CCamera *arg1 = (CCamera *) 0 ;
  float arg2 ;
  
  arg1 = (CCamera *)jarg1; 
  arg2 = (float)jarg2; 
  (arg1)->Pitch(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCamera_RotateY(void * jarg1, float jarg2) {
  CCamera *arg1 = (CCamera *) 0 ;
  float arg2 ;
  
  arg1 = (CCamera *)jarg1; 
  arg2 = (float)jarg2; 
  (arg1)->RotateY(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCamera_SetRenderTarget(void * jarg1, char * jarg2) {
  CCamera *arg1 = (CCamera *) 0 ;
  std::string arg2 ;
  
  arg1 = (CCamera *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  (&arg2)->assign(jarg2); 
  (arg1)->SetRenderTarget(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCamera_mCamType_set(void * jarg1, int jarg2) {
  CCamera *arg1 = (CCamera *) 0 ;
  CCamera::CamType arg2 ;
  
  arg1 = (CCamera *)jarg1; 
  arg2 = (CCamera::CamType)jarg2; 
  if (arg1) (arg1)->mCamType = arg2;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CCamera_mCamType_get(void * jarg1) {
  int jresult ;
  CCamera *arg1 = (CCamera *) 0 ;
  CCamera::CamType result;
  
  arg1 = (CCamera *)jarg1; 
  result = (CCamera::CamType) ((arg1)->mCamType);
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCamera_mActiveProj_set(void * jarg1, int jarg2) {
  CCamera *arg1 = (CCamera *) 0 ;
  CCamera::CamProj arg2 ;
  
  arg1 = (CCamera *)jarg1; 
  arg2 = (CCamera::CamProj)jarg2; 
  if (arg1) (arg1)->mActiveProj = arg2;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CCamera_mActiveProj_get(void * jarg1) {
  int jresult ;
  CCamera *arg1 = (CCamera *) 0 ;
  CCamera::CamProj result;
  
  arg1 = (CCamera *)jarg1; 
  result = (CCamera::CamProj) ((arg1)->mActiveProj);
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCamera_mFoVmodifier_set(void * jarg1, float jarg2) {
  CCamera *arg1 = (CCamera *) 0 ;
  float arg2 ;
  
  arg1 = (CCamera *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mFoVmodifier = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCamera_mFoVmodifier_get(void * jarg1) {
  float jresult ;
  CCamera *arg1 = (CCamera *) 0 ;
  float result;
  
  arg1 = (CCamera *)jarg1; 
  result = (float) ((arg1)->mFoVmodifier);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCamera_DispatchClickMessages_set(void * jarg1, unsigned int jarg2) {
  CCamera *arg1 = (CCamera *) 0 ;
  bool arg2 ;
  
  arg1 = (CCamera *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->DispatchClickMessages = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CCamera_DispatchClickMessages_get(void * jarg1) {
  unsigned int jresult ;
  CCamera *arg1 = (CCamera *) 0 ;
  bool result;
  
  arg1 = (CCamera *)jarg1; 
  result = (bool) ((arg1)->DispatchClickMessages);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCamera_mCameraRT_set(void * jarg1, void * jarg2) {
  CCamera *arg1 = (CCamera *) 0 ;
  AssetHandle *arg2 = (AssetHandle *) 0 ;
  
  arg1 = (CCamera *)jarg1; 
  arg2 = (AssetHandle *)jarg2; 
  if (arg1) (arg1)->mCameraRT = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCamera_mCameraRT_get(void * jarg1) {
  void * jresult ;
  CCamera *arg1 = (CCamera *) 0 ;
  AssetHandle *result = 0 ;
  
  arg1 = (CCamera *)jarg1; 
  result = (AssetHandle *)& ((arg1)->mCameraRT);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCamera_mNearZ_set(void * jarg1, float jarg2) {
  CCamera *arg1 = (CCamera *) 0 ;
  float arg2 ;
  
  arg1 = (CCamera *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mNearZ = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCamera_mNearZ_get(void * jarg1) {
  float jresult ;
  CCamera *arg1 = (CCamera *) 0 ;
  float result;
  
  arg1 = (CCamera *)jarg1; 
  result = (float) ((arg1)->mNearZ);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCamera_mFarZ_set(void * jarg1, float jarg2) {
  CCamera *arg1 = (CCamera *) 0 ;
  float arg2 ;
  
  arg1 = (CCamera *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mFarZ = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCamera_mFarZ_get(void * jarg1) {
  float jresult ;
  CCamera *arg1 = (CCamera *) 0 ;
  float result;
  
  arg1 = (CCamera *)jarg1; 
  result = (float) ((arg1)->mFarZ);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_SoundParameterList__SWIG_0() {
  void * jresult ;
  std::map< std::string,float > *result = 0 ;
  
  result = (std::map< std::string,float > *)new std::map< std::string,float >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_SoundParameterList__SWIG_1(void * jarg1) {
  void * jresult ;
  std::map< std::string,float,std::less< std::string > > *arg1 = 0 ;
  std::map< std::string,float > *result = 0 ;
  
  arg1 = (std::map< std::string,float,std::less< std::string > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::map< std::string,float,std::less< std::string > > const & type is null", 0);
    return 0;
  } 
  result = (std::map< std::string,float > *)new std::map< std::string,float >((std::map< std::string,float,std::less< std::string > > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_SoundParameterList_size(void * jarg1) {
  unsigned long jresult ;
  std::map< std::string,float > *arg1 = (std::map< std::string,float > *) 0 ;
  std::map< std::string,float >::size_type result;
  
  arg1 = (std::map< std::string,float > *)jarg1; 
  result = ((std::map< std::string,float > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_SoundParameterList_empty(void * jarg1) {
  unsigned int jresult ;
  std::map< std::string,float > *arg1 = (std::map< std::string,float > *) 0 ;
  bool result;
  
  arg1 = (std::map< std::string,float > *)jarg1; 
  result = (bool)((std::map< std::string,float > const *)arg1)->empty();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_SoundParameterList_Clear(void * jarg1) {
  std::map< std::string,float > *arg1 = (std::map< std::string,float > *) 0 ;
  
  arg1 = (std::map< std::string,float > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT float SWIGSTDCALL CSharp_SoundParameterList_getitem(void * jarg1, char * jarg2) {
  float jresult ;
  std::map< std::string,float > *arg1 = (std::map< std::string,float > *) 0 ;
  std::map< std::string,float >::key_type *arg2 = 0 ;
  std::map< std::string,float >::mapped_type *result = 0 ;
  
  arg1 = (std::map< std::string,float > *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  std::map< std::string,float >::key_type arg2_str(jarg2);
  arg2 = &arg2_str; 
  try {
    result = (std::map< std::string,float >::mapped_type *) &std_map_Sl_std_string_Sc_float_Sg__getitem(arg1,(std::string const &)*arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = *result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_SoundParameterList_setitem(void * jarg1, char * jarg2, float jarg3) {
  std::map< std::string,float > *arg1 = (std::map< std::string,float > *) 0 ;
  std::map< std::string,float >::key_type *arg2 = 0 ;
  std::map< std::string,float >::mapped_type *arg3 = 0 ;
  std::map< std::string,float >::mapped_type temp3 ;
  
  arg1 = (std::map< std::string,float > *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  std::map< std::string,float >::key_type arg2_str(jarg2);
  arg2 = &arg2_str; 
  temp3 = (std::map< std::string,float >::mapped_type)jarg3; 
  arg3 = &temp3; 
  std_map_Sl_std_string_Sc_float_Sg__setitem(arg1,(std::string const &)*arg2,(float const &)*arg3);
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_SoundParameterList_ContainsKey(void * jarg1, char * jarg2) {
  unsigned int jresult ;
  std::map< std::string,float > *arg1 = (std::map< std::string,float > *) 0 ;
  std::map< std::string,float >::key_type *arg2 = 0 ;
  bool result;
  
  arg1 = (std::map< std::string,float > *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  std::map< std::string,float >::key_type arg2_str(jarg2);
  arg2 = &arg2_str; 
  result = (bool)std_map_Sl_std_string_Sc_float_Sg__ContainsKey(arg1,(std::string const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_SoundParameterList_Add(void * jarg1, char * jarg2, float jarg3) {
  std::map< std::string,float > *arg1 = (std::map< std::string,float > *) 0 ;
  std::map< std::string,float >::key_type *arg2 = 0 ;
  std::map< std::string,float >::mapped_type *arg3 = 0 ;
  std::map< std::string,float >::mapped_type temp3 ;
  
  arg1 = (std::map< std::string,float > *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  std::map< std::string,float >::key_type arg2_str(jarg2);
  arg2 = &arg2_str; 
  temp3 = (std::map< std::string,float >::mapped_type)jarg3; 
  arg3 = &temp3; 
  try {
    std_map_Sl_std_string_Sc_float_Sg__Add(arg1,(std::string const &)*arg2,(float const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_SoundParameterList_Remove(void * jarg1, char * jarg2) {
  unsigned int jresult ;
  std::map< std::string,float > *arg1 = (std::map< std::string,float > *) 0 ;
  std::map< std::string,float >::key_type *arg2 = 0 ;
  bool result;
  
  arg1 = (std::map< std::string,float > *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  std::map< std::string,float >::key_type arg2_str(jarg2);
  arg2 = &arg2_str; 
  result = (bool)std_map_Sl_std_string_Sc_float_Sg__Remove(arg1,(std::string const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_SoundParameterList_create_iterator_begin(void * jarg1) {
  void * jresult ;
  std::map< std::string,float > *arg1 = (std::map< std::string,float > *) 0 ;
  std::map< std::string,float,std::less< std::string > >::iterator *result = 0 ;
  
  arg1 = (std::map< std::string,float > *)jarg1; 
  result = (std::map< std::string,float,std::less< std::string > >::iterator *)std_map_Sl_std_string_Sc_float_Sg__create_iterator_begin(arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT char * SWIGSTDCALL CSharp_SoundParameterList_get_next_key(void * jarg1, void * jarg2) {
  char * jresult ;
  std::map< std::string,float > *arg1 = (std::map< std::string,float > *) 0 ;
  std::map< std::string,float,std::less< std::string > >::iterator *arg2 = (std::map< std::string,float,std::less< std::string > >::iterator *) 0 ;
  std::map< std::string,float >::key_type *result = 0 ;
  
  arg1 = (std::map< std::string,float > *)jarg1; 
  arg2 = (std::map< std::string,float,std::less< std::string > >::iterator *)jarg2; 
  result = (std::map< std::string,float >::key_type *) &std_map_Sl_std_string_Sc_float_Sg__get_next_key(arg1,arg2);
  jresult = SWIG_csharp_string_callback(result->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_SoundParameterList_destroy_iterator(void * jarg1, void * jarg2) {
  std::map< std::string,float > *arg1 = (std::map< std::string,float > *) 0 ;
  std::map< std::string,float,std::less< std::string > >::iterator *arg2 = (std::map< std::string,float,std::less< std::string > >::iterator *) 0 ;
  
  arg1 = (std::map< std::string,float > *)jarg1; 
  arg2 = (std::map< std::string,float,std::less< std::string > >::iterator *)jarg2; 
  std_map_Sl_std_string_Sc_float_Sg__destroy_iterator(arg1,arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_SoundParameterList(void * jarg1) {
  std::map< std::string,float > *arg1 = (std::map< std::string,float > *) 0 ;
  
  arg1 = (std::map< std::string,float > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_AudioAsset_is3D__set(void * jarg1, unsigned int jarg2) {
  AudioAsset *arg1 = (AudioAsset *) 0 ;
  bool arg2 ;
  
  arg1 = (AudioAsset *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->is3D_ = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_AudioAsset_is3D__get(void * jarg1) {
  unsigned int jresult ;
  AudioAsset *arg1 = (AudioAsset *) 0 ;
  bool result;
  
  arg1 = (AudioAsset *)jarg1; 
  result = (bool) ((arg1)->is3D_);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_AudioAsset_handle__set(void * jarg1, void * jarg2) {
  AudioAsset *arg1 = (AudioAsset *) 0 ;
  Sound *arg2 = (Sound *) 0 ;
  
  arg1 = (AudioAsset *)jarg1; 
  arg2 = (Sound *)jarg2; 
  if (arg1) (arg1)->handle_ = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_AudioAsset_handle__get(void * jarg1) {
  void * jresult ;
  AudioAsset *arg1 = (AudioAsset *) 0 ;
  Sound *result = 0 ;
  
  arg1 = (AudioAsset *)jarg1; 
  result = (Sound *) ((arg1)->handle_);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_AudioAsset_paramList__set(void * jarg1, void * jarg2) {
  AudioAsset *arg1 = (AudioAsset *) 0 ;
  std::map< std::string,float,std::less< std::string > > *arg2 = (std::map< std::string,float,std::less< std::string > > *) 0 ;
  
  arg1 = (AudioAsset *)jarg1; 
  arg2 = (std::map< std::string,float,std::less< std::string > > *)jarg2; 
  if (arg1) (arg1)->paramList_ = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_AudioAsset_paramList__get(void * jarg1) {
  void * jresult ;
  AudioAsset *arg1 = (AudioAsset *) 0 ;
  std::map< std::string,float,std::less< std::string > > *result = 0 ;
  
  arg1 = (AudioAsset *)jarg1; 
  result = (std::map< std::string,float,std::less< std::string > > *)& ((arg1)->paramList_);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_AudioAsset() {
  void * jresult ;
  AudioAsset *result = 0 ;
  
  result = (AudioAsset *)new AudioAsset();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_AudioAsset(void * jarg1) {
  AudioAsset *arg1 = (AudioAsset *) 0 ;
  
  arg1 = (AudioAsset *)jarg1; 
  delete arg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_SoundHandleList__SWIG_0() {
  void * jresult ;
  std::map< std::string,AudioAsset > *result = 0 ;
  
  result = (std::map< std::string,AudioAsset > *)new std::map< std::string,AudioAsset >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_SoundHandleList__SWIG_1(void * jarg1) {
  void * jresult ;
  std::map< std::string,AudioAsset,std::less< std::string > > *arg1 = 0 ;
  std::map< std::string,AudioAsset > *result = 0 ;
  
  arg1 = (std::map< std::string,AudioAsset,std::less< std::string > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::map< std::string,AudioAsset,std::less< std::string > > const & type is null", 0);
    return 0;
  } 
  result = (std::map< std::string,AudioAsset > *)new std::map< std::string,AudioAsset >((std::map< std::string,AudioAsset,std::less< std::string > > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_SoundHandleList_size(void * jarg1) {
  unsigned long jresult ;
  std::map< std::string,AudioAsset > *arg1 = (std::map< std::string,AudioAsset > *) 0 ;
  std::map< std::string,AudioAsset >::size_type result;
  
  arg1 = (std::map< std::string,AudioAsset > *)jarg1; 
  result = ((std::map< std::string,AudioAsset > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_SoundHandleList_empty(void * jarg1) {
  unsigned int jresult ;
  std::map< std::string,AudioAsset > *arg1 = (std::map< std::string,AudioAsset > *) 0 ;
  bool result;
  
  arg1 = (std::map< std::string,AudioAsset > *)jarg1; 
  result = (bool)((std::map< std::string,AudioAsset > const *)arg1)->empty();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_SoundHandleList_Clear(void * jarg1) {
  std::map< std::string,AudioAsset > *arg1 = (std::map< std::string,AudioAsset > *) 0 ;
  
  arg1 = (std::map< std::string,AudioAsset > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void * SWIGSTDCALL CSharp_SoundHandleList_getitem(void * jarg1, char * jarg2) {
  void * jresult ;
  std::map< std::string,AudioAsset > *arg1 = (std::map< std::string,AudioAsset > *) 0 ;
  std::map< std::string,AudioAsset >::key_type *arg2 = 0 ;
  std::map< std::string,AudioAsset >::mapped_type *result = 0 ;
  
  arg1 = (std::map< std::string,AudioAsset > *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  std::map< std::string,AudioAsset >::key_type arg2_str(jarg2);
  arg2 = &arg2_str; 
  try {
    result = (std::map< std::string,AudioAsset >::mapped_type *) &std_map_Sl_std_string_Sc_AudioAsset_Sg__getitem(arg1,(std::string const &)*arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_SoundHandleList_setitem(void * jarg1, char * jarg2, void * jarg3) {
  std::map< std::string,AudioAsset > *arg1 = (std::map< std::string,AudioAsset > *) 0 ;
  std::map< std::string,AudioAsset >::key_type *arg2 = 0 ;
  std::map< std::string,AudioAsset >::mapped_type *arg3 = 0 ;
  
  arg1 = (std::map< std::string,AudioAsset > *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  std::map< std::string,AudioAsset >::key_type arg2_str(jarg2);
  arg2 = &arg2_str; 
  arg3 = (std::map< std::string,AudioAsset >::mapped_type *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::map< std::string,AudioAsset >::mapped_type const & type is null", 0);
    return ;
  } 
  std_map_Sl_std_string_Sc_AudioAsset_Sg__setitem(arg1,(std::string const &)*arg2,(AudioAsset const &)*arg3);
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_SoundHandleList_ContainsKey(void * jarg1, char * jarg2) {
  unsigned int jresult ;
  std::map< std::string,AudioAsset > *arg1 = (std::map< std::string,AudioAsset > *) 0 ;
  std::map< std::string,AudioAsset >::key_type *arg2 = 0 ;
  bool result;
  
  arg1 = (std::map< std::string,AudioAsset > *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  std::map< std::string,AudioAsset >::key_type arg2_str(jarg2);
  arg2 = &arg2_str; 
  result = (bool)std_map_Sl_std_string_Sc_AudioAsset_Sg__ContainsKey(arg1,(std::string const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_SoundHandleList_Add(void * jarg1, char * jarg2, void * jarg3) {
  std::map< std::string,AudioAsset > *arg1 = (std::map< std::string,AudioAsset > *) 0 ;
  std::map< std::string,AudioAsset >::key_type *arg2 = 0 ;
  std::map< std::string,AudioAsset >::mapped_type *arg3 = 0 ;
  
  arg1 = (std::map< std::string,AudioAsset > *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  std::map< std::string,AudioAsset >::key_type arg2_str(jarg2);
  arg2 = &arg2_str; 
  arg3 = (std::map< std::string,AudioAsset >::mapped_type *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::map< std::string,AudioAsset >::mapped_type const & type is null", 0);
    return ;
  } 
  try {
    std_map_Sl_std_string_Sc_AudioAsset_Sg__Add(arg1,(std::string const &)*arg2,(AudioAsset const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_SoundHandleList_Remove(void * jarg1, char * jarg2) {
  unsigned int jresult ;
  std::map< std::string,AudioAsset > *arg1 = (std::map< std::string,AudioAsset > *) 0 ;
  std::map< std::string,AudioAsset >::key_type *arg2 = 0 ;
  bool result;
  
  arg1 = (std::map< std::string,AudioAsset > *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  std::map< std::string,AudioAsset >::key_type arg2_str(jarg2);
  arg2 = &arg2_str; 
  result = (bool)std_map_Sl_std_string_Sc_AudioAsset_Sg__Remove(arg1,(std::string const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_SoundHandleList_create_iterator_begin(void * jarg1) {
  void * jresult ;
  std::map< std::string,AudioAsset > *arg1 = (std::map< std::string,AudioAsset > *) 0 ;
  std::map< std::string,AudioAsset,std::less< std::string > >::iterator *result = 0 ;
  
  arg1 = (std::map< std::string,AudioAsset > *)jarg1; 
  result = (std::map< std::string,AudioAsset,std::less< std::string > >::iterator *)std_map_Sl_std_string_Sc_AudioAsset_Sg__create_iterator_begin(arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT char * SWIGSTDCALL CSharp_SoundHandleList_get_next_key(void * jarg1, void * jarg2) {
  char * jresult ;
  std::map< std::string,AudioAsset > *arg1 = (std::map< std::string,AudioAsset > *) 0 ;
  std::map< std::string,AudioAsset,std::less< std::string > >::iterator *arg2 = (std::map< std::string,AudioAsset,std::less< std::string > >::iterator *) 0 ;
  std::map< std::string,AudioAsset >::key_type *result = 0 ;
  
  arg1 = (std::map< std::string,AudioAsset > *)jarg1; 
  arg2 = (std::map< std::string,AudioAsset,std::less< std::string > >::iterator *)jarg2; 
  result = (std::map< std::string,AudioAsset >::key_type *) &std_map_Sl_std_string_Sc_AudioAsset_Sg__get_next_key(arg1,arg2);
  jresult = SWIG_csharp_string_callback(result->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_SoundHandleList_destroy_iterator(void * jarg1, void * jarg2) {
  std::map< std::string,AudioAsset > *arg1 = (std::map< std::string,AudioAsset > *) 0 ;
  std::map< std::string,AudioAsset,std::less< std::string > >::iterator *arg2 = (std::map< std::string,AudioAsset,std::less< std::string > >::iterator *) 0 ;
  
  arg1 = (std::map< std::string,AudioAsset > *)jarg1; 
  arg2 = (std::map< std::string,AudioAsset,std::less< std::string > >::iterator *)jarg2; 
  std_map_Sl_std_string_Sc_AudioAsset_Sg__destroy_iterator(arg1,arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_SoundHandleList(void * jarg1) {
  std::map< std::string,AudioAsset > *arg1 = (std::map< std::string,AudioAsset > *) 0 ;
  
  arg1 = (std::map< std::string,AudioAsset > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CSound_PlayIndependentEvent(void * jarg1, char * jarg2, unsigned int jarg3, int jarg4) {
  CSound *arg1 = (CSound *) 0 ;
  std::string *arg2 = 0 ;
  bool arg3 ;
  int arg4 ;
  
  arg1 = (CSound *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  arg3 = jarg3 ? true : false; 
  arg4 = (int)jarg4; 
  (arg1)->PlayIndependentEvent((std::string const &)*arg2,arg3,arg4);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CSound_PlayIndependentEventStatic3D(void * jarg1, char * jarg2, void * jarg3, unsigned int jarg4) {
  CSound *arg1 = (CSound *) 0 ;
  std::string *arg2 = 0 ;
  Math::Vector3 *arg3 = 0 ;
  bool arg4 ;
  
  arg1 = (CSound *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  arg3 = (Math::Vector3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  arg4 = jarg4 ? true : false; 
  (arg1)->PlayIndependentEventStatic3D((std::string const &)*arg2,(Math::Vector3 const &)*arg3,arg4);
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CSound_GetUniqueEvent(void * jarg1, char * jarg2, int jarg3) {
  unsigned int jresult ;
  CSound *arg1 = (CSound *) 0 ;
  std::string *arg2 = 0 ;
  int arg3 ;
  unsigned int result;
  
  arg1 = (CSound *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  arg3 = (int)jarg3; 
  result = (unsigned int)(arg1)->GetUniqueEvent((std::string const &)*arg2,arg3);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CSound_PlayUniqueEvent__SWIG_0(void * jarg1, unsigned int jarg2, unsigned int jarg3) {
  CSound *arg1 = (CSound *) 0 ;
  unsigned int arg2 ;
  bool arg3 ;
  
  arg1 = (CSound *)jarg1; 
  arg2 = (unsigned int)jarg2; 
  arg3 = jarg3 ? true : false; 
  (arg1)->PlayUniqueEvent(arg2,arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CSound_PlayUniqueEvent__SWIG_1(void * jarg1, unsigned int jarg2, void * jarg3, unsigned int jarg4) {
  CSound *arg1 = (CSound *) 0 ;
  unsigned int arg2 ;
  Math::Vector3 *arg3 = 0 ;
  bool arg4 ;
  
  arg1 = (CSound *)jarg1; 
  arg2 = (unsigned int)jarg2; 
  arg3 = (Math::Vector3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Math::Vector3 const & type is null", 0);
    return ;
  } 
  arg4 = jarg4 ? true : false; 
  (arg1)->PlayUniqueEvent(arg2,(Math::Vector3 const &)*arg3,arg4);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CSound_PauseUniqueEvent(void * jarg1, unsigned int jarg2) {
  CSound *arg1 = (CSound *) 0 ;
  unsigned int arg2 ;
  
  arg1 = (CSound *)jarg1; 
  arg2 = (unsigned int)jarg2; 
  (arg1)->PauseUniqueEvent(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CSound_ResumeUniqueEvent(void * jarg1, unsigned int jarg2) {
  CSound *arg1 = (CSound *) 0 ;
  unsigned int arg2 ;
  
  arg1 = (CSound *)jarg1; 
  arg2 = (unsigned int)jarg2; 
  (arg1)->ResumeUniqueEvent(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CSound_StopUniqueEvent__SWIG_0(void * jarg1, unsigned int jarg2, unsigned int jarg3) {
  CSound *arg1 = (CSound *) 0 ;
  unsigned int arg2 ;
  bool arg3 ;
  
  arg1 = (CSound *)jarg1; 
  arg2 = (unsigned int)jarg2; 
  arg3 = jarg3 ? true : false; 
  (arg1)->StopUniqueEvent(arg2,arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CSound_StopUniqueEvent__SWIG_1(void * jarg1, unsigned int jarg2) {
  CSound *arg1 = (CSound *) 0 ;
  unsigned int arg2 ;
  
  arg1 = (CSound *)jarg1; 
  arg2 = (unsigned int)jarg2; 
  (arg1)->StopUniqueEvent(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CSound_SetUniqueEventParam(void * jarg1, unsigned int jarg2, char * jarg3, float jarg4) {
  CSound *arg1 = (CSound *) 0 ;
  unsigned int arg2 ;
  std::string *arg3 = 0 ;
  float arg4 ;
  
  arg1 = (CSound *)jarg1; 
  arg2 = (unsigned int)jarg2; 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  std::string arg3_str(jarg3);
  arg3 = &arg3_str; 
  arg4 = (float)jarg4; 
  (arg1)->SetUniqueEventParam(arg2,(std::string const &)*arg3,arg4);
}


SWIGEXPORT float SWIGSTDCALL CSharp_CSound_GetUniqueEventParam(void * jarg1, unsigned int jarg2, char * jarg3) {
  float jresult ;
  CSound *arg1 = (CSound *) 0 ;
  unsigned int arg2 ;
  std::string *arg3 = 0 ;
  float result;
  
  arg1 = (CSound *)jarg1; 
  arg2 = (unsigned int)jarg2; 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  std::string arg3_str(jarg3);
  arg3 = &arg3_str; 
  result = (float)(arg1)->GetUniqueEventParam(arg2,(std::string const &)*arg3);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CSound_GetUniqueEventIsPlaying(void * jarg1, unsigned int jarg2) {
  unsigned int jresult ;
  CSound *arg1 = (CSound *) 0 ;
  unsigned int arg2 ;
  bool result;
  
  arg1 = (CSound *)jarg1; 
  arg2 = (unsigned int)jarg2; 
  result = (bool)(arg1)->GetUniqueEventIsPlaying(arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CSound_GetUniqueEventIsStopped(void * jarg1, unsigned int jarg2) {
  unsigned int jresult ;
  CSound *arg1 = (CSound *) 0 ;
  unsigned int arg2 ;
  bool result;
  
  arg1 = (CSound *)jarg1; 
  arg2 = (unsigned int)jarg2; 
  result = (bool)(arg1)->GetUniqueEventIsStopped(arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CSound_GetUniqueEventIsPaused(void * jarg1, unsigned int jarg2) {
  unsigned int jresult ;
  CSound *arg1 = (CSound *) 0 ;
  unsigned int arg2 ;
  bool result;
  
  arg1 = (CSound *)jarg1; 
  arg2 = (unsigned int)jarg2; 
  result = (bool)(arg1)->GetUniqueEventIsPaused(arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CSound_StopAllGlobalEvents(void * jarg1) {
  CSound *arg1 = (CSound *) 0 ;
  
  arg1 = (CSound *)jarg1; 
  (arg1)->StopAllGlobalEvents();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CSound_StopAllMyEvents(void * jarg1, unsigned int jarg2) {
  CSound *arg1 = (CSound *) 0 ;
  bool arg2 ;
  
  arg1 = (CSound *)jarg1; 
  arg2 = jarg2 ? true : false; 
  (arg1)->StopAllMyEvents(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CSound_ResumeAllMyEvents(void * jarg1) {
  CSound *arg1 = (CSound *) 0 ;
  
  arg1 = (CSound *)jarg1; 
  (arg1)->ResumeAllMyEvents();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CSound_PauseAllMyEvents(void * jarg1) {
  CSound *arg1 = (CSound *) 0 ;
  
  arg1 = (CSound *)jarg1; 
  (arg1)->PauseAllMyEvents();
}


SWIGEXPORT void SWIGSTDCALL CSharp_IZone_width_set(void * jarg1, float jarg2) {
  IZone *arg1 = (IZone *) 0 ;
  float arg2 ;
  
  arg1 = (IZone *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->width = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_IZone_width_get(void * jarg1) {
  float jresult ;
  IZone *arg1 = (IZone *) 0 ;
  float result;
  
  arg1 = (IZone *)jarg1; 
  result = (float) ((arg1)->width);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_IZone_height_set(void * jarg1, float jarg2) {
  IZone *arg1 = (IZone *) 0 ;
  float arg2 ;
  
  arg1 = (IZone *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->height = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_IZone_height_get(void * jarg1) {
  float jresult ;
  IZone *arg1 = (IZone *) 0 ;
  float result;
  
  arg1 = (IZone *)jarg1; 
  result = (float) ((arg1)->height);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_IZone_depth_set(void * jarg1, float jarg2) {
  IZone *arg1 = (IZone *) 0 ;
  float arg2 ;
  
  arg1 = (IZone *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->depth = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_IZone_depth_get(void * jarg1) {
  float jresult ;
  IZone *arg1 = (IZone *) 0 ;
  float result;
  
  arg1 = (IZone *)jarg1; 
  result = (float) ((arg1)->depth);
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_IZone_GetLeftBound(void * jarg1) {
  float jresult ;
  IZone *arg1 = (IZone *) 0 ;
  float result;
  
  arg1 = (IZone *)jarg1; 
  result = (float)(arg1)->GetLeftBound();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_IZone_GetRightBound(void * jarg1) {
  float jresult ;
  IZone *arg1 = (IZone *) 0 ;
  float result;
  
  arg1 = (IZone *)jarg1; 
  result = (float)(arg1)->GetRightBound();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_IZone_GetBottomBound(void * jarg1) {
  float jresult ;
  IZone *arg1 = (IZone *) 0 ;
  float result;
  
  arg1 = (IZone *)jarg1; 
  result = (float)(arg1)->GetBottomBound();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_IZone_GetTopBound(void * jarg1) {
  float jresult ;
  IZone *arg1 = (IZone *) 0 ;
  float result;
  
  arg1 = (IZone *)jarg1; 
  result = (float)(arg1)->GetTopBound();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_IZone_GetFrontBound(void * jarg1) {
  float jresult ;
  IZone *arg1 = (IZone *) 0 ;
  float result;
  
  arg1 = (IZone *)jarg1; 
  result = (float)(arg1)->GetFrontBound();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_IZone_GetBackBound(void * jarg1) {
  float jresult ;
  IZone *arg1 = (IZone *) 0 ;
  float result;
  
  arg1 = (IZone *)jarg1; 
  result = (float)(arg1)->GetBackBound();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_IZone_Init(void * jarg1, void * jarg2) {
  IZone *arg1 = (IZone *) 0 ;
  GameObject *arg2 = (GameObject *) 0 ;
  
  arg1 = (IZone *)jarg1; 
  arg2 = (GameObject *)jarg2; 
  (arg1)->Init(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_IZone_GetDiagonalCornerZero(void * jarg1) {
  void * jresult ;
  IZone *arg1 = (IZone *) 0 ;
  Math::Vector3 result;
  
  arg1 = (IZone *)jarg1; 
  result = (arg1)->GetDiagonalCornerZero();
  jresult = new Math::Vector3((const Math::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_IZone_GetDiagonalCornerOne(void * jarg1) {
  void * jresult ;
  IZone *arg1 = (IZone *) 0 ;
  Math::Vector3 result;
  
  arg1 = (IZone *)jarg1; 
  result = (arg1)->GetDiagonalCornerOne();
  jresult = new Math::Vector3((const Math::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_IZone_IsPointWithin(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  IZone *arg1 = (IZone *) 0 ;
  Math::Vector3 arg2 ;
  Math::Vector3 *argp2 ;
  bool result;
  
  arg1 = (IZone *)jarg1; 
  argp2 = (Math::Vector3 *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null Math::Vector3", 0);
    return 0;
  }
  arg2 = *argp2; 
  result = (bool)(arg1)->IsPointWithin(arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_IZone_ClampObjectToBounds(void * jarg1, void * jarg2) {
  IZone *arg1 = (IZone *) 0 ;
  GameObject *arg2 = (GameObject *) 0 ;
  
  arg1 = (IZone *)jarg1; 
  arg2 = (GameObject *)jarg2; 
  (arg1)->ClampObjectToBounds(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_IZone_GetObjectsInBounds(void * jarg1) {
  void * jresult ;
  IZone *arg1 = (IZone *) 0 ;
  std::vector< GameObject * > result;
  
  arg1 = (IZone *)jarg1; 
  result = (arg1)->GetObjectsInBounds();
  jresult = new std::vector< GameObject * >((const std::vector< GameObject * > &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_IZone_DrawBounds(void * jarg1) {
  IZone *arg1 = (IZone *) 0 ;
  
  arg1 = (IZone *)jarg1; 
  (arg1)->DrawBounds();
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CZone_GetCenter(void * jarg1) {
  void * jresult ;
  CZone *arg1 = (CZone *) 0 ;
  Math::Vector3 *result = 0 ;
  
  arg1 = (CZone *)jarg1; 
  result = (Math::Vector3 *) &(arg1)->GetCenter();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CZone_width_set(void * jarg1, float jarg2) {
  CZone *arg1 = (CZone *) 0 ;
  float arg2 ;
  
  arg1 = (CZone *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->width = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CZone_width_get(void * jarg1) {
  float jresult ;
  CZone *arg1 = (CZone *) 0 ;
  float result;
  
  arg1 = (CZone *)jarg1; 
  result = (float) ((arg1)->width);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CZone_height_set(void * jarg1, float jarg2) {
  CZone *arg1 = (CZone *) 0 ;
  float arg2 ;
  
  arg1 = (CZone *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->height = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CZone_height_get(void * jarg1) {
  float jresult ;
  CZone *arg1 = (CZone *) 0 ;
  float result;
  
  arg1 = (CZone *)jarg1; 
  result = (float) ((arg1)->height);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CZone_depth_set(void * jarg1, float jarg2) {
  CZone *arg1 = (CZone *) 0 ;
  float arg2 ;
  
  arg1 = (CZone *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->depth = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CZone_depth_get(void * jarg1) {
  float jresult ;
  CZone *arg1 = (CZone *) 0 ;
  float result;
  
  arg1 = (CZone *)jarg1; 
  result = (float) ((arg1)->depth);
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CZone_GetLeftBound(void * jarg1) {
  float jresult ;
  CZone *arg1 = (CZone *) 0 ;
  float result;
  
  arg1 = (CZone *)jarg1; 
  result = (float)(arg1)->GetLeftBound();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CZone_GetRightBound(void * jarg1) {
  float jresult ;
  CZone *arg1 = (CZone *) 0 ;
  float result;
  
  arg1 = (CZone *)jarg1; 
  result = (float)(arg1)->GetRightBound();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CZone_GetBottomBound(void * jarg1) {
  float jresult ;
  CZone *arg1 = (CZone *) 0 ;
  float result;
  
  arg1 = (CZone *)jarg1; 
  result = (float)(arg1)->GetBottomBound();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CZone_GetTopBound(void * jarg1) {
  float jresult ;
  CZone *arg1 = (CZone *) 0 ;
  float result;
  
  arg1 = (CZone *)jarg1; 
  result = (float)(arg1)->GetTopBound();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CZone_GetFrontBound(void * jarg1) {
  float jresult ;
  CZone *arg1 = (CZone *) 0 ;
  float result;
  
  arg1 = (CZone *)jarg1; 
  result = (float)(arg1)->GetFrontBound();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CZone_GetBackBound(void * jarg1) {
  float jresult ;
  CZone *arg1 = (CZone *) 0 ;
  float result;
  
  arg1 = (CZone *)jarg1; 
  result = (float)(arg1)->GetBackBound();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CZone_GetDiagonalCornerZero(void * jarg1) {
  void * jresult ;
  CZone *arg1 = (CZone *) 0 ;
  Math::Vector3 result;
  
  arg1 = (CZone *)jarg1; 
  result = (arg1)->GetDiagonalCornerZero();
  jresult = new Math::Vector3((const Math::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CZone_GetDiagonalCornerOne(void * jarg1) {
  void * jresult ;
  CZone *arg1 = (CZone *) 0 ;
  Math::Vector3 result;
  
  arg1 = (CZone *)jarg1; 
  result = (arg1)->GetDiagonalCornerOne();
  jresult = new Math::Vector3((const Math::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CZone_IsPointWithin(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  CZone *arg1 = (CZone *) 0 ;
  Math::Vector3 arg2 ;
  Math::Vector3 *argp2 ;
  bool result;
  
  arg1 = (CZone *)jarg1; 
  argp2 = (Math::Vector3 *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null Math::Vector3", 0);
    return 0;
  }
  arg2 = *argp2; 
  result = (bool)(arg1)->IsPointWithin(arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CZone_ClampObjectToBounds(void * jarg1, void * jarg2) {
  CZone *arg1 = (CZone *) 0 ;
  GameObject *arg2 = (GameObject *) 0 ;
  
  arg1 = (CZone *)jarg1; 
  arg2 = (GameObject *)jarg2; 
  (arg1)->ClampObjectToBounds(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CMapZone_id_set(void * jarg1, char * jarg2) {
  CMapZone *arg1 = (CMapZone *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (CMapZone *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  if (arg1) (arg1)->id = *arg2;
}


SWIGEXPORT char * SWIGSTDCALL CSharp_CMapZone_id_get(void * jarg1) {
  char * jresult ;
  CMapZone *arg1 = (CMapZone *) 0 ;
  std::string *result = 0 ;
  
  arg1 = (CMapZone *)jarg1; 
  result = (std::string *) & ((arg1)->id);
  jresult = SWIG_csharp_string_callback(result->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CMapZone_zone_set(void * jarg1, void * jarg2) {
  CMapZone *arg1 = (CMapZone *) 0 ;
  IZone *arg2 = (IZone *) 0 ;
  
  arg1 = (CMapZone *)jarg1; 
  arg2 = (IZone *)jarg2; 
  if (arg1) (arg1)->zone = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CMapZone_zone_get(void * jarg1) {
  void * jresult ;
  CMapZone *arg1 = (CMapZone *) 0 ;
  IZone *result = 0 ;
  
  arg1 = (CMapZone *)jarg1; 
  result = (IZone *)& ((arg1)->zone);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CStreamMarker_markerID_set(void * jarg1, char * jarg2) {
  CStreamMarker *arg1 = (CStreamMarker *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (CStreamMarker *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  if (arg1) (arg1)->markerID = *arg2;
}


SWIGEXPORT char * SWIGSTDCALL CSharp_CStreamMarker_markerID_get(void * jarg1) {
  char * jresult ;
  CStreamMarker *arg1 = (CStreamMarker *) 0 ;
  std::string *result = 0 ;
  
  arg1 = (CStreamMarker *)jarg1; 
  result = (std::string *) & ((arg1)->markerID);
  jresult = SWIG_csharp_string_callback(result->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CStreamZone_zone_set(void * jarg1, void * jarg2) {
  CStreamZone *arg1 = (CStreamZone *) 0 ;
  IZone *arg2 = (IZone *) 0 ;
  
  arg1 = (CStreamZone *)jarg1; 
  arg2 = (IZone *)jarg2; 
  if (arg1) (arg1)->zone = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CStreamZone_zone_get(void * jarg1) {
  void * jresult ;
  CStreamZone *arg1 = (CStreamZone *) 0 ;
  IZone *result = 0 ;
  
  arg1 = (CStreamZone *)jarg1; 
  result = (IZone *)& ((arg1)->zone);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CStreamZone_mapZoneId_set(void * jarg1, char * jarg2) {
  CStreamZone *arg1 = (CStreamZone *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (CStreamZone *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  if (arg1) (arg1)->mapZoneId = *arg2;
}


SWIGEXPORT char * SWIGSTDCALL CSharp_CStreamZone_mapZoneId_get(void * jarg1) {
  char * jresult ;
  CStreamZone *arg1 = (CStreamZone *) 0 ;
  std::string *result = 0 ;
  
  arg1 = (CStreamZone *)jarg1; 
  result = (std::string *) & ((arg1)->mapZoneId);
  jresult = SWIG_csharp_string_callback(result->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CStreamZone_mode_set(void * jarg1, int jarg2) {
  CStreamZone *arg1 = (CStreamZone *) 0 ;
  CStreamZone::StreamMode arg2 ;
  
  arg1 = (CStreamZone *)jarg1; 
  arg2 = (CStreamZone::StreamMode)jarg2; 
  if (arg1) (arg1)->mode = arg2;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CStreamZone_mode_get(void * jarg1) {
  int jresult ;
  CStreamZone *arg1 = (CStreamZone *) 0 ;
  CStreamZone::StreamMode result;
  
  arg1 = (CStreamZone *)jarg1; 
  result = (CStreamZone::StreamMode) ((arg1)->mode);
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CStreamZone_fileToStream_set(void * jarg1, char * jarg2) {
  CStreamZone *arg1 = (CStreamZone *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (CStreamZone *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  if (arg1) (arg1)->fileToStream = *arg2;
}


SWIGEXPORT char * SWIGSTDCALL CSharp_CStreamZone_fileToStream_get(void * jarg1) {
  char * jresult ;
  CStreamZone *arg1 = (CStreamZone *) 0 ;
  std::string *result = 0 ;
  
  arg1 = (CStreamZone *)jarg1; 
  result = (std::string *) & ((arg1)->fileToStream);
  jresult = SWIG_csharp_string_callback(result->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CStreamZone_forceZoneUnusableAfterStream_set(void * jarg1, unsigned int jarg2) {
  CStreamZone *arg1 = (CStreamZone *) 0 ;
  bool arg2 ;
  
  arg1 = (CStreamZone *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->forceZoneUnusableAfterStream = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CStreamZone_forceZoneUnusableAfterStream_get(void * jarg1) {
  unsigned int jresult ;
  CStreamZone *arg1 = (CStreamZone *) 0 ;
  bool result;
  
  arg1 = (CStreamZone *)jarg1; 
  result = (bool) ((arg1)->forceZoneUnusableAfterStream);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CStreamZone_useOffsetFromThisPos_set(void * jarg1, unsigned int jarg2) {
  CStreamZone *arg1 = (CStreamZone *) 0 ;
  bool arg2 ;
  
  arg1 = (CStreamZone *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->useOffsetFromThisPos = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CStreamZone_useOffsetFromThisPos_get(void * jarg1) {
  unsigned int jresult ;
  CStreamZone *arg1 = (CStreamZone *) 0 ;
  bool result;
  
  arg1 = (CStreamZone *)jarg1; 
  result = (bool) ((arg1)->useOffsetFromThisPos);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CStreamZone_offset_set(void * jarg1, void * jarg2) {
  CStreamZone *arg1 = (CStreamZone *) 0 ;
  Math::Vector3 *arg2 = (Math::Vector3 *) 0 ;
  
  arg1 = (CStreamZone *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2; 
  if (arg1) (arg1)->offset = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CStreamZone_offset_get(void * jarg1) {
  void * jresult ;
  CStreamZone *arg1 = (CStreamZone *) 0 ;
  Math::Vector3 *result = 0 ;
  
  arg1 = (CStreamZone *)jarg1; 
  result = (Math::Vector3 *)& ((arg1)->offset);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CStreamZone_mUseMarkers_set(void * jarg1, unsigned int jarg2) {
  CStreamZone *arg1 = (CStreamZone *) 0 ;
  bool arg2 ;
  
  arg1 = (CStreamZone *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->mUseMarkers = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CStreamZone_mUseMarkers_get(void * jarg1) {
  unsigned int jresult ;
  CStreamZone *arg1 = (CStreamZone *) 0 ;
  bool result;
  
  arg1 = (CStreamZone *)jarg1; 
  result = (bool) ((arg1)->mUseMarkers);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CStreamZone_mMarkerID_set(void * jarg1, char * jarg2) {
  CStreamZone *arg1 = (CStreamZone *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (CStreamZone *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  if (arg1) (arg1)->mMarkerID = *arg2;
}


SWIGEXPORT char * SWIGSTDCALL CSharp_CStreamZone_mMarkerID_get(void * jarg1) {
  char * jresult ;
  CStreamZone *arg1 = (CStreamZone *) 0 ;
  std::string *result = 0 ;
  
  arg1 = (CStreamZone *)jarg1; 
  result = (std::string *) & ((arg1)->mMarkerID);
  jresult = SWIG_csharp_string_callback(result->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CStreamZone_mPreAccumulateUnloadObjs_set(void * jarg1, unsigned int jarg2) {
  CStreamZone *arg1 = (CStreamZone *) 0 ;
  bool arg2 ;
  
  arg1 = (CStreamZone *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->mPreAccumulateUnloadObjs = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CStreamZone_mPreAccumulateUnloadObjs_get(void * jarg1) {
  unsigned int jresult ;
  CStreamZone *arg1 = (CStreamZone *) 0 ;
  bool result;
  
  arg1 = (CStreamZone *)jarg1; 
  result = (bool) ((arg1)->mPreAccumulateUnloadObjs);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CStreamZone_incrementalDeload_set(void * jarg1, unsigned int jarg2) {
  CStreamZone *arg1 = (CStreamZone *) 0 ;
  bool arg2 ;
  
  arg1 = (CStreamZone *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->incrementalDeload = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CStreamZone_incrementalDeload_get(void * jarg1) {
  unsigned int jresult ;
  CStreamZone *arg1 = (CStreamZone *) 0 ;
  bool result;
  
  arg1 = (CStreamZone *)jarg1; 
  result = (bool) ((arg1)->incrementalDeload);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CStreamZone_GetIsStreaming(void * jarg1) {
  unsigned int jresult ;
  CStreamZone *arg1 = (CStreamZone *) 0 ;
  bool result;
  
  arg1 = (CStreamZone *)jarg1; 
  result = (bool)(arg1)->GetIsStreaming();
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CStreamZone_GetHasFinishedStreaming(void * jarg1) {
  unsigned int jresult ;
  CStreamZone *arg1 = (CStreamZone *) 0 ;
  bool result;
  
  arg1 = (CStreamZone *)jarg1; 
  result = (bool)(arg1)->GetHasFinishedStreaming();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CStreamZone_SetStreamMode(void * jarg1, int jarg2) {
  CStreamZone *arg1 = (CStreamZone *) 0 ;
  CStreamZone::StreamMode arg2 ;
  
  arg1 = (CStreamZone *)jarg1; 
  arg2 = (CStreamZone::StreamMode)jarg2; 
  (arg1)->SetStreamMode(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CStreamZone_SetFileToStream(void * jarg1, char * jarg2) {
  CStreamZone *arg1 = (CStreamZone *) 0 ;
  std::string arg2 ;
  
  arg1 = (CStreamZone *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  (&arg2)->assign(jarg2); 
  (arg1)->SetFileToStream(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_ScriptProperties() {
  void * jresult ;
  ScriptProperties *result = 0 ;
  
  result = (ScriptProperties *)new ScriptProperties();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_ScriptProperties(void * jarg1) {
  ScriptProperties *arg1 = (ScriptProperties *) 0 ;
  
  arg1 = (ScriptProperties *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CScript_isBinded_set(void * jarg1, unsigned int jarg2) {
  CScript *arg1 = (CScript *) 0 ;
  bool arg2 ;
  
  arg1 = (CScript *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->isBinded = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CScript_isBinded_get(void * jarg1) {
  unsigned int jresult ;
  CScript *arg1 = (CScript *) 0 ;
  bool result;
  
  arg1 = (CScript *)jarg1; 
  result = (bool) ((arg1)->isBinded);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CScript_scriptAsset_set(void * jarg1, void * jarg2) {
  CScript *arg1 = (CScript *) 0 ;
  AssetHandle *arg2 = (AssetHandle *) 0 ;
  
  arg1 = (CScript *)jarg1; 
  arg2 = (AssetHandle *)jarg2; 
  if (arg1) (arg1)->scriptAsset = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CScript_scriptAsset_get(void * jarg1) {
  void * jresult ;
  CScript *arg1 = (CScript *) 0 ;
  AssetHandle *result = 0 ;
  
  arg1 = (CScript *)jarg1; 
  result = (AssetHandle *)& ((arg1)->scriptAsset);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CScript_register_id_set(void * jarg1, char * jarg2) {
  CScript *arg1 = (CScript *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (CScript *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  if (arg1) (arg1)->register_id = *arg2;
}


SWIGEXPORT char * SWIGSTDCALL CSharp_CScript_register_id_get(void * jarg1) {
  char * jresult ;
  CScript *arg1 = (CScript *) 0 ;
  std::string *result = 0 ;
  
  arg1 = (CScript *)jarg1; 
  result = (std::string *) & ((arg1)->register_id);
  jresult = SWIG_csharp_string_callback(result->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CScript_p_set(void * jarg1, void * jarg2) {
  CScript *arg1 = (CScript *) 0 ;
  ScriptProperties *arg2 = (ScriptProperties *) 0 ;
  
  arg1 = (CScript *)jarg1; 
  arg2 = (ScriptProperties *)jarg2; 
  if (arg1) (arg1)->dummyProperties = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CScript_p_get(void * jarg1) {
  void * jresult ;
  CScript *arg1 = (CScript *) 0 ;
  ScriptProperties *result = 0 ;
  
  arg1 = (CScript *)jarg1; 
  result = (ScriptProperties *)& ((arg1)->dummyProperties);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CDiffuseRenderer_mDrawOnTop_set(void * jarg1, unsigned int jarg2) {
  CDiffuseRenderer *arg1 = (CDiffuseRenderer *) 0 ;
  bool arg2 ;
  
  arg1 = (CDiffuseRenderer *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->mDrawOnTop = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CDiffuseRenderer_mDrawOnTop_get(void * jarg1) {
  unsigned int jresult ;
  CDiffuseRenderer *arg1 = (CDiffuseRenderer *) 0 ;
  bool result;
  
  arg1 = (CDiffuseRenderer *)jarg1; 
  result = (bool) ((arg1)->mDrawOnTop);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CForwardRenderer_mDrawOnTop_set(void * jarg1, unsigned int jarg2) {
  CForwardRenderer *arg1 = (CForwardRenderer *) 0 ;
  bool arg2 ;
  
  arg1 = (CForwardRenderer *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->mDrawOnTop = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CForwardRenderer_mDrawOnTop_get(void * jarg1) {
  unsigned int jresult ;
  CForwardRenderer *arg1 = (CForwardRenderer *) 0 ;
  bool result;
  
  arg1 = (CForwardRenderer *)jarg1; 
  result = (bool) ((arg1)->mDrawOnTop);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CFontRenderer_ClampTextWithinWidth(void * jarg1, float jarg2) {
  CFontRenderer *arg1 = (CFontRenderer *) 0 ;
  float arg2 ;
  
  arg1 = (CFontRenderer *)jarg1; 
  arg2 = (float)jarg2; 
  (arg1)->ClampTextWithinWidth(arg2);
}


SWIGEXPORT float SWIGSTDCALL CSharp_CFontRenderer_GetLineWidth(void * jarg1, unsigned int jarg2) {
  float jresult ;
  CFontRenderer *arg1 = (CFontRenderer *) 0 ;
  unsigned int arg2 ;
  float result;
  
  arg1 = (CFontRenderer *)jarg1; 
  arg2 = (unsigned int)jarg2; 
  result = (float)((CFontRenderer const *)arg1)->GetLineWidth(arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CFontRenderer_GetNumberOfLines(void * jarg1) {
  unsigned int jresult ;
  CFontRenderer *arg1 = (CFontRenderer *) 0 ;
  unsigned int result;
  
  arg1 = (CFontRenderer *)jarg1; 
  result = (unsigned int)((CFontRenderer const *)arg1)->GetNumberOfLines();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CFontRenderer_mFontSize_set(void * jarg1, unsigned int jarg2) {
  CFontRenderer *arg1 = (CFontRenderer *) 0 ;
  unsigned int arg2 ;
  
  arg1 = (CFontRenderer *)jarg1; 
  arg2 = (unsigned int)jarg2; 
  if (arg1) (arg1)->mFontSize = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CFontRenderer_mFontSize_get(void * jarg1) {
  unsigned int jresult ;
  CFontRenderer *arg1 = (CFontRenderer *) 0 ;
  unsigned int result;
  
  arg1 = (CFontRenderer *)jarg1; 
  result = (unsigned int) ((arg1)->mFontSize);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CFontRenderer_mFontScale_set(void * jarg1, float jarg2) {
  CFontRenderer *arg1 = (CFontRenderer *) 0 ;
  float arg2 ;
  
  arg1 = (CFontRenderer *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mFontScale = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CFontRenderer_mFontScale_get(void * jarg1) {
  float jresult ;
  CFontRenderer *arg1 = (CFontRenderer *) 0 ;
  float result;
  
  arg1 = (CFontRenderer *)jarg1; 
  result = (float) ((arg1)->mFontScale);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CFontRenderer_mText_set(void * jarg1, char * jarg2) {
  CFontRenderer *arg1 = (CFontRenderer *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (CFontRenderer *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  if (arg1) (arg1)->mText = *arg2;
}


SWIGEXPORT char * SWIGSTDCALL CSharp_CFontRenderer_mText_get(void * jarg1) {
  char * jresult ;
  CFontRenderer *arg1 = (CFontRenderer *) 0 ;
  std::string *result = 0 ;
  
  arg1 = (CFontRenderer *)jarg1; 
  result = (std::string *) & ((arg1)->mText);
  jresult = SWIG_csharp_string_callback(result->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CFontRenderer_mColor_set(void * jarg1, void * jarg2) {
  CFontRenderer *arg1 = (CFontRenderer *) 0 ;
  Color *arg2 = (Color *) 0 ;
  
  arg1 = (CFontRenderer *)jarg1; 
  arg2 = (Color *)jarg2; 
  if (arg1) (arg1)->mColor = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CFontRenderer_mColor_get(void * jarg1) {
  void * jresult ;
  CFontRenderer *arg1 = (CFontRenderer *) 0 ;
  Color *result = 0 ;
  
  arg1 = (CFontRenderer *)jarg1; 
  result = (Color *)& ((arg1)->mColor);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CFontRenderer_mJustification_set(void * jarg1, int jarg2) {
  CFontRenderer *arg1 = (CFontRenderer *) 0 ;
  CFontRenderer::FONT_JUSTIFICATION arg2 ;
  
  arg1 = (CFontRenderer *)jarg1; 
  arg2 = (CFontRenderer::FONT_JUSTIFICATION)jarg2; 
  if (arg1) (arg1)->mJustification = arg2;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CFontRenderer_mJustification_get(void * jarg1) {
  int jresult ;
  CFontRenderer *arg1 = (CFontRenderer *) 0 ;
  CFontRenderer::FONT_JUSTIFICATION result;
  
  arg1 = (CFontRenderer *)jarg1; 
  result = (CFontRenderer::FONT_JUSTIFICATION) ((arg1)->mJustification);
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CFontRenderer_mFontAsset_set(void * jarg1, void * jarg2) {
  CFontRenderer *arg1 = (CFontRenderer *) 0 ;
  AssetHandle *arg2 = (AssetHandle *) 0 ;
  
  arg1 = (CFontRenderer *)jarg1; 
  arg2 = (AssetHandle *)jarg2; 
  if (arg1) (arg1)->mFontAsset = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CFontRenderer_mFontAsset_get(void * jarg1) {
  void * jresult ;
  CFontRenderer *arg1 = (CFontRenderer *) 0 ;
  AssetHandle *result = 0 ;
  
  arg1 = (CFontRenderer *)jarg1; 
  result = (AssetHandle *)& ((arg1)->mFontAsset);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CFontRenderer_mNewlineSpacing_set(void * jarg1, float jarg2) {
  CFontRenderer *arg1 = (CFontRenderer *) 0 ;
  float arg2 ;
  
  arg1 = (CFontRenderer *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mNewlineSpacing = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CFontRenderer_mNewlineSpacing_get(void * jarg1) {
  float jresult ;
  CFontRenderer *arg1 = (CFontRenderer *) 0 ;
  float result;
  
  arg1 = (CFontRenderer *)jarg1; 
  result = (float) ((arg1)->mNewlineSpacing);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CReflectionProbe_mStatic_set(void * jarg1, unsigned int jarg2) {
  CReflectionProbe *arg1 = (CReflectionProbe *) 0 ;
  bool arg2 ;
  
  arg1 = (CReflectionProbe *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->mStatic = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CReflectionProbe_mStatic_get(void * jarg1) {
  unsigned int jresult ;
  CReflectionProbe *arg1 = (CReflectionProbe *) 0 ;
  bool result;
  
  arg1 = (CReflectionProbe *)jarg1; 
  result = (bool) ((arg1)->mStatic);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CReflectionProbe_mProbeBoxDim_set(void * jarg1, void * jarg2) {
  CReflectionProbe *arg1 = (CReflectionProbe *) 0 ;
  Math::Vector3 *arg2 = (Math::Vector3 *) 0 ;
  
  arg1 = (CReflectionProbe *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2; 
  if (arg1) (arg1)->mProbeBoxDim = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CReflectionProbe_mProbeBoxDim_get(void * jarg1) {
  void * jresult ;
  CReflectionProbe *arg1 = (CReflectionProbe *) 0 ;
  Math::Vector3 *result = 0 ;
  
  arg1 = (CReflectionProbe *)jarg1; 
  result = (Math::Vector3 *)& ((arg1)->mProbeBoxDim);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_EmitterProperties_mUsedParticles_set(void * jarg1, unsigned int jarg2) {
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  unsigned int arg2 ;
  
  arg1 = (EmitterProperties *)jarg1; 
  arg2 = (unsigned int)jarg2; 
  if (arg1) (arg1)->mUsedParticles = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_EmitterProperties_mUsedParticles_get(void * jarg1) {
  unsigned int jresult ;
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  unsigned int result;
  
  arg1 = (EmitterProperties *)jarg1; 
  result = (unsigned int) ((arg1)->mUsedParticles);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_EmitterProperties_mWarmCount_set(void * jarg1, int jarg2) {
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  int arg2 ;
  
  arg1 = (EmitterProperties *)jarg1; 
  arg2 = (int)jarg2; 
  if (arg1) (arg1)->mWarmCount = arg2;
}


SWIGEXPORT int SWIGSTDCALL CSharp_EmitterProperties_mWarmCount_get(void * jarg1) {
  int jresult ;
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  int result;
  
  arg1 = (EmitterProperties *)jarg1; 
  result = (int) ((arg1)->mWarmCount);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_EmitterProperties_mMinLifetime_set(void * jarg1, float jarg2) {
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  float arg2 ;
  
  arg1 = (EmitterProperties *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mMinLifetime = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_EmitterProperties_mMinLifetime_get(void * jarg1) {
  float jresult ;
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  float result;
  
  arg1 = (EmitterProperties *)jarg1; 
  result = (float) ((arg1)->mMinLifetime);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_EmitterProperties_mMaxLifetime_set(void * jarg1, float jarg2) {
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  float arg2 ;
  
  arg1 = (EmitterProperties *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mMaxLifetime = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_EmitterProperties_mMaxLifetime_get(void * jarg1) {
  float jresult ;
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  float result;
  
  arg1 = (EmitterProperties *)jarg1; 
  result = (float) ((arg1)->mMaxLifetime);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_EmitterProperties_mMinVel_set(void * jarg1, float jarg2) {
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  float arg2 ;
  
  arg1 = (EmitterProperties *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mMinVel = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_EmitterProperties_mMinVel_get(void * jarg1) {
  float jresult ;
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  float result;
  
  arg1 = (EmitterProperties *)jarg1; 
  result = (float) ((arg1)->mMinVel);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_EmitterProperties_mMaxVel_set(void * jarg1, float jarg2) {
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  float arg2 ;
  
  arg1 = (EmitterProperties *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mMaxVel = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_EmitterProperties_mMaxVel_get(void * jarg1) {
  float jresult ;
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  float result;
  
  arg1 = (EmitterProperties *)jarg1; 
  result = (float) ((arg1)->mMaxVel);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_EmitterProperties_mStartSize_set(void * jarg1, float jarg2) {
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  float arg2 ;
  
  arg1 = (EmitterProperties *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mStartSize = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_EmitterProperties_mStartSize_get(void * jarg1) {
  float jresult ;
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  float result;
  
  arg1 = (EmitterProperties *)jarg1; 
  result = (float) ((arg1)->mStartSize);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_EmitterProperties_mEndSize_set(void * jarg1, float jarg2) {
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  float arg2 ;
  
  arg1 = (EmitterProperties *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mEndSize = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_EmitterProperties_mEndSize_get(void * jarg1) {
  float jresult ;
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  float result;
  
  arg1 = (EmitterProperties *)jarg1; 
  result = (float) ((arg1)->mEndSize);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_EmitterProperties_mFadeStartAmt_set(void * jarg1, float jarg2) {
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  float arg2 ;
  
  arg1 = (EmitterProperties *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mFadeStartAmt = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_EmitterProperties_mFadeStartAmt_get(void * jarg1) {
  float jresult ;
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  float result;
  
  arg1 = (EmitterProperties *)jarg1; 
  result = (float) ((arg1)->mFadeStartAmt);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_EmitterProperties_mFadeEndAmt_set(void * jarg1, float jarg2) {
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  float arg2 ;
  
  arg1 = (EmitterProperties *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mFadeEndAmt = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_EmitterProperties_mFadeEndAmt_get(void * jarg1) {
  float jresult ;
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  float result;
  
  arg1 = (EmitterProperties *)jarg1; 
  result = (float) ((arg1)->mFadeEndAmt);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_EmitterProperties_mStartColour_set(void * jarg1, void * jarg2) {
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  Color *arg2 = (Color *) 0 ;
  
  arg1 = (EmitterProperties *)jarg1; 
  arg2 = (Color *)jarg2; 
  if (arg1) (arg1)->mStartColour = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_EmitterProperties_mStartColour_get(void * jarg1) {
  void * jresult ;
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  Color *result = 0 ;
  
  arg1 = (EmitterProperties *)jarg1; 
  result = (Color *)& ((arg1)->mStartColour);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_EmitterProperties_mEndColour_set(void * jarg1, void * jarg2) {
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  Color *arg2 = (Color *) 0 ;
  
  arg1 = (EmitterProperties *)jarg1; 
  arg2 = (Color *)jarg2; 
  if (arg1) (arg1)->mEndColour = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_EmitterProperties_mEndColour_get(void * jarg1) {
  void * jresult ;
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  Color *result = 0 ;
  
  arg1 = (EmitterProperties *)jarg1; 
  result = (Color *)& ((arg1)->mEndColour);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_EmitterProperties_mEmissionAngleVariance_set(void * jarg1, float jarg2) {
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  float arg2 ;
  
  arg1 = (EmitterProperties *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mEmissionAngleVariance = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_EmitterProperties_mEmissionAngleVariance_get(void * jarg1) {
  float jresult ;
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  float result;
  
  arg1 = (EmitterProperties *)jarg1; 
  result = (float) ((arg1)->mEmissionAngleVariance);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_EmitterProperties_mEmissionAngle_set(void * jarg1, void * jarg2) {
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  Math::Vector3 *arg2 = (Math::Vector3 *) 0 ;
  
  arg1 = (EmitterProperties *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2; 
  if (arg1) (arg1)->mEmissionAngle = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_EmitterProperties_mEmissionAngle_get(void * jarg1) {
  void * jresult ;
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  Math::Vector3 *result = 0 ;
  
  arg1 = (EmitterProperties *)jarg1; 
  result = (Math::Vector3 *)& ((arg1)->mEmissionAngle);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_EmitterProperties_mIsEmitting_set(void * jarg1, unsigned int jarg2) {
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  bool arg2 ;
  
  arg1 = (EmitterProperties *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->mIsEmitting = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_EmitterProperties_mIsEmitting_get(void * jarg1) {
  unsigned int jresult ;
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  bool result;
  
  arg1 = (EmitterProperties *)jarg1; 
  result = (bool) ((arg1)->mIsEmitting);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_EmitterProperties_mGravityFactor_set(void * jarg1, float jarg2) {
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  float arg2 ;
  
  arg1 = (EmitterProperties *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mGravityFactor = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_EmitterProperties_mGravityFactor_get(void * jarg1) {
  float jresult ;
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  float result;
  
  arg1 = (EmitterProperties *)jarg1; 
  result = (float) ((arg1)->mGravityFactor);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_EmitterProperties_mRadius_set(void * jarg1, float jarg2) {
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  float arg2 ;
  
  arg1 = (EmitterProperties *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mRadius = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_EmitterProperties_mRadius_get(void * jarg1) {
  float jresult ;
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  float result;
  
  arg1 = (EmitterProperties *)jarg1; 
  result = (float) ((arg1)->mRadius);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_EmitterProperties_mAttractorPos_set(void * jarg1, void * jarg2) {
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  Math::Vector3 *arg2 = (Math::Vector3 *) 0 ;
  
  arg1 = (EmitterProperties *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2; 
  if (arg1) (arg1)->mAttractorPos = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_EmitterProperties_mAttractorPos_get(void * jarg1) {
  void * jresult ;
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  Math::Vector3 *result = 0 ;
  
  arg1 = (EmitterProperties *)jarg1; 
  result = (Math::Vector3 *)& ((arg1)->mAttractorPos);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_EmitterProperties_mAttracted_set(void * jarg1, unsigned int jarg2) {
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  bool arg2 ;
  
  arg1 = (EmitterProperties *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->mAttracted = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_EmitterProperties_mAttracted_get(void * jarg1) {
  unsigned int jresult ;
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  bool result;
  
  arg1 = (EmitterProperties *)jarg1; 
  result = (bool) ((arg1)->mAttracted);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_EmitterProperties_mAttractorLocalSpace_set(void * jarg1, unsigned int jarg2) {
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  bool arg2 ;
  
  arg1 = (EmitterProperties *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->mAttractorLocalSpace = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_EmitterProperties_mAttractorLocalSpace_get(void * jarg1) {
  unsigned int jresult ;
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  bool result;
  
  arg1 = (EmitterProperties *)jarg1; 
  result = (bool) ((arg1)->mAttractorLocalSpace);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_EmitterProperties_mAttractorFactor_set(void * jarg1, float jarg2) {
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  float arg2 ;
  
  arg1 = (EmitterProperties *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mAttractorFactor = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_EmitterProperties_mAttractorFactor_get(void * jarg1) {
  float jresult ;
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  float result;
  
  arg1 = (EmitterProperties *)jarg1; 
  result = (float) ((arg1)->mAttractorFactor);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_EmitterProperties_mIsOneShot_set(void * jarg1, unsigned int jarg2) {
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  bool arg2 ;
  
  arg1 = (EmitterProperties *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->mIsOneShot = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_EmitterProperties_mIsOneShot_get(void * jarg1) {
  unsigned int jresult ;
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  bool result;
  
  arg1 = (EmitterProperties *)jarg1; 
  result = (bool) ((arg1)->mIsOneShot);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_EmitterProperties_mRandomDirection_set(void * jarg1, unsigned int jarg2) {
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  bool arg2 ;
  
  arg1 = (EmitterProperties *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->mRandomDirection = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_EmitterProperties_mRandomDirection_get(void * jarg1) {
  unsigned int jresult ;
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  bool result;
  
  arg1 = (EmitterProperties *)jarg1; 
  result = (bool) ((arg1)->mRandomDirection);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_EmitterProperties_mDeceleration_set(void * jarg1, unsigned int jarg2) {
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  bool arg2 ;
  
  arg1 = (EmitterProperties *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->mDeceleration = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_EmitterProperties_mDeceleration_get(void * jarg1) {
  unsigned int jresult ;
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  bool result;
  
  arg1 = (EmitterProperties *)jarg1; 
  result = (bool) ((arg1)->mDeceleration);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_EmitterProperties_mSpawnInGeometry_set(void * jarg1, unsigned int jarg2) {
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  bool arg2 ;
  
  arg1 = (EmitterProperties *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->mSpawnInGeometry = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_EmitterProperties_mSpawnInGeometry_get(void * jarg1) {
  unsigned int jresult ;
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  bool result;
  
  arg1 = (EmitterProperties *)jarg1; 
  result = (bool) ((arg1)->mSpawnInGeometry);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_EmitterProperties_mDieInGeometry_set(void * jarg1, unsigned int jarg2) {
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  bool arg2 ;
  
  arg1 = (EmitterProperties *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->mDieInGeometry = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_EmitterProperties_mDieInGeometry_get(void * jarg1) {
  unsigned int jresult ;
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  bool result;
  
  arg1 = (EmitterProperties *)jarg1; 
  result = (bool) ((arg1)->mDieInGeometry);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_EmitterProperties_mNormal_set(void * jarg1, void * jarg2) {
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  Math::Vector3 *arg2 = (Math::Vector3 *) 0 ;
  
  arg1 = (EmitterProperties *)jarg1; 
  arg2 = (Math::Vector3 *)jarg2; 
  if (arg1) (arg1)->mNormal = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_EmitterProperties_mNormal_get(void * jarg1) {
  void * jresult ;
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  Math::Vector3 *result = 0 ;
  
  arg1 = (EmitterProperties *)jarg1; 
  result = (Math::Vector3 *)& ((arg1)->mNormal);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_EmitterProperties_mPlaneEmit_set(void * jarg1, unsigned int jarg2) {
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  bool arg2 ;
  
  arg1 = (EmitterProperties *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->mPlaneEmit = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_EmitterProperties_mPlaneEmit_get(void * jarg1) {
  unsigned int jresult ;
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  bool result;
  
  arg1 = (EmitterProperties *)jarg1; 
  result = (bool) ((arg1)->mPlaneEmit);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_EmitterProperties_mType_set(void * jarg1, int jarg2) {
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  ParticleEmissionType arg2 ;
  
  arg1 = (EmitterProperties *)jarg1; 
  arg2 = (ParticleEmissionType)jarg2; 
  if (arg1) (arg1)->mType = arg2;
}


SWIGEXPORT int SWIGSTDCALL CSharp_EmitterProperties_mType_get(void * jarg1) {
  int jresult ;
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  ParticleEmissionType result;
  
  arg1 = (EmitterProperties *)jarg1; 
  result = (ParticleEmissionType) ((arg1)->mType);
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_EmitterProperties() {
  void * jresult ;
  EmitterProperties *result = 0 ;
  
  result = (EmitterProperties *)new EmitterProperties();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_EmitterProperties(void * jarg1) {
  EmitterProperties *arg1 = (EmitterProperties *) 0 ;
  
  arg1 = (EmitterProperties *)jarg1; 
  delete arg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CParticleEmitter_GetGPUShader(void * jarg1) {
  void * jresult ;
  CParticleEmitter *arg1 = (CParticleEmitter *) 0 ;
  GPUShader *result = 0 ;
  
  arg1 = (CParticleEmitter *)jarg1; 
  result = (GPUShader *)((CParticleEmitter const *)arg1)->GetGPUShader();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CParticleEmitter_SetGPUShader(void * jarg1, void * jarg2) {
  CParticleEmitter *arg1 = (CParticleEmitter *) 0 ;
  GPUShader *arg2 = (GPUShader *) 0 ;
  
  arg1 = (CParticleEmitter *)jarg1; 
  arg2 = (GPUShader *)jarg2; 
  (arg1)->SetGPUShader(arg2);
}


SWIGEXPORT int SWIGSTDCALL CSharp_CParticleEmitter_GetBehaviour__SWIG_0(void * jarg1) {
  int jresult ;
  CParticleEmitter *arg1 = (CParticleEmitter *) 0 ;
  ParticleBehaviour result;
  
  arg1 = (CParticleEmitter *)jarg1; 
  result = (ParticleBehaviour)((CParticleEmitter const *)arg1)->GetBehaviour();
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CParticleEmitter_GetBehaviour__SWIG_1(void * jarg1, int jarg2) {
  CParticleEmitter *arg1 = (CParticleEmitter *) 0 ;
  ParticleBehaviour arg2 ;
  
  arg1 = (CParticleEmitter *)jarg1; 
  arg2 = (ParticleBehaviour)jarg2; 
  (arg1)->GetBehaviour(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CParticleEmitter_TriggerOneShot(void * jarg1) {
  CParticleEmitter *arg1 = (CParticleEmitter *) 0 ;
  
  arg1 = (CParticleEmitter *)jarg1; 
  (arg1)->TriggerOneShot();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CParticleEmitter_mEmitterProperty_set(void * jarg1, void * jarg2) {
  CParticleEmitter *arg1 = (CParticleEmitter *) 0 ;
  EmitterProperties *arg2 = (EmitterProperties *) 0 ;
  
  arg1 = (CParticleEmitter *)jarg1; 
  arg2 = (EmitterProperties *)jarg2; 
  if (arg1) (arg1)->mEmitterProperty = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CParticleEmitter_mEmitterProperty_get(void * jarg1) {
  void * jresult ;
  CParticleEmitter *arg1 = (CParticleEmitter *) 0 ;
  EmitterProperties *result = 0 ;
  
  arg1 = (CParticleEmitter *)jarg1; 
  result = (EmitterProperties *)& ((arg1)->mEmitterProperty);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CBloom_mBloomFactor_set(void * jarg1, float jarg2) {
  CBloom *arg1 = (CBloom *) 0 ;
  float arg2 ;
  
  arg1 = (CBloom *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mBloomFactor = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CBloom_mBloomFactor_get(void * jarg1) {
  float jresult ;
  CBloom *arg1 = (CBloom *) 0 ;
  float result;
  
  arg1 = (CBloom *)jarg1; 
  result = (float) ((arg1)->mBloomFactor);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CMotionBlur_mBlurFactor_set(void * jarg1, int jarg2) {
  CMotionBlur *arg1 = (CMotionBlur *) 0 ;
  int arg2 ;
  
  arg1 = (CMotionBlur *)jarg1; 
  arg2 = (int)jarg2; 
  if (arg1) (arg1)->mBlurFactor = arg2;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CMotionBlur_mBlurFactor_get(void * jarg1) {
  int jresult ;
  CMotionBlur *arg1 = (CMotionBlur *) 0 ;
  int result;
  
  arg1 = (CMotionBlur *)jarg1; 
  result = (int) ((arg1)->mBlurFactor);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CFilmGrain_mBarHeight_set(void * jarg1, float jarg2) {
  CFilmGrain *arg1 = (CFilmGrain *) 0 ;
  float arg2 ;
  
  arg1 = (CFilmGrain *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mBarHeight = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CFilmGrain_mBarHeight_get(void * jarg1) {
  float jresult ;
  CFilmGrain *arg1 = (CFilmGrain *) 0 ;
  float result;
  
  arg1 = (CFilmGrain *)jarg1; 
  result = (float) ((arg1)->mBarHeight);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CFilmGrain_mBarSpeed_set(void * jarg1, float jarg2) {
  CFilmGrain *arg1 = (CFilmGrain *) 0 ;
  float arg2 ;
  
  arg1 = (CFilmGrain *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mBarSpeed = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CFilmGrain_mBarSpeed_get(void * jarg1) {
  float jresult ;
  CFilmGrain *arg1 = (CFilmGrain *) 0 ;
  float result;
  
  arg1 = (CFilmGrain *)jarg1; 
  result = (float) ((arg1)->mBarSpeed);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CFilmGrain_mBarOverflow_set(void * jarg1, float jarg2) {
  CFilmGrain *arg1 = (CFilmGrain *) 0 ;
  float arg2 ;
  
  arg1 = (CFilmGrain *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mBarOverflow = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CFilmGrain_mBarOverflow_get(void * jarg1) {
  float jresult ;
  CFilmGrain *arg1 = (CFilmGrain *) 0 ;
  float result;
  
  arg1 = (CFilmGrain *)jarg1; 
  result = (float) ((arg1)->mBarOverflow);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CFilmGrain_mNoiseDensity_set(void * jarg1, float jarg2) {
  CFilmGrain *arg1 = (CFilmGrain *) 0 ;
  float arg2 ;
  
  arg1 = (CFilmGrain *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mNoiseDensity = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CFilmGrain_mNoiseDensity_get(void * jarg1) {
  float jresult ;
  CFilmGrain *arg1 = (CFilmGrain *) 0 ;
  float result;
  
  arg1 = (CFilmGrain *)jarg1; 
  result = (float) ((arg1)->mNoiseDensity);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CFilmGrain_mPixelDensity_set(void * jarg1, float jarg2) {
  CFilmGrain *arg1 = (CFilmGrain *) 0 ;
  float arg2 ;
  
  arg1 = (CFilmGrain *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mPixelDensity = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CFilmGrain_mPixelDensity_get(void * jarg1) {
  float jresult ;
  CFilmGrain *arg1 = (CFilmGrain *) 0 ;
  float result;
  
  arg1 = (CFilmGrain *)jarg1; 
  result = (float) ((arg1)->mPixelDensity);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CArtifactFX_mBlockThreshold_set(void * jarg1, float jarg2) {
  CArtifactFX *arg1 = (CArtifactFX *) 0 ;
  float arg2 ;
  
  arg1 = (CArtifactFX *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mBlockThreshold = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CArtifactFX_mBlockThreshold_get(void * jarg1) {
  float jresult ;
  CArtifactFX *arg1 = (CArtifactFX *) 0 ;
  float result;
  
  arg1 = (CArtifactFX *)jarg1; 
  result = (float) ((arg1)->mBlockThreshold);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CArtifactFX_mLineThreshold_set(void * jarg1, float jarg2) {
  CArtifactFX *arg1 = (CArtifactFX *) 0 ;
  float arg2 ;
  
  arg1 = (CArtifactFX *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mLineThreshold = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CArtifactFX_mLineThreshold_get(void * jarg1) {
  float jresult ;
  CArtifactFX *arg1 = (CArtifactFX *) 0 ;
  float result;
  
  arg1 = (CArtifactFX *)jarg1; 
  result = (float) ((arg1)->mLineThreshold);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CShadowProbe_mStatic_set(void * jarg1, unsigned int jarg2) {
  CShadowProbe *arg1 = (CShadowProbe *) 0 ;
  bool arg2 ;
  
  arg1 = (CShadowProbe *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->mStatic = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CShadowProbe_mStatic_get(void * jarg1) {
  unsigned int jresult ;
  CShadowProbe *arg1 = (CShadowProbe *) 0 ;
  bool result;
  
  arg1 = (CShadowProbe *)jarg1; 
  result = (bool) ((arg1)->mStatic);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CShadowProbe_mStrength_set(void * jarg1, float jarg2) {
  CShadowProbe *arg1 = (CShadowProbe *) 0 ;
  float arg2 ;
  
  arg1 = (CShadowProbe *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mStrength = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CShadowProbe_mStrength_get(void * jarg1) {
  float jresult ;
  CShadowProbe *arg1 = (CShadowProbe *) 0 ;
  float result;
  
  arg1 = (CShadowProbe *)jarg1; 
  result = (float) ((arg1)->mStrength);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CShadowProbe_mBias_set(void * jarg1, float jarg2) {
  CShadowProbe *arg1 = (CShadowProbe *) 0 ;
  float arg2 ;
  
  arg1 = (CShadowProbe *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mBias = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CShadowProbe_mBias_get(void * jarg1) {
  float jresult ;
  CShadowProbe *arg1 = (CShadowProbe *) 0 ;
  float result;
  
  arg1 = (CShadowProbe *)jarg1; 
  result = (float) ((arg1)->mBias);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CShadowProbe_mUseSoftShadows_set(void * jarg1, unsigned int jarg2) {
  CShadowProbe *arg1 = (CShadowProbe *) 0 ;
  bool arg2 ;
  
  arg1 = (CShadowProbe *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->mUseSoftShadows = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CShadowProbe_mUseSoftShadows_get(void * jarg1) {
  unsigned int jresult ;
  CShadowProbe *arg1 = (CShadowProbe *) 0 ;
  bool result;
  
  arg1 = (CShadowProbe *)jarg1; 
  result = (bool) ((arg1)->mUseSoftShadows);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CShadowProbe_mNearZ_set(void * jarg1, float jarg2) {
  CShadowProbe *arg1 = (CShadowProbe *) 0 ;
  float arg2 ;
  
  arg1 = (CShadowProbe *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mNearZ = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CShadowProbe_mNearZ_get(void * jarg1) {
  float jresult ;
  CShadowProbe *arg1 = (CShadowProbe *) 0 ;
  float result;
  
  arg1 = (CShadowProbe *)jarg1; 
  result = (float) ((arg1)->mNearZ);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CShadowProbe_mFarZ_set(void * jarg1, float jarg2) {
  CShadowProbe *arg1 = (CShadowProbe *) 0 ;
  float arg2 ;
  
  arg1 = (CShadowProbe *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->mFarZ = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CShadowProbe_mFarZ_get(void * jarg1) {
  float jresult ;
  CShadowProbe *arg1 = (CShadowProbe *) 0 ;
  float result;
  
  arg1 = (CShadowProbe *)jarg1; 
  result = (float) ((arg1)->mFarZ);
  jresult = result; 
  return jresult;
}


SWIGEXPORT IMeta * SWIGSTDCALL CSharp_Asset_SWIGUpcast(Asset *jarg1) {
    return (IMeta *)jarg1;
}

SWIGEXPORT IMeta * SWIGSTDCALL CSharp_AssetManager_SWIGUpcast(AssetManager *jarg1) {
    return (IMeta *)jarg1;
}

SWIGEXPORT Asset * SWIGSTDCALL CSharp_Mesh_SWIGUpcast(Mesh *jarg1) {
    return (Asset *)jarg1;
}

SWIGEXPORT BaseState * SWIGSTDCALL CSharp_EditorState_SWIGUpcast(EditorState *jarg1) {
    return (BaseState *)jarg1;
}

SWIGEXPORT IMeta * SWIGSTDCALL CSharp_MatAttribNode_SWIGUpcast(MatAttribNode *jarg1) {
    return (IMeta *)jarg1;
}

SWIGEXPORT MatAttribNode * SWIGSTDCALL CSharp_TextureNode_SWIGUpcast(TextureNode *jarg1) {
    return (MatAttribNode *)jarg1;
}

SWIGEXPORT MatAttribNode * SWIGSTDCALL CSharp_ColorNode_SWIGUpcast(ColorNode *jarg1) {
    return (MatAttribNode *)jarg1;
}

SWIGEXPORT MatAttribNode * SWIGSTDCALL CSharp_ShaderNode_SWIGUpcast(ShaderNode *jarg1) {
    return (MatAttribNode *)jarg1;
}

SWIGEXPORT MatAttribNode * SWIGSTDCALL CSharp_UVTransformNode_SWIGUpcast(UVTransformNode *jarg1) {
    return (MatAttribNode *)jarg1;
}

SWIGEXPORT Asset * SWIGSTDCALL CSharp_Animation_SWIGUpcast(Animation *jarg1) {
    return (Asset *)jarg1;
}

SWIGEXPORT IMeta * SWIGSTDCALL CSharp_Component_SWIGUpcast(Component *jarg1) {
    return (IMeta *)jarg1;
}

SWIGEXPORT Component * SWIGSTDCALL CSharp_CTransform_SWIGUpcast(CTransform *jarg1) {
    return (Component *)jarg1;
}

SWIGEXPORT Component * SWIGSTDCALL CSharp_CRenderer_SWIGUpcast(CRenderer *jarg1) {
    return (Component *)jarg1;
}

SWIGEXPORT CRenderer * SWIGSTDCALL CSharp_CMeshRenderer_SWIGUpcast(CMeshRenderer *jarg1) {
    return (CRenderer *)jarg1;
}

SWIGEXPORT CRenderer * SWIGSTDCALL CSharp_CSkinMeshRenderer_SWIGUpcast(CSkinMeshRenderer *jarg1) {
    return (CRenderer *)jarg1;
}

SWIGEXPORT Component * SWIGSTDCALL CSharp_CAnimationController_SWIGUpcast(CAnimationController *jarg1) {
    return (Component *)jarg1;
}

SWIGEXPORT Component * SWIGSTDCALL CSharp_CLight_SWIGUpcast(CLight *jarg1) {
    return (Component *)jarg1;
}

SWIGEXPORT Component * SWIGSTDCALL CSharp_CPhysics_SWIGUpcast(CPhysics *jarg1) {
    return (Component *)jarg1;
}

SWIGEXPORT IMeta * SWIGSTDCALL CSharp_CollisionData_SWIGUpcast(CollisionData *jarg1) {
    return (IMeta *)jarg1;
}

SWIGEXPORT Component * SWIGSTDCALL CSharp_ColliderComponent_SWIGUpcast(ColliderComponent *jarg1) {
    return (Component *)jarg1;
}

SWIGEXPORT ColliderComponent * SWIGSTDCALL CSharp_CBoxColliderComponent_SWIGUpcast(CBoxColliderComponent *jarg1) {
    return (ColliderComponent *)jarg1;
}

SWIGEXPORT ColliderComponent * SWIGSTDCALL CSharp_CMeshColliderComponent_SWIGUpcast(CMeshColliderComponent *jarg1) {
    return (ColliderComponent *)jarg1;
}

SWIGEXPORT ColliderComponent * SWIGSTDCALL CSharp_CSphereColliderComponent_SWIGUpcast(CSphereColliderComponent *jarg1) {
    return (ColliderComponent *)jarg1;
}

SWIGEXPORT Component * SWIGSTDCALL CSharp_CCamera_SWIGUpcast(CCamera *jarg1) {
    return (Component *)jarg1;
}

SWIGEXPORT Component * SWIGSTDCALL CSharp_CSound_SWIGUpcast(CSound *jarg1) {
    return (Component *)jarg1;
}

SWIGEXPORT Component * SWIGSTDCALL CSharp_CZone_SWIGUpcast(CZone *jarg1) {
    return (Component *)jarg1;
}

SWIGEXPORT Component * SWIGSTDCALL CSharp_CMapZone_SWIGUpcast(CMapZone *jarg1) {
    return (Component *)jarg1;
}

SWIGEXPORT Component * SWIGSTDCALL CSharp_CStreamMarker_SWIGUpcast(CStreamMarker *jarg1) {
    return (Component *)jarg1;
}

SWIGEXPORT Component * SWIGSTDCALL CSharp_CStreamZoneListener_SWIGUpcast(CStreamZoneListener *jarg1) {
    return (Component *)jarg1;
}

SWIGEXPORT Component * SWIGSTDCALL CSharp_CStreamZone_SWIGUpcast(CStreamZone *jarg1) {
    return (Component *)jarg1;
}

SWIGEXPORT Component * SWIGSTDCALL CSharp_CScript_SWIGUpcast(CScript *jarg1) {
    return (Component *)jarg1;
}

SWIGEXPORT CRenderer * SWIGSTDCALL CSharp_CDiffuseRenderer_SWIGUpcast(CDiffuseRenderer *jarg1) {
    return (CRenderer *)jarg1;
}

SWIGEXPORT CRenderer * SWIGSTDCALL CSharp_CForwardRenderer_SWIGUpcast(CForwardRenderer *jarg1) {
    return (CRenderer *)jarg1;
}

SWIGEXPORT CDiffuseRenderer * SWIGSTDCALL CSharp_CFontRenderer_SWIGUpcast(CFontRenderer *jarg1) {
    return (CDiffuseRenderer *)jarg1;
}

SWIGEXPORT Component * SWIGSTDCALL CSharp_CReflectionProbe_SWIGUpcast(CReflectionProbe *jarg1) {
    return (Component *)jarg1;
}

SWIGEXPORT Component * SWIGSTDCALL CSharp_CConvexHull_SWIGUpcast(CConvexHull *jarg1) {
    return (Component *)jarg1;
}

SWIGEXPORT Component * SWIGSTDCALL CSharp_CParticleEmitter_SWIGUpcast(CParticleEmitter *jarg1) {
    return (Component *)jarg1;
}

SWIGEXPORT CRenderer * SWIGSTDCALL CSharp_CParticleRenderer_SWIGUpcast(CParticleRenderer *jarg1) {
    return (CRenderer *)jarg1;
}

SWIGEXPORT Component * SWIGSTDCALL CSharp_CPostProcess_SWIGUpcast(CPostProcess *jarg1) {
    return (Component *)jarg1;
}

SWIGEXPORT CPostProcess * SWIGSTDCALL CSharp_CBloom_SWIGUpcast(CBloom *jarg1) {
    return (CPostProcess *)jarg1;
}

SWIGEXPORT CPostProcess * SWIGSTDCALL CSharp_CMotionBlur_SWIGUpcast(CMotionBlur *jarg1) {
    return (CPostProcess *)jarg1;
}

SWIGEXPORT CPostProcess * SWIGSTDCALL CSharp_CCensorFX_SWIGUpcast(CCensorFX *jarg1) {
    return (CPostProcess *)jarg1;
}

SWIGEXPORT CPostProcess * SWIGSTDCALL CSharp_CFilmGrain_SWIGUpcast(CFilmGrain *jarg1) {
    return (CPostProcess *)jarg1;
}

SWIGEXPORT CPostProcess * SWIGSTDCALL CSharp_CChromaticAberration_SWIGUpcast(CChromaticAberration *jarg1) {
    return (CPostProcess *)jarg1;
}

SWIGEXPORT CPostProcess * SWIGSTDCALL CSharp_CArtifactFX_SWIGUpcast(CArtifactFX *jarg1) {
    return (CPostProcess *)jarg1;
}

SWIGEXPORT Component * SWIGSTDCALL CSharp_CShadowProbe_SWIGUpcast(CShadowProbe *jarg1) {
    return (Component *)jarg1;
}

#ifdef __cplusplus
}
#endif

